<!DOCTYPE html><html lang="zh-CN"><head><meta charset="UTF-8"><meta name="viewport" content="width=device-width"><meta name="theme-color" content="#222"><meta name="generator" content="Hexo 6.3.0"><link rel="preconnect" href="https://fonts.googleapis.com" crossorigin><link rel="preconnect" href="https://cdnjs.cloudflare.com" crossorigin><link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon.png"><link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32.png"><link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16.png"><link rel="mask-icon" href="/images/logo.svg" color="#222"><link rel="manifest" href="/images/manifest.json"><link rel="stylesheet" href="/css/main.css"><link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Lato:300,300italic,400,400italic,700,700italic%7CPT+Sans:300,300italic,400,400italic,700,700italic%7CFira+Code:300,300italic,400,400italic,700,700italic&display=swap&subset=latin,latin-ext"><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.2.0/css/all.min.css" integrity="sha256-AbA177XfpSnFEvgpYu1jMygiLabzPCJCRIBtR5jGc0k=" crossorigin="anonymous"><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/animate.css/3.1.1/animate.min.css" integrity="sha256-PR7ttpcvz8qrF57fur/yAx1qXMFJeJFiA6pSzWi0OIE=" crossorigin="anonymous"><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/fancybox/3.5.7/jquery.fancybox.min.css" integrity="sha256-Vzbj7sDDS/woiFS3uNKo8eIuni59rjyNGtXfstRzStA=" crossorigin="anonymous"><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/pace/1.2.4/themes/greem/pace-theme-minimal.css"><script src="https://cdnjs.cloudflare.com/ajax/libs/pace/1.2.4/pace.min.js" integrity="sha256-gqd7YTjg/BtfqWSwsJOvndl0Bxc8gFImLEkXQT8+qj0=" crossorigin="anonymous"></script><script class="next-config" data-name="main" type="application/json">{"hostname":"blog.liukairui.me","root":"/","images":"/images","scheme":"Mist","darkmode":false,"version":"8.13.1","exturl":true,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"width":320},"copycode":{"enable":true,"style":"flat"},"bookmark":{"enable":false,"color":"#222","save":"auto"},"mediumzoom":false,"lazyload":false,"pangu":true,"comments":{"style":"tabs","active":"valine","storage":true,"lazyload":false,"nav":null,"activeClass":"valine"},"stickytabs":false,"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"fadeInDown","post_body":"fadeInDown","coll_header":"fadeInLeft","sidebar":"fadeInUp"}},"prism":false,"i18n":{"placeholder":"搜索...","empty":"没有找到任何搜索结果：${query}","hits_time":"找到 ${hits} 个搜索结果（用时 ${time} 毫秒）","hits":"找到 ${hits} 个搜索结果"},"algolia":{"appID":"GPJGYFJZH3","apiKey":"594eec10fca5caccffae82e82d066310","indexName":"hexo","hits":{"per_page":10}}}</script><script src="/js/config.js"></script><meta name="description" content="转变思维🤔. 从思考How(怎么编写指令)到思考What(我们要解决的问题是什么). 最初我以为函数式编程就是思考如何用函数(数学)的方式描述问题. 但逐渐发现函数式编程的重点是如何操作函数去描述函数. 总之, 他值得一学!😎"><meta property="og:type" content="article"><meta property="og:title" content="函数式编程Haskell初探"><meta property="og:url" content="https://blog.liukairui.me/article/%E5%87%BD%E6%95%B0%E5%BC%8F%E7%BC%96%E7%A8%8BHaskell%E5%88%9D%E6%8E%A2/"><meta property="og:site_name" content="LiuKairui&#39;s Blog"><meta property="og:description" content="转变思维🤔. 从思考How(怎么编写指令)到思考What(我们要解决的问题是什么). 最初我以为函数式编程就是思考如何用函数(数学)的方式描述问题. 但逐渐发现函数式编程的重点是如何操作函数去描述函数. 总之, 他值得一学!😎"><meta property="og:locale" content="zh_CN"><meta property="article:published_time" content="2022-03-02T16:00:01.000Z"><meta property="article:modified_time" content="2022-04-08T08:17:13.143Z"><meta property="article:author" content="Liu Kairui"><meta property="article:tag" content="瞎折腾"><meta property="article:tag" content="函数式编程"><meta property="article:tag" content="Haskell"><meta name="twitter:card" content="summary"><link rel="canonical" href="https://blog.liukairui.me/article/%E5%87%BD%E6%95%B0%E5%BC%8F%E7%BC%96%E7%A8%8BHaskell%E5%88%9D%E6%8E%A2/"><script class="next-config" data-name="page" type="application/json">{"sidebar":"","isHome":false,"isPost":true,"lang":"zh-CN","comments":true,"permalink":"https://blog.liukairui.me/article/%E5%87%BD%E6%95%B0%E5%BC%8F%E7%BC%96%E7%A8%8BHaskell%E5%88%9D%E6%8E%A2/","path":"article/函数式编程Haskell初探/","title":"函数式编程Haskell初探"}</script><script class="next-config" data-name="calendar" type="application/json">""</script><title>函数式编程Haskell初探 | LiuKairui's Blog</title><script>var titleTime,OriginTitile=document.title;document.addEventListener("visibilitychange",function(){document.hidden?(document.title="我们活着是为了什么? | "+OriginTitile,clearTimeout(titleTime)):(document.title="整点薯条 | "+OriginTitile,titleTime=setTimeout(function(){document.title=OriginTitile},2e3))})</script><noscript><link rel="stylesheet" href="/css/noscript.css"></noscript><link rel="alternate" href="/atom.xml" title="LiuKairui's Blog" type="application/atom+xml"><style>.darkmode--activated{--body-bg-color:#282828;--content-bg-color:#333;--card-bg-color:#555;--text-color:#ccc;--blockquote-color:#bbb;--link-color:#ccc;--link-hover-color:#eee;--brand-color:#ddd;--brand-hover-color:#ddd;--table-row-odd-bg-color:#282828;--table-row-hover-bg-color:#363636;--menu-item-bg-color:#555;--btn-default-bg:#222;--btn-default-color:#ccc;--btn-default-border-color:#555;--btn-default-hover-bg:#666;--btn-default-hover-color:#ccc;--btn-default-hover-border-color:#666;--highlight-background:#282b2e;--highlight-foreground:#a9b7c6;--highlight-gutter-background:#34393d;--highlight-gutter-foreground:#9ca9b6}.darkmode--activated img{opacity:.75}.darkmode--activated img:hover{opacity:.9}.darkmode--activated code{color:#69dbdc;background:0 0}button.darkmode-toggle{z-index:9999}.darkmode-ignore,img{display:flex!important}.beian img{display:inline-block!important}</style></head><body itemscope itemtype="http://schema.org/WebPage" class="use-motion"><div class="headband"></div><main class="main"><header class="header" itemscope itemtype="http://schema.org/WPHeader"><div class="header-inner"><div class="site-brand-container"><div class="site-nav-toggle"><div class="toggle" aria-label="切换导航栏" role="button"><span class="toggle-line"></span> <span class="toggle-line"></span> <span class="toggle-line"></span></div></div><div class="site-meta"><a href="/" class="brand" rel="start"><i class="logo-line"></i><p class="site-title">LiuKairui's Blog</p><i class="logo-line"></i></a><p class="site-subtitle" itemprop="description">整点薯条</p></div><div class="site-nav-right"><div class="toggle popup-trigger"><i class="fa fa-search fa-fw fa-lg"></i></div></div></div><nav class="site-nav"><ul class="main-menu menu"><li class="menu-item menu-item-home"><a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a></li><li class="menu-item menu-item-categories"><a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类</a></li><li class="menu-item menu-item-tags"><a href="/tags/" rel="section"><i class="fas fa-hashtag fa-fw"></i>标签</a></li><li class="menu-item menu-item-收藏夹"><a href="/favorites/" rel="section"><i class="fab fa-gratipay fa-fw"></i>收藏夹</a></li><li class="menu-item menu-item-留言板"><a href="/messageBoard/" rel="section"><i class="fab fa-facebook-messenger fa-fw"></i>留言板</a></li><li class="menu-item menu-item-项目"><a href="/projects/" rel="section"><i class="fa fa-satellite fa-fw"></i>项目</a></li><li class="menu-item menu-item-about"><a href="/about/" rel="section"><i class="fa fa-user fa-fw"></i>关于</a></li><li class="menu-item menu-item-search"><a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>搜索</a></li></ul></nav><div class="search-pop-overlay"><div class="popup search-popup"><div class="search-header"><span class="search-icon"><i class="fa fa-search"></i></span><div class="search-input-container"></div><span class="popup-btn-close" role="button"><i class="fa fa-times-circle"></i></span></div><div class="search-result-container"><div class="algolia-stats"><hr></div><div class="algolia-hits"></div><div class="algolia-pagination"></div></div></div></div><script async src="/js/wobblewindow.js"></script><script async>window.addEventListener("load",function(){768<window.innerWidth&&($("body>main>header").wobbleWindow({radius:50,movementTop:!1,movementLeft:!1,movementRight:!1,debug:!1}),$("body>footer").wobbleWindow({radius:50,movementBottom:!1,movementLeft:!1,movementRight:!1,debug:!1}))})</script></div><div class="toggle sidebar-toggle" role="button"><span class="toggle-line"></span> <span class="toggle-line"></span> <span class="toggle-line"></span></div><aside class="sidebar"><div class="sidebar-inner sidebar-nav-active sidebar-toc-active"><ul class="sidebar-nav"><li class="sidebar-nav-toc">文章目录</li><li class="sidebar-nav-overview">站点概览</li></ul><div class="sidebar-panel-container"><div class="post-toc-wrap sidebar-panel"><div class="post-toc animated"><ol class="nav"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%AE%80%E4%BB%8B"><span class="nav-text">简介</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%BC%98%E8%B5%B7"><span class="nav-text">缘起</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%BB%80%E4%B9%88%E6%98%AFhaskell%E5%87%BD%E6%95%B0%E5%BC%8F%E7%BC%96%E7%A8%8B"><span class="nav-text">什么是Haskell&#x2F;函数式编程</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE"><span class="nav-text">环境配置</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95"><span class="nav-text">基础语法</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E8%BF%90%E7%AE%97%E7%AC%A6"><span class="nav-text">运算符</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%87%BD%E6%95%B0%E8%B0%83%E7%94%A8"><span class="nav-text">函数调用</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%87%BD%E6%95%B0%E7%BC%96%E5%86%99"><span class="nav-text">函数编写</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#list%E7%B1%BB%E5%9E%8B%E5%9F%BA%E7%A1%80"><span class="nav-text">List类型基础</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#list%E7%9A%84range"><span class="nav-text">List的Range</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#list%E7%9A%84comprehension"><span class="nav-text">List的Comprehension</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#tuple%E7%B1%BB%E5%9E%8B%E5%9F%BA%E7%A1%80"><span class="nav-text">Tuple类型基础</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%B1%BB%E5%9E%8B%E4%B8%8E%E7%B1%BB%E5%9E%8B%E7%B1%BB"><span class="nav-text">类型与类型类</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%B1%BB%E5%9E%8Btypes"><span class="nav-text">类型(Types)</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%B1%BB%E5%9E%8B%E5%8F%98%E9%87%8Ftype-variables%E4%B8%8E%E7%B1%BB%E5%9E%8B%E7%B1%BBtype-variables"><span class="nav-text">类型变量(Type variables)与类型类(Type variables)</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%87%BD%E6%95%B0"><span class="nav-text">函数</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%A8%A1%E5%BC%8F%E5%8C%B9%E9%85%8Dpattern-matching"><span class="nav-text">模式匹配(Pattern matching)</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#guards%E5%AE%88%E5%8D%AB"><span class="nav-text">Guards(守卫)</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#where%E7%BB%91%E5%AE%9A"><span class="nav-text">Where绑定</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#let%E7%BB%91%E5%AE%9A"><span class="nav-text">Let绑定</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#case%E8%A1%A8%E8%BE%BE%E5%BC%8F"><span class="nav-text">Case表达式</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%B0%86%E5%87%BD%E6%95%B0%E5%AE%9A%E4%B9%89%E4%B8%BA%E4%B8%AD%E7%BC%80%E5%87%BD%E6%95%B0"><span class="nav-text">将函数定义为中缀函数</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%AE%9A%E4%B9%89%E5%87%BD%E6%95%B0%E7%9A%84%E7%BB%93%E5%90%88%E6%80%A7%E4%B8%8E%E4%BC%98%E5%85%88%E7%BA%A7"><span class="nav-text">定义函数的结合性与优先级</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%80%92%E5%BD%92"><span class="nav-text">递归</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%87%BD%E6%95%B0pro"><span class="nav-text">函数Pro</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%87%BD%E6%95%B0%E6%9F%AF%E9%87%8C%E5%8C%96%E4%B8%8E%E4%B8%8D%E5%85%A8%E8%B0%83%E7%94%A8"><span class="nav-text">函数柯里化与不全调用</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E9%AB%98%E9%98%B6%E5%87%BD%E6%95%B0"><span class="nav-text">高阶函数</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#lambda%E5%87%BD%E6%95%B0"><span class="nav-text">Lambda函数</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#mapfilterfoldscan"><span class="nav-text">map&amp;filter&amp;fold&amp;scan</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%B8%8E.%E8%B0%83%E7%94%A8"><span class="nav-text">$与.调用</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%A8%A1%E5%9D%97"><span class="nav-text">模块</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#data.list%E6%A8%A1%E5%9D%97"><span class="nav-text">Data.List模块</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#data.char%E6%A8%A1%E5%9D%97"><span class="nav-text">Data.Char模块</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#data.map%E6%A8%A1%E5%9D%97"><span class="nav-text">Data.Map模块</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#data.set-%E6%A8%A1%E5%9D%97"><span class="nav-text">Data.Set 模块</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%A3%B0%E6%98%8E%E6%A8%A1%E5%9D%97"><span class="nav-text">声明模块</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%A3%B0%E6%98%8E%E7%B1%BB%E5%9E%8B%E4%B8%8E%E7%B1%BB%E5%9E%8B%E7%B1%BB"><span class="nav-text">声明类型与类型类</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%BB%A3%E6%95%B0%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B"><span class="nav-text">代数数据类型</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#record-syntax"><span class="nav-text">Record Syntax</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%B1%BB%E5%9E%8B%E5%8F%82%E6%95%B0"><span class="nav-text">类型参数</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E9%80%92%E5%BD%92%E5%AE%9A%E4%B9%89%E7%B1%BB%E5%9E%8B"><span class="nav-text">递归定义类型</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%B1%BB%E5%9E%8B%E5%88%AB%E5%90%8D"><span class="nav-text">类型别名</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%B4%BE%E7%94%9F"><span class="nav-text">派生</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%AE%9A%E4%B9%89typeclasses"><span class="nav-text">定义TypeClasses</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#functor-typeclass"><span class="nav-text">Functor typeclass</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#kind"><span class="nav-text">Kind</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%BE%93%E5%85%A5%E4%B8%8E%E8%BE%93%E5%87%BA"><span class="nav-text">输入与输出</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%9F%BA%E7%A1%80io%E5%87%BD%E6%95%B0"><span class="nav-text">基础IO函数</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%96%87%E4%BB%B6%E4%B8%8E%E5%AD%97%E7%AC%A6%E6%B5%81"><span class="nav-text">文件与字符流</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%91%BD%E4%BB%A4%E8%A1%8C%E5%8F%82%E6%95%B0"><span class="nav-text">命令行参数</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%87%BD%E6%95%B0%E5%BC%8F%E5%9C%B0%E8%A7%A3%E5%86%B3%E9%97%AE%E9%A2%98"><span class="nav-text">函数式地解决问题</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%B1%82%E8%A7%A3%E9%80%86%E6%B3%A2%E5%85%B0%E8%A1%A8%E8%BE%BE%E5%BC%8F"><span class="nav-text">求解逆波兰表达式</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%9C%80%E7%9F%AD%E8%B7%AF%E6%90%9C%E7%B4%A2"><span class="nav-text">最短路搜索</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BB%8Efunctor%E5%88%B0monoids"><span class="nav-text">从Functor到Monoids</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#functor%E6%98%AF%E4%BB%80%E4%B9%88"><span class="nav-text">Functor是什么</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#applicative-functors"><span class="nav-text">Applicative Functors</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#newtype"><span class="nav-text">newtype</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#monoids"><span class="nav-text">Monoids</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#monad%E5%BA%94%E7%94%A8"><span class="nav-text">Monad应用</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#monad%E4%B8%8A%E7%9A%84%E6%96%B9%E6%B3%95"><span class="nav-text">Monad上的方法</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%BB%B4%E6%8A%A4%E4%B8%A4%E4%B8%AA%E6%95%B0"><span class="nav-text">维护两个数</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#do%E8%A1%A8%E7%A4%BA%E6%B3%95"><span class="nav-text">do表示法</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#list%E7%9A%84monad%E5%AE%9A%E4%B9%89"><span class="nav-text">List的Monad定义</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E9%9A%8F%E6%9C%BA%E6%95%B0"><span class="nav-text">随机数</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#bytestring"><span class="nav-text">ByteString</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#write-monad"><span class="nav-text">Write Monad</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#reader-monad"><span class="nav-text">Reader Monad</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#state-monad"><span class="nav-text">State Monad</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#error-monad"><span class="nav-text">Error Monad</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%85%B6%E4%BB%96monad%E6%96%B9%E6%B3%95"><span class="nav-text">其他Monad方法</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%94%A8zippers%E4%BF%9D%E5%AD%98%E7%8A%B6%E6%80%81"><span class="nav-text">用Zippers保存状态</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%BB%B4%E6%8A%A4%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91"><span class="nav-text">维护二叉搜索树</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%BB%B4%E6%8A%A4list"><span class="nav-text">维护List</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%BB%B4%E6%8A%A4%E4%B8%80%E4%B8%AA%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F"><span class="nav-text">维护一个文件系统</span></a></li></ol></li></ol></div></div><div class="site-overview-wrap sidebar-panel"><div class="site-author site-overview-item animated" itemprop="author" itemscope itemtype="http://schema.org/Person"><img class="site-author-image" itemprop="image" alt="Liu Kairui" src="/images/avatar.jpg"><p class="site-author-name" itemprop="name">Liu Kairui</p><div class="site-description" itemprop="description">LiuKairui's Personal Website</div></div><div class="site-state-wrap site-overview-item animated"><nav class="site-state"><div class="site-state-item site-state-posts"><a href="/archives/"><span class="site-state-item-count">49</span> <span class="site-state-item-name">日志</span></a></div><div class="site-state-item site-state-categories"><a href="/categories/"><span class="site-state-item-count">27</span> <span class="site-state-item-name">分类</span></a></div><div class="site-state-item site-state-tags"><a href="/tags/"><span class="site-state-item-count">61</span> <span class="site-state-item-name">标签</span></a></div></nav></div><div class="links-of-author site-overview-item animated"><span class="links-of-author-item"><span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL0thaXJ1aUxpdQ==" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;KairuiLiu"><i class="fab fa-github fa-fw"></i>GitHub</span> </span><span class="links-of-author-item"><span class="exturl" data-url="bWFpbHRvOm1lQGxpdWthaXJ1aS5tZQ==" title="E-Mail → mailto:me@liukairui.me"><i class="fa fa-envelope fa-fw"></i>E-Mail</span> </span><span class="links-of-author-item"><span class="exturl" data-url="aHR0cHM6Ly9xbS5xcS5jb20vY2dpLWJpbi9xbS9xcj9rPW9hZjNUb09sTjE3aHI1c0hWOThiVDhxeHNOWUdhdzVMJm5vdmVyaWZ5PTA=" title="QQ → https:&#x2F;&#x2F;qm.qq.com&#x2F;cgi-bin&#x2F;qm&#x2F;qr?k&#x3D;oaf3ToOlN17hr5sHV98bT8qxsNYGaw5L&amp;noverify&#x3D;0"><i class="fab fa-qq fa-fw"></i>QQ</span> </span><span class="links-of-author-item"><a href="/atom.xml" title="RSS → &#x2F;atom.xml"><i class="fa fa-rss fa-fw"></i>RSS</a> </span><span class="links-of-author-item"><span class="exturl" data-url="aHR0cHM6Ly9saXVrYWlydWkuYmxvZy5jc2RuLm5ldA==" title="CSDN → https:&#x2F;&#x2F;liukairui.blog.csdn.net"><i class="fab fa-cuttlefish fa-fw"></i>CSDN</span> </span><span class="links-of-author-item"><span class="exturl" data-url="aHR0cDovL2xpdWthaXJ1aS5jYw==" title="国内站点 → http:&#x2F;&#x2F;liukairui.cc"><i class="fa fa-globe fa-fw"></i>国内站点</span></span></div><div class="cc-license site-overview-item animated" itemprop="license"><span class="exturl cc-opacity" data-url="aHR0cHM6Ly9jcmVhdGl2ZWNvbW1vbnMub3JnL2xpY2Vuc2VzL2J5LW5jLXNhLzQuMC9kZWVkLnpo"><img src="https://cdnjs.cloudflare.com/ajax/libs/creativecommons-vocabulary/2020.11.3/assets/license_badges/small/by_nc_sa.svg" alt="Creative Commons"></span></div></div></div></div></aside><div class="sidebar-dimmer"></div></header><div class="back-to-top" role="button" aria-label="返回顶部"><i class="fa fa-arrow-up"></i> <span>0%</span></div><div class="reading-progress-bar"></div><noscript><div class="noscript-warning">Theme NexT works best with JavaScript enabled</div></noscript><div class="main-inner post posts-expand"><div class="post-block"><article itemscope itemtype="http://schema.org/Article" class="post-content" lang="zh-CN"><link itemprop="mainEntityOfPage" href="https://blog.liukairui.me/article/%E5%87%BD%E6%95%B0%E5%BC%8F%E7%BC%96%E7%A8%8BHaskell%E5%88%9D%E6%8E%A2/"><span hidden itemprop="author" itemscope itemtype="http://schema.org/Person"><meta itemprop="image" content="/images/avatar.jpg"><meta itemprop="name" content="Liu Kairui"></span><span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization"><meta itemprop="name" content="LiuKairui's Blog"><meta itemprop="description" content="LiuKairui's Personal Website"></span><span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork"><meta itemprop="name" content="函数式编程Haskell初探 | LiuKairui's Blog"><meta itemprop="description" content="转变思维🤔. 从思考How(怎么编写指令)到思考What(我们要解决的问题是什么). 最初我以为函数式编程就是思考如何用函数(数学)的方式描述问题. 但逐渐发现函数式编程的重点是如何操作函数去描述函数. 总之, 他值得一学!😎"></span><header class="post-header"><h1 class="post-title" itemprop="name headline">函数式编程Haskell初探</h1><div class="post-meta-container"><div class="post-meta"><span class="post-meta-item"><span class="post-meta-item-icon"><i class="far fa-calendar"></i> </span><span class="post-meta-item-text">发表于</span> <time title="创建时间：2022-03-03 00:00:01" itemprop="dateCreated datePublished" datetime="2022-03-03T00:00:01+08:00">2022-03-03</time> </span><span class="post-meta-item"><span class="post-meta-item-icon"><i class="far fa-folder"></i> </span><span class="post-meta-item-text">分类于</span> <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/%E7%9E%8E%E6%8A%98%E8%85%BE/" itemprop="url" rel="index"><span itemprop="name">瞎折腾</span></a> </span>， <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/%E7%9E%8E%E6%8A%98%E8%85%BE/%E5%87%BD%E6%95%B0%E5%BC%8F%E7%BC%96%E7%A8%8B/" itemprop="url" rel="index"><span itemprop="name">函数式编程</span></a> </span></span><span id="/article/%E5%87%BD%E6%95%B0%E5%BC%8F%E7%BC%96%E7%A8%8BHaskell%E5%88%9D%E6%8E%A2/" class="post-meta-item leancloud_visitors" data-flag-title="函数式编程Haskell初探" title="阅读次数"><span class="post-meta-item-icon"><i class="far fa-eye"></i> </span><span class="post-meta-item-text">阅读次数：</span> <span class="leancloud-visitors-count"></span> </span><span class="post-meta-item" title="阅读次数" id="busuanzi_container_page_pv"><span class="post-meta-item-icon"><i class="far fa-eye"></i> </span><span class="post-meta-item-text">阅读次数：</span> <span id="busuanzi_value_page_pv"></span> </span><span class="post-meta-item"><span class="post-meta-item-icon"><i class="far fa-comment"></i> </span><span class="post-meta-item-text">Valine：</span> <a title="valine" href="/article/%E5%87%BD%E6%95%B0%E5%BC%8F%E7%BC%96%E7%A8%8BHaskell%E5%88%9D%E6%8E%A2/#valine-comments" itemprop="discussionUrl"><span class="post-comments-count valine-comment-count" data-xid="/article/%E5%87%BD%E6%95%B0%E5%BC%8F%E7%BC%96%E7%A8%8BHaskell%E5%88%9D%E6%8E%A2/" itemprop="commentCount"></span> </a></span><span class="post-meta-item theme_switch_wapper hidden" id="theme_switch_wapper"><span class="post-meta-item-icon"><i class="fa-brands fa-markdown"></i></span> <span class="post-meta-item-text">主题： </span><select name="theme_switch" id="theme_switch"><option>sneh</option><option>mo</option><option>with</option><option>next</option></select> </span><span class="post-meta-item" title="本文字数"><span class="post-meta-item-icon"><i class="far fa-file-word"></i> </span><span class="post-meta-item-text">本文字数：</span> <span>75k</span></span></div><div class="post-description">转变思维🤔. 从思考How(怎么编写指令)到思考What(我们要解决的问题是什么). 最初我以为函数式编程就是思考如何用函数(数学)的方式描述问题. 但逐渐发现函数式编程的重点是如何操作函数去描述函数. 总之, 他值得一学!😎</div></div></header><div class="post-body" itemprop="articleBody"><h3 id="简介">简介</h3><h4 id="缘起">缘起</h4><p>🤔想想本科CS教育大多都教的是什么?</p><ul><li>算法: 在给你一个问题, 要你尽<strong>快</strong>算出解.</li><li>数据库: 给你一些数据, 要你<strong>快</strong>速储存查找.</li><li>分布式算法/GPU编程: 一个CPU不够用, 给你更快的硬件(集群或者GPU), 要你更<strong>快</strong>算出解</li><li>人工智能课: 写出指数增长的搜索算法, 然后再用剪枝, 学习等方法<strong>加速</strong>.</li><li>体系结构课: 是在用电路门造出更<strong>快</strong>的CPU.</li></ul><p>为什么我们一个劲去优化机器, 程序员难道不重要吗? 随着代码规模的增大, 重构, 调试, 测试, API设计变得越来越复杂. 于是人们提出了函数式编程. 函数式编程不关心代码的逻辑执行速度(复杂度). 程序员只负责将问题描述给计算机, 而速度优化则一口气交给计算机处理.</p><p>⚠️<strong>注意</strong>: Haskell并没有在工业界流行. 这意味着你很难将Haskell应用于大型项目(虽然Haskell具有这样的能力)</p><h4 id="什么是haskell函数式编程">什么是Haskell/函数式编程</h4><p>🔡Haskell是一门纯粹函数式编程语言</p><p><strong>🏎函数式与命令式编程对比</strong></p><ul><li><p>🏃‍♂️执行操作:</p><ul><li>命令式编程: 给计算机一系列指令, 计算机根据指令执行变量状态变化. 最后得到结果</li><li>函数式编程: 告诉计算机我们需要解决什么样的问题</li></ul><p>例如: 获取字符串<span class="math inline">\(s\)</span>中的大写字母</p><ul><li>命令式编程: 遍历<span class="math inline">\(s\)</span> - 如果字符<span class="math inline">\(c\)</span>满足<span class="math inline">\(&#39;A&#39; \leq c \leq &#39;Z&#39;\)</span> - 将<span class="math inline">\(c\)</span>放入数组<span class="math inline">\(res\)</span> - 返回<span class="math inline">\(res\)</span></li><li>函数式编程: 我要获得一个字符串 - 这个字符串中的字符来自<span class="math inline">\(s\)</span> - 只有大写字母满足要求 - 大写字母指的是<span class="math inline">\({&#39;A&#39;, &#39;B&#39;,...,&#39;Z&#39;}\)</span></li></ul><p>不难发现, 我们可以很难将命令式编程中的语句转化为数学函数(比如遍历的<code>for</code>就无法转换为函数), 但是可以很轻易的将函数式编程语句的内容转化为数学表达式 <span class="math display">\[ f(s) = \{x|x \in s , x \in Caps\} \ \ \ where\ Caps = \{&#39;A&#39;, &#39;B&#39;,...,&#39;Z&#39;\} \]</span> 他的Haskell表达式也很数学化(暂时看不懂也没有大碍)</p><pre class="line-numbers language-haskell" data-language="haskell"><code class="language-haskell">f s &#x3D; [x|x&lt;-s, x &#96;elem&#96; [&#39;A&#39;..&#39;Z&#39;]]<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>回头想想, 我们经常把命令式编程语句中的<code>function</code>称作"函数". 但是这些"函数"内部却总是有数学函数无法实现的内容(例如循环, 变量重复赋值). 所幸函数式编程解决了这个问题</p></li><li><p>🙅变量与常量</p><ul><li>命令式编程: 常量一旦声明就无法变化, 而变量可以随时重新赋值</li><li>函数式编程: 变量一旦被指定, 就不可以更改了. 函数能做的唯一事情就是利用引数计算结果(毕竟数学函数中可没有重复赋值的操作, 但数学中可到处都是复合函数)</li></ul></li><li><p>💊副作用(side effect, 即改变非函数内部的状态)</p><ul><li>命令式编程: 函数可能存在副作用(修改外部变量值)</li><li>函数式编程: 无副作用, 且函数式编程中的函数是纯函数(即: 以同样的参数调用同一个函数两次, 得到的结果一定是相同)</li></ul></li><li><p>⏱惰性求值</p><ul><li><p>命令式编程: 除非使用特殊数据结构, 默认非惰性求值, 例如在JS中写下</p><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript"><span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">3</span><span class="token punctuation">]</span><span class="token punctuation">.</span><span class="token function">map</span><span class="token punctuation">(</span><span class="token parameter">d</span><span class="token operator">=></span>d<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">map</span><span class="token punctuation">(</span><span class="token parameter">d</span><span class="token operator">=></span>d<span class="token operator">/</span><span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>解释器会对数组遍历两次</p></li><li><p>函数式编程: 默认惰性求值, 例如在Haskell中写下</p><pre class="line-numbers language-haskell" data-language="haskell"><code class="language-haskell">map (&#x2F;2) (map (+1) [1,2,3])<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>数组只会遍历一次, 即每一个元素都调用函数两次, 最后得到结果. 好像有点问题: 如果我想定义一个<code>cnt</code>, 并让<code>cnt</code>在每次执行加法/乘法的时候<code>+1</code>, 最后加<code>cnt</code>到结果上呢? 即</p><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript"><span class="token keyword">let</span> t <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">3</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
<span class="token keyword">let</span> cnt <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">let</span> i<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span> i<span class="token operator">&lt;</span>t<span class="token punctuation">.</span>length<span class="token punctuation">;</span>i<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>
    t<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token operator">+=</span><span class="token number">1</span><span class="token punctuation">;</span>cnt<span class="token operator">++</span><span class="token punctuation">;</span>
    t<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token operator">/=</span><span class="token number">2</span><span class="token punctuation">;</span>cnt<span class="token operator">++</span><span class="token punctuation">;</span>
    t<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token operator">+=</span>cnt<span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>Haskell的惰性求值似乎会让这样的函数无法实现? 但是还记得副作用吗, Haskell中的函数都是纯函数, 纯函数的执行不能对外部产生副作用. 也正是因为函数都是纯函数, 所以惰性求值时候将元素经常连续变化并不会造成结果存在差异.</p><p>惰性求值的另一个好处是我们可以处理一个无限数组例如: 获取前10个奇数</p><pre class="line-numbers language-haskell" data-language="haskell"><code class="language-haskell">[1..]           -- 获取一个[1,2,3...]的无限数组
filter (odd) [1..]    -- 过滤出所有奇数 [1,3,5..]
take 10 filter (odd) [1..]   -- 取前10项<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre></li></ul></li></ul><p><strong>🚫Haskell是静态强类型语言</strong></p><ul><li>静态类型意味着我们需要在运行前明确指出变量的类型, 同时Haskell支持类型推导, 这意味着我们不必告诉Haskell每一个变量的类型(例如Haskell会自动推断<code>a = 1+1</code>的<code>a</code>是数值, 同时由于Haskell不可重复赋值, a的类型不会再有变化)</li><li>强类型意味着Haskell不会自动进行类型转换(除了部分语法糖)</li></ul><h4 id="环境配置">环境配置</h4><p>🛠最方便的方法就是使用<code>Haskell Platform</code>, 此程序包包含</p><ul><li><span class="exturl" data-url="aHR0cHM6Ly93d3cuaGFza2VsbC5vcmcvZ2hjLw==">GHC<i class="fa fa-external-link-alt"></i></span>: Haskell编译器</li><li><span class="exturl" data-url="aHR0cHM6Ly9jYWJhbC5yZWFkdGhlZG9jcy5pby8=">cabal-install<i class="fa fa-external-link-alt"></i></span>: 包管理器</li><li><span class="exturl" data-url="aHR0cHM6Ly9kb2NzLmhhc2tlbGxzdGFjay5vcmcv">stack<i class="fa fa-external-link-alt"></i></span>: 跨平台开发工具</li><li><span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL2hhc2tlbGwvaGFza2VsbC1sYW5ndWFnZS1zZXJ2ZXI=">haskell-language-server<i class="fa fa-external-link-alt"></i></span>: 语言支持</li></ul><p>对于<code>archlinux</code>, 由于GHC采用动态链接, 需要增加几个软件</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">pacman -S ghc cabal-install stack haskell-language-server happy alex haskell-haddock-library<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>对于VSCode用户</p><ul><li><span class="exturl" data-url="aHR0cHM6Ly9tYXJrZXRwbGFjZS52aXN1YWxzdHVkaW8uY29tL2l0ZW1zP2l0ZW1OYW1lPW1vZ2Vrby5oYXNrZWxsLWV4dGVuc2lvbi1wYWNr">Haskell Extension Pack<i class="fa fa-external-link-alt"></i></span></li><li><span class="exturl" data-url="aHR0cHM6Ly9tYXJrZXRwbGFjZS52aXN1YWxzdHVkaW8uY29tL2l0ZW1zP2l0ZW1OYW1lPWRyYW1mb3JldmVyLnZzY29kZS1naGMtc2ltcGxl">Simple GHC (Haskell) Integration<i class="fa fa-external-link-alt"></i></span></li><li><span class="exturl" data-url="aHR0cHM6Ly9tYXJrZXRwbGFjZS52aXN1YWxzdHVkaW8uY29tL2l0ZW1zP2l0ZW1OYW1lPXBob2l0eW5lLnBob2l0eW5lLXZzY29kZQ==">Haskell GHCi Debug Adapter Phoityne<i class="fa fa-external-link-alt"></i></span></li></ul><p>GHC在编译Haskell文件(<code>.hs</code>文件)的同时提供了交互模式(类似Node, Python, 虽然他是编译型语言(这里应该感谢纯函数的特性)), 只需要终端输入<code>ghci</code>即可进入交互模式. 在交互模式中</p><pre class="line-numbers language-haskell" data-language="haskell"><code class="language-haskell">:l xx.hs    -- 可以加载xx.hs文件, 其中.hs可以省略
:r          -- 刷新已经加载的文件<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><h3 id="基础语法">基础语法</h3><h4 id="运算符">运算符</h4><ul><li><p>数学运算: <code>2 + 15</code>, <code>49 * 100</code>, <code>1892 - 1472</code>, <code>5 / 2</code>, <code>50 * (100 - 4999)</code></p><p>注意: <code>5 * -3</code>会报错, 因为<strong>在Haskell中函数是一等公民</strong>, 而<code>*</code>本身就是一个二元函数. Haskell会将表达式解析为<code>( 5 * - ) 3</code>, 所以应该改为<code>5 * (-3)</code></p></li><li><p>Boolean运算: <code>True</code>, <code>False</code>(必须大写), <code>&amp;&amp;</code>, <code>||</code>, <code>not</code>, <code>==</code>, <code>/=</code>(即<code>!=</code>)</p></li></ul><p>数学运算与Boolean运算都不支持默认类型转换(整数支持默认转换为小数)</p><h4 id="函数调用">函数调用</h4><ul><li><p>函数调用: 调用方法为<code>函数名 参数1 参数2...</code>, 看起来很怪, 没有<code>()</code>, 也没有<code>,</code>分隔. 例如</p><pre class="line-numbers language-haskell" data-language="haskell"><code class="language-haskell">succ 8                 -- 获取8的后继, 即9
min 9 10               -- 8,9最小值
max 9 10               -- 8,9最大值
succ 9 + max 5 4 + 1   -- 函数调用具有最高优先级, 即(succ 9) + (max 5 4) + 1<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre></li><li><p>中缀函数: 对于二元函数, 我们可以将<code>f x y</code>写成<code>x `f` y</code>, 注意, 这里的<code>`</code>, 是必须的. 例如</p><pre class="line-numbers language-haskell" data-language="haskell"><code class="language-haskell">2 &#96;min&#96; 4    -- 即 min 2 4
1 &#96;elem&#96; [2,3,1] -- 即elem 1 [2,3,1], 其中elem x xs返回x是否在xs中 <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre></li><li><p>函数调用是自左向右的</p></li></ul><h4 id="函数编写">函数编写</h4><ul><li><p>函数定义与数学中的函数表达式很类似, 例如</p><ul><li><p>需要定义表达式<span class="math inline">\(doubleMe(x) = x+x\)</span>, 只需要</p><p><pre class="line-numbers language-haskell" data-language="haskell"><code class="language-haskell">doubleMe x &#x3D; x+x<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></p></li><li><p>需要定义表达式<span class="math inline">\(doubleUs(x,y) = x+x+y+y\)</span>, 只需要</p><p><pre class="line-numbers language-haskell" data-language="haskell"><code class="language-haskell">doubleUs x y &#x3D; x+x+y+y<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></p><p>当然, 也可以调用函数</p><p><pre class="line-numbers language-haskell" data-language="haskell"><code class="language-haskell">doubleUs x y &#x3D; doubleMe x + doubleMe y<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></p></li></ul></li><li><p>变量就是常函数(因为变量不可修改值, 所以, 可以像构建常函数一样构建变量)</p><pre class="line-numbers language-haskell" data-language="haskell"><code class="language-haskell">testValue &#x3D; 12<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></li><li><p>无需关心<strong>函数之间</strong>的位置, 例如</p><pre class="line-numbers language-haskell" data-language="haskell"><code class="language-haskell">doubleUs x y &#x3D; doubleMe x + doubleMe y
doubleMe x &#x3D; x + x
demoRes &#x3D; demoUs 1 2<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>并不会报错</p></li><li><p>条件语句If: <code>if-then-else</code>结构, 例如</p><pre class="line-numbers language-haskell" data-language="haskell"><code class="language-haskell">doubleSmallNumber x &#x3D; if x &gt; 100
                      then x
                      else  x*2<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>支持压行书写</p></li><li><p>使用<code>_</code>表示我们不关系这个变量取值, 例如定义函数 <span class="math display">\[ f(x,y,z) = x\\ g(x,y,z) = y\\ g(x,y,z) = z \]</span> Haskell表示就是</p><pre class="line-numbers language-haskell" data-language="haskell"><code class="language-haskell">f x _ _ &#x3D; x
g _ y _ &#x3D; y
h _ _ z &#x3D; z<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>这和JS中<code>_</code>表示不关心变量不一样, 这个甚至可以重名</p></li><li><p>在Haskell中使用<code>'</code>表示类似, 但是不同的函数, 比如我们想使用两种方式实现<span class="math inline">\(Fibonacci\)</span></p><pre class="line-numbers language-haskell" data-language="haskell"><code class="language-haskell">fib n &#x3D; if n&lt;&#x3D;2 then n else fib (n-1) + fib (n-2)<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>忽然我们又想实现一个<span class="math inline">\(Fibonacci\)</span></p><pre class="line-numbers language-haskell" data-language="haskell"><code class="language-haskell">fib&#39; n &#x3D; if n&lt;&#x3D;3 then n else fib (n-1) + fib (n-2)<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>这只是一种命名习惯, 不强制, 也没有其他效果</p></li></ul><h4 id="list类型基础">List类型基础</h4><p>📜这里的List和JS/Python的数组类似, 我喜欢把他作为<strong>可重复无序集合</strong>使用.</p><ul><li><p>声明一个List很简单</p><p><pre class="line-numbers language-haskell" data-language="haskell"><code class="language-haskell">t &#x3D; [1,2,3]<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></p><p>⚠️List中的元素类型必须相同</p></li><li><p>字符串实际上是字符List的语法糖</p><p><pre class="line-numbers language-haskell" data-language="haskell"><code class="language-haskell">&quot;231&quot; &#x3D;&#x3D; [&#39;2&#39;,&#39;3&#39;,&#39;1&#39;]  -- True<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></p></li><li><p>可以使用<code>++</code>运算合并List, 例如</p><p><pre class="line-numbers language-haskell" data-language="haskell"><code class="language-haskell">t &#x3D; [1,2,3] ++ [4,5,6]   -- [1,2,3,4,5,6]<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></p><p>⚠️其实现原理是遍历<code>++</code>前的数组并合并到后者, 所以这是一个低效运算子</p></li><li><p>可以使用<code>:</code>运算符将元素加入List头部, 例如</p><p><pre class="line-numbers language-haskell" data-language="haskell"><code class="language-haskell">t &#x3D; 1:[2,3,4]    -- [1,2,3,4]<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></p><p>支持链式调用, 例如</p><p><pre class="line-numbers language-haskell" data-language="haskell"><code class="language-haskell">t &#x3D; 1:2:3:[4,5,6]   -- [1,2,3,4,5,6]<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></p></li><li><p>可以使用<code>!!</code>取List的某一位</p><p><pre class="line-numbers language-haskell" data-language="haskell"><code class="language-haskell">t &#x3D; [1,2,3,4,5,6] !! 2   -- 3<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></p><p>⚠️越界访问会报错</p></li><li><p>取值方法</p><ul><li><p><code>head List</code>返回<strong>首个</strong>元素: <code>head [1,2,3]</code>为<code>1</code></p></li><li><p><code>tail List</code>返回<strong>非首个</strong>元素们: <code>tail [1,2,3]</code>为<code>[2,3]</code></p></li><li><p><code>last List</code>返回<strong>最后一个</strong>元素: <code>last [1,2,3]</code>为<code>3</code></p></li><li><p><code>init List</code>返回<strong>非最后一个</strong>元素: <code>init [1,2,3]</code>为<code>[1,2]</code></p><p>⚠️对空数组执行均会报错</p></li></ul></li><li><p>其他方法</p><ul><li><p><code>length List</code>返回数组长度: <code>length [1,2,3]</code>为<code>3</code></p></li><li><p><code>null List</code>返回是否为空: <code>null [1,2,3]</code> 为 <code>False</code></p></li><li><p><code>reverse List</code>反转数组: <code>reverse [1,2,3]</code>为<code>[3,2,1]</code>, 并不会反转原数组(因为纯函数)</p></li><li><p><code>take n List</code>返回前<code>n</code>的元素, 越界部分不返回, <code>n==0</code>返回<code>[]</code></p><pre class="line-numbers language-haskell" data-language="haskell"><code class="language-haskell">take 2  [1,2,3,4]  -- [1,2]
take 10 [1,2,3,4]  -- [1,2,3,4] 
take 0  [1,2,3,4]  -- [] 
take -1 [1,2,3,4]  -- Error!<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre></li><li><p><code>drop</code>与<code>take</code>类似, 作用为删除前<code>n</code>个元素</p></li><li><p><code>maximum List</code>返回最大值: <code>maximum [1,9,2,3,4]</code>为<code>9</code></p></li><li><p><code>maximum List</code>返回最大值: <code>minimum [8,4,2,1,5,6]</code>为<code>1</code></p></li><li><p><code>sum List</code>返回和: <code>sum [8,4,2,1,5,6]</code>为<code>26</code></p></li><li><p><code>product List</code>返回积: <code>product [8,4,2,1,5,6]</code>为<code>1920</code></p></li></ul></li><li><p><code>elem ele List</code>判断<code>ele</code>是否在<code>List</code>中: <code>4 `elem` [3,4,5,6]</code>为<code>True</code></p></li></ul><h4 id="list的range">List的Range</h4><p>📜类似于Python的Range, 但是更加智能</p><pre class="line-numbers language-haskell" data-language="haskell"><code class="language-haskell">t &#x3D; [1..5]   -- [1,2,3,4,5]
t &#x3D; [&#39;a&#39;..&#39;f&#39;]  -- [&#39;a&#39;,&#39;b&#39;,&#39;c&#39;,&#39;d&#39;,&#39;e&#39;,&#39;f&#39;]
-- 默认Step为1, 自定义时需要列前两项
t &#x3D; [1,1.2..2]  --  [1.0,1.2,1.4,1.5999999999999999,1.7999999999999998,1.9999999999999998]
-- 但是精度堪忧, 建议使用其他方法(后面会提到)
t &#x3D; [1..]   -- [1,2,3..]定义无限长List
t &#x3D; [1,3..]   -- [1,3,5,7..]<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><code>repeat n</code>返回无限个<code>n</code>组成的List(等价于<code>[n,n..]</code>)</p><pre class="line-numbers language-haskell" data-language="haskell"><code class="language-haskell">t &#x3D; repeat 5   -- [5,5,5,5...]<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>一般搭配<code>take</code>使用</p><h4 id="list的comprehension">List的Comprehension</h4><p>🔰非常类似于集合的定义(这也是我把List当无序可重集合的原因)</p><p>对于一个集合 <span class="math display">\[ S = \{ 2x | x \in \mathbb N , \sqrt{x} \in \{1,..,100\} \} \]</span> 首先他是一个List, 所以应该包着<code>[]</code>, 之后有一个竖线分隔符, 左边是输出函数(集合中的代表元素), 右边是约束, 例如<code>[x|条件]</code>, 条件中<span class="math inline">\(\in\)</span>使用<code>&lt;-</code>表示, 那么刚刚集合就可以表示为<code>t = [ 2*x | x &lt;- [1..100], (sqrt x) `elem` [1..100]]</code></p><p>还可以结合之前的函数与<code>if</code>语句, 例如:</p><p>定义<code>List</code>它能够使<code>List</code>中所有大于 10 的奇数变为 <code>"BANG"</code>，小于 10 的奇数变为 <code>"BOOM"</code>，其他则统统扔掉</p><pre class="line-numbers language-haskell" data-language="haskell"><code class="language-haskell">boomBangs xs &#x3D; [ if x &lt; 10 then &quot;BOOM!&quot; else &quot;BANG!&quot; | x &lt;- xs, odd x]<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>同时支持同多List中取元素</p><pre class="line-numbers language-haskell" data-language="haskell"><code class="language-haskell">[ x*y | x &lt;- [2,5,10], y &lt;- [8,10,11]]  --[16,20,22,40,50,55,80,100,110]<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>🤔<strong>使用comprehension的时候注意思考方式</strong>: 我需要的List是什么样子的, 而不是List是怎么算出来的</p><h4 id="tuple类型基础">Tuple类型基础</h4><p>📜这里的Tuple和Python的元组类似. 与List不同的就是: Tuple是定长的, 其中可以为任意不同数据类型(例如<code>('a',1)</code>)</p><p>⚠️Tuple也是有类型的, 这意味着若List中有Tuple, 那么所有的Tuple类型应该相同(每个Tuple的长度相同, 每一个位置的类型相同), 即</p><pre class="line-numbers language-haskell" data-language="haskell"><code class="language-haskell">[(1,2,3), (4,5,6)]   -- 👍
[(1,2,3), (4,5,True)]  -- 💩
[(1,2,3), (4,5)]   -- 💩
[(1,2), (4,5.0)]          -- 👍 同时你将获得[(1,2.0), (4,5.0)]<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p><strong>方法:</strong></p><ul><li><p><code>fst Tuple</code>获取<strong>二元</strong>Tuple的第一个元素, 不可用于其他长度Tuple!</p></li><li><p><code>snd Tuple</code>获取<strong>二元</strong>Tuple的第二个元素, 不可用于其他长度Tuple!</p></li><li><p><code>zip List List</code>获取一个交叉配对的Tuple List</p><pre class="line-numbers language-haskell" data-language="haskell"><code class="language-haskell">zip [1,2,3,4,5] [5,5,5,5,5]
-- [(1,5),(2,5),(3,5),(4,5),(5,5)]
zip [1 .. 5] [&quot;one&quot;, &quot;two&quot;, &quot;three&quot;, &quot;four&quot;, &quot;five&quot;]
-- [(1,&quot;one&quot;),(2,&quot;two&quot;),(3,&quot;three&quot;),(4,&quot;four&quot;),(5,&quot;five&quot;)]<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>这个<code>zip</code>函数确实很形象啊😂, 同时若两个List长度不一样的, 则舍弃长出的部分(拉拉链的时候要是两边不一样长也只能拉到较短的位置), 这种特性与惰性求值组合后<code>zip</code>就可以处理无限数组了</p><pre class="line-numbers language-haskell" data-language="haskell"><code class="language-haskell">zip &quot;Karry&quot; [1..]
-- [(&#39;K&#39;,1),(&#39;a&#39;,2),(&#39;r&#39;,3),(&#39;r&#39;,4),(&#39;y&#39;,5)]<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre></li><li><p><code>zipWi1th f List List</code>: 与<code>zip</code>类似, 将每次取得的两个元素调用<code>f</code>并返回</p><pre class="line-numbers language-haskell" data-language="haskell"><code class="language-haskell">add x y &#x3D; x + y
zipWith add [1 .. 10] [1 .. 10]
-- [2,4,6,8,10,12,14,16,18,20]<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre></li></ul><p><strong>😆有趣的例子</strong>: 还是要注意思考方式</p><ul><li><p>所有三边长度皆为整数且小于等于 10，周长为 24 的三角形</p><pre class="line-numbers language-haskell" data-language="haskell"><code class="language-haskell">triangles &#x3D; [ (a,b,c) | c &lt;- [1..10], b &lt;- [1..10], a &lt;- [1..10], a+b&gt;c, a+c&gt;b, b+c&gt;a]<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></li><li><p>三边都小于等于 10 的直角三角形(三边按顺序输出)</p><pre class="line-numbers language-haskell" data-language="haskell"><code class="language-haskell">triangles&#39; &#x3D; [ (a,b,c) | c &lt;- [1..10], b &lt;- [1..c], a &lt;- [1..b], a^2 + b^2 &#x3D;&#x3D; c^2]<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></li><li><p>周长为24, 三边都小于等于 10 的直角三角形</p><pre class="line-numbers language-haskell" data-language="haskell"><code class="language-haskell">triangles&#39;&#39; &#x3D; [ (a,b,c) | c &lt;- [1..10], b &lt;- [1..c], a &lt;- [1..b], a^2 + b^2 &#x3D;&#x3D; c^2, a+b+c &#x3D;&#x3D; 24]<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></li></ul><h3 id="类型与类型类">类型与类型类</h3><h4 id="类型types">类型(Types)</h4><p>Haskell是静态类型语言且支持类型推导. 但Haskell不支持隐式类型转换(除了Int-&gt;Float)</p><p>可以在<code>ghci</code>中使用<code>:t 表达式</code>的方式获取类型</p><pre class="line-numbers language-haskell" data-language="haskell"><code class="language-haskell">:t &#39;a&#39;     -- &#39;a&#39;::Char
:t True    -- True::Bool
:t &quot;HELLO!&quot;   -- &quot;HELLO&quot;::String
:t max    -- max :: Ord a &#x3D;&gt; a -&gt; a -&gt; a
:t [1,2,3]   -- [1,2,3] :: Num a &#x3D;&gt; [a]
:t 12.3    -- 12.3 :: Fractional p &#x3D;&gt; p
:t (True, 1)  -- (True, 1) :: Num b &#x3D;&gt; (Bool, b)
:t (&#x3D;&#x3D;)    -- (&#x3D;&#x3D;) :: Eq a &#x3D;&gt; a -&gt; a -&gt; Bool<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>🙄常见的类型有</p><ul><li><code>Int</code>: 表示<span class="math inline">\(-2^{31} \sim 2^{31}-1\)</span>的整数</li><li><code>Integer</code>: 表示整数, 无界</li><li><code>Float</code>: 单精度浮点数</li><li><code>Double</code>: 双精度浮点型</li><li><code>Bool</code>: 布尔型, 取值为<code>True</code>与<code>False</code></li><li><code>Char</code>: 字符型, <code>String = [Char]</code>表示字符串</li></ul><p>🙄类型表示时的术语</p><ul><li><p>使用大写字母开头表示类型</p></li><li><p><code>::</code>表示"类型为", 例如: "HELLO"的类型为String</p></li><li><p><code>[a]</code>表示<code>a</code>类型的数组</p></li><li><p>对于函数, 将参数与返回值类型依次使用<code>-&gt;</code>连接即可, 例如</p><ul><li><p><code>a-&gt;b</code>表示这是一个函数, 接受一个<code>a</code>类型的参数, 返回一个<code>b</code>类型变量</p></li><li><p><code>a-&gt;b-&gt;c-&gt;d</code>表示这是一个函数, 按顺序接受<code>a</code>,<code>b</code>, <code>c</code>类型变量, 返回<code>d</code>类型变量</p></li></ul><p>将参数与返回值类型简单粗暴的连接在一起看起来有点"欠考虑", 实际上, 这样的模式在函数式编程中十分符合直觉</p><p>当函数可以接受多种类型的参数并返回不同类型的类型时, 我们一般采用<code>a</code>, <code>b</code>, <code>c</code>...表示某一种类型, 这与命令式语言中的<strong>多态</strong>类似, 例如<code>reverse</code>函数: <code>[a] -&gt; [a]</code></p></li><li><p>运算符也是一个函数, 例如<code>==</code>类型就是一个<code>a-&gt;a-&gt;Bool</code>, 不过在进行类型判断应该使用括号将运算符括起来, 如<code>:t (==)</code></p></li><li><p>Tuple的类型是每一项的类型组成的Tuple</p></li><li><p>至今没有解决的<code>=&gt;</code>表示什么, 这需要类型类的知识</p></li></ul><h4 id="类型变量type-variables与类型类type-variables">类型变量(Type variables)与类型类(Type variables)</h4><p>🎁前面提到, 我们可以通过使用<code>a</code>, <code>b</code>等变量表示任意类型, 例如<code>sum</code>函数表示<code>[a]-&gt;a</code>, 此时的<code>a</code>就是<strong>类型变量</strong>, 例如</p><ul><li><code>fst</code>函数: <code>[a] -&gt; a</code></li><li><code>length</code>函数: <code>[a] -&gt; Int</code></li><li><code>div</code>函数: <code>a -&gt; a -&gt; a</code></li></ul><p>此时, <code>div</code>函数似乎有点问题, 我们只用<code>a</code>代表了某一种类型, 但是<code>Char</code>类型能除吗? 我们应该将类型变量限定到一定类型范围, 例如<code>div</code>函数的<code>a</code>应该是一个可计算类型, 用<code>:t</code>检查<code>div</code>函数</p><pre class="line-numbers language-haskell" data-language="haskell"><code class="language-haskell">ghci&gt; :t div
div :: (Integral a) &#x3D;&gt; a -&gt; a -&gt; a<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>这里的<code>(Integral a)</code>用来描述<code>a</code>这个类型是一个<code>Integral</code>类型类(括号表示省略). 注意描述: <strong>类型变量<code>a</code>是一个<code>Intergral</code>类型类的类型变量</strong>, 在描述结束时候使用<code>=&gt;</code>链接类型声明</p><p>🪆有点套娃的意思了. 将这些术语与命令式编程对应一下.</p><ul><li><p>函数的参数与返回值可能是多种类型的(<strong>对应多态</strong>)</p></li><li><p>于是我们将每种类型用不同的类型变量表示(<strong>对应模板, 用类型变量代表某一个类</strong>)</p></li><li><p>为了约束类型变量, 我们提出了类型类. 那什么样的类属于某个类型类呢?</p><p><strong>完成了类型类中定义的成员与方法的类</strong>都可以属于类型类(<strong>对应接口</strong>).</p></li></ul><p>🌰看几个常见的例子</p><ul><li><p><code>Eq</code>类型类表示可以表示相等的类型类. <code>Eq</code>类型类要求实现<code>==</code>函数以用于判断.</p><p>例如<code>:t (==)</code>类型为<code>(==) :: Eq a =&gt; a -&gt; a -&gt; Bool</code></p></li><li><p><code>Ord</code>类型类表示可以比较类型类, <code>Ord</code>类型类要求实现<code>&lt;</code>, <code>&gt;</code>, <code>&lt;=</code>, <code>&gt;=</code>函数.</p><p><code>:t min</code>类型为<code>min :: Ord a =&gt; a -&gt; a -&gt; a</code></p></li><li><p><code>Show</code>类型类表示可以转换为字符串的类型类, <code>Show</code>类要求实现<code>show</code>函数用于转换为字符串</p><p>例如: <code>:t show</code>类型为<code>show :: Show a =&gt; a -&gt; String</code></p><p>例如: <code>show 123</code>表示<code>"123"</code>, <code>show [1,2,3]</code>表示<code>"[1,2,3]"</code></p></li><li><p><code>Read</code>类型与<code>Show</code>类型相反. <code>read</code>函数可以将字符串转换为<code>Read</code>类型类的成员</p><p>例如: <code>:t read</code>类型为<code>read :: Read a =&gt; String -&gt; a</code></p><p>但是: 将<code>String</code>转换为<code>Read</code>类型类中哪个类型呢, 比如"True"应该转换为字符串还是布尔呢</p><ul><li>可以使用Haskell自带的类型推导: <code>read "123" + 1</code>得到<code>124</code></li><li>可以使用Haskell类型声明手动指定: <code>read "123" :: Float</code>得到<code>123.0</code></li></ul></li><li><p><code>Enum</code>类型类的成员都是可枚举的. 其成员实现了<code>succ</code>(后继子)与<code>pred</code>(前继子)方法. <code>Bool</code>, <code>Char</code>, <code>Ordering</code>, <code>Int</code>, <code>Integer</code>, <code>Float</code>, <code>Double</code>类型都术语该类型类</p><p>例如: <code>:t succ</code>类型为<code>succ :: Enum a =&gt; a -&gt; a</code></p></li><li><p><code>Bounded</code>类型类的成员都有上限与下限</p><ul><li><code>:t minBound</code>类型为<code>minBound :: Bounded a =&gt; a</code>, 例如: <code>minBound :: Int</code>为<code>-9223372036854775808</code></li><li><code>:t maxBound</code>类型为<code>maxBound :: Bounded a =&gt; a</code></li></ul></li><li><p><code>Num</code>为数字类型类</p></li><li><p><code>Integral</code>: 表示整数, 包含<code>Int</code> 和 <code>Integer</code></p><p>当我们想显式将<code>Integral</code>转化为<code>Num</code>时, 可以使用<code>fromIntegral</code>函数</p><p>⚠️<code>Integer</code>与<code>Integral</code>区别</p></li><li><p><code>Floating</code>: 表示浮点数, 包含<code>Float</code> 和 <code>Double</code></p></li></ul><p>⚠️如果一个类型属于多个类型类可以这样写</p><h3 id="函数">函数</h3><p>Haskell有一套独特的函数语法</p><h4 id="模式匹配pattern-matching">模式匹配(Pattern matching)</h4><p>模式匹配通过检查数据的特定结构来检查其是否匹配，并按模式从中取得数据. 这在函数定义中很常用</p><p>👂听起来和字符串正则匹配很像. 在定义函数时可以这样写</p><pre class="line-numbers language-haskell" data-language="haskell"><code class="language-haskell">lucky :: (Integral a) &#x3D;&gt; a -&gt; String  
lucky 7 &#x3D; &quot;LUCKY NUMBER SEVEN!&quot;  
lucky x &#x3D; &quot;Sorry, you&#39;re out of luck, pal!&quot;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>在调用 <code>lucky</code> 时, 模式会从<strong>上至下进行检查, 一旦有匹配, 那对应的函数体就被应用了</strong>. 这个模式中的唯一匹配是参数为<code>7</code>，如果不是<code>7</code>，就转到下一个模式，它匹配一切数值并将其绑定为 <code>x</code> . 若是自上而下检查所有模式都没有命中, Haskell会报错. 所以在使用模式匹配的时候务必要考虑<strong>边界条件与特殊值</strong>(这与你在数学表达式中考虑边界值一样重要)</p><p>一个实现阶乘的例子</p><pre class="line-numbers language-haskell" data-language="haskell"><code class="language-haskell">factorial :: (Integral a) &#x3D;&gt; a -&gt; a  
factorial 0 &#x3D; 1  
factorial n &#x3D; n * factorial (n - 1)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>🤔看起来模式匹配只是用于类似数学中递归定义的一个语法糖?(简化了<code>switch-case</code>)</p><p>👻并不是, 模式匹配还有高级用法(我更喜欢把他理解为JS正则中<code>if(regExp.test())&#123;args = regExp.exec()&#125;</code>的语法糖或者是<code>Object</code>结构赋值的语法糖)</p><ul><li><p>实现一个二维向量相加</p><p><pre class="line-numbers language-haskell" data-language="haskell"><code class="language-haskell">addVectors :: (Num a) &#x3D;&gt; (a, a) -&gt; (a, a) -&gt; (a, a)  
addVectors a b &#x3D; (fst a + fst b, snd a + snd b)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre></p><p>用模式匹配写后</p><p><pre class="line-numbers language-haskell" data-language="haskell"><code class="language-haskell">addVectors :: (Num a) &#x3D;&gt; (a, a) -&gt; (a, a) -&gt; (a, a)  
addVectors (x1, y1) (x2, y2) &#x3D; (x1 + x2, y1 + y2)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre></p><p>在定义函数的时候我就将参数与传入值进行了匹配</p></li><li><p>实现一个<code>List</code>的<code>reverse</code>(注意实现思路与模式匹配的应用)</p><p><pre class="line-numbers language-haskell" data-language="haskell"><code class="language-haskell">reverse&#39; :: [a] -&gt; [a]
reverse&#39; (x : xs) &#x3D; reverse&#39; xs ++ [x]
reverse&#39; [] &#x3D; []<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre></p><ul><li><p><code>x : xs</code>: 表示匹配一个List, 将这个List的第一个元素设置为<code>x</code>, 剩下的设置为<code>xs</code></p><p>例如: 使用其匹配的时候<code>[1,2,3]</code>就会匹配为<code>1:[2,3]</code>, 于是<code>x = 1, xs = [2,3]</code></p><p>⚠️使用这样的方式匹配数组时需要加上括号表示他们是一体的</p></li><li><p><code>reverse</code>函数是什么呢? 就是把数组的第一个元素放到最后, 在前面加上反转后的剩下的元素</p></li><li><p>什么时候会匹配失败呢? 当参数是空数组的时候就取不出来头, 于是设置一个边界值</p></li></ul></li><li><p>实现一个<code>List</code>的<code>head</code>函数</p><p><pre class="line-numbers language-haskell" data-language="haskell"><code class="language-haskell">head&#39; :: [a] -&gt; a
head&#39; (x:_) &#x3D; x
head&#39; [] &#x3D; error &quot;empty list&quot;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre></p><p>我们并不关心模式匹配时首元素后面的元素, 那么可以用<code>_</code>代替</p></li><li><p>实现一个快速排序</p><p><pre class="line-numbers language-haskell" data-language="haskell"><code class="language-haskell">qsort :: (Ord a) &#x3D;&gt; [a] -&gt; [a]
qsort (target:xs) &#x3D; [x|x&lt;-xs, x&lt;&#x3D;target] ++ [target] ++ [x|x&lt;-xs, x&gt;target]
qsort [] &#x3D; []<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre></p><p>这是一个经典的例子, 快速排序是什么, 就是随便这一个元素, 把比他小的排序后放在左边, 比他大的排序后放在右边</p></li><li><p>还可以在匹配时使用<code>@</code>语法保留对整体的引用</p><p><pre class="line-numbers language-haskell" data-language="haskell"><code class="language-haskell">capital :: String -&gt; String  
capital &quot;&quot; &#x3D; &quot;Empty string, whoops!&quot;  
capital all@(x:xs) &#x3D; &quot;The first letter of &quot; ++ all ++ &quot; is &quot; ++ [x]<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre></p></li></ul><h4 id="guards守卫">Guards(守卫)</h4><p>💂🏽<code>guard</code>用来检查一个值的某项属性是否为真. 听起来和路由守卫一样, 如果条件判断通过就放行. 例如计算BMI函数:</p><pre class="line-numbers language-haskell" data-language="haskell"><code class="language-haskell">bmiTell :: (RealFloat a) &#x3D;&gt; a -&gt; String  
bmiTell bmi         -- 注意这里没有等号
    | bmi &lt;&#x3D; 18.5 &#x3D; &quot;underweight&quot;      -- 等号在这里
    | bmi &lt;&#x3D; 25.0 &#x3D; &quot;Pffft&quot;                -- 与if-else一样只会匹配第一个通过的
    | bmi &lt;&#x3D; 30.0 &#x3D; &quot;fat&quot;  
    | otherwise   &#x3D; &quot;whale&quot;      -- 最后可以使用otherwise兜底<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>👀看起来是个语法糖: <code>|</code>和<code>if-else-if</code>一样, <code>otherwise</code>和兜底<code>else</code>一样, 但是用在此处相当简洁.</p><p>⚠️如果使用<code>Guard</code>且没有使用<code>otherwise</code>且全部匹配失败, Haskell会匹配下一个函数, 例如:</p><pre class="line-numbers language-haskell" data-language="haskell"><code class="language-haskell">f :: (Ord a, Num a) &#x3D;&gt; a -&gt; [a]
f x
  | x &lt; 0 &#x3D; error &quot;make sure x &gt;&#x3D; 0&quot;
  | x &#x3D;&#x3D; 0 &#x3D; [0]
f x &#x3D; x : f (x - 1)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>如果<code>x&gt;0</code>, <code>f x</code>会先进入第一个函数, 两个<code>guard</code>都匹配失败了, 于是进入下一个模式匹配</p><h4 id="where绑定">Where绑定</h4><p>改进一下BMI, 要求用户输入身高与体重👇</p><pre class="line-numbers language-haskell" data-language="haskell"><code class="language-haskell">bmiTell :: (RealFloat a) &#x3D;&gt; a -&gt; a -&gt; String  
bmiTell weight height  
    | weight &#x2F; height ^ 2 &lt;&#x3D; 18.5 &#x3D; &quot;underweight&quot;  
    | weight &#x2F; height ^ 2 &lt;&#x3D; 25.0 &#x3D; &quot;Pffft&quot;  
    | weight &#x2F; height ^ 2 &lt;&#x3D; 30.0 &#x3D; &quot;fat&quot;  
    | otherwise                   &#x3D; &quot;whale&quot;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>与命令式语言一样, 我们想把<code>weight / height ^ 2</code>定义成变量, 可以使用<code>where</code>关键字</p><pre class="line-numbers language-haskell" data-language="haskell"><code class="language-haskell">bmiTell :: (RealFloat a) &#x3D;&gt; a -&gt; a -&gt; String  
bmiTell weight height  
    | bmi &lt;&#x3D; 18.5 &#x3D; &quot;underweight&quot;  
    | bmi &lt;&#x3D; 25.0 &#x3D; &quot;Pffft&quot;  
    | bmi &lt;&#x3D; 30.0 &#x3D; &quot;fat&quot;  
    | otherwise   &#x3D; &quot;whale&quot;
    where bmi &#x3D; weight &#x2F; height ^ 2<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>就像写数学公式一样 <span class="math display">\[ \begin{equation} f(h,w) = \left\{ \\ \begin{aligned} &amp;\text{underweight} &amp; BMI\leq 18.5 \\ &amp;\text{Pffft} &amp; 18.5&lt; BMI\leq 25 \\ &amp;\text{fat} &amp; 25&lt; BMI\leq 30 \\ &amp;\text{whale} &amp; 30&lt; BMI \end{aligned} \right. \ \ \ where\ BMI = w/h^2 \end{equation} \]</span> <code>where</code>后面可以跟多个名字和函数定义</p><pre class="line-numbers language-haskell" data-language="haskell"><code class="language-haskell">bmiTell :: (RealFloat a) &#x3D;&gt; a -&gt; a -&gt; String  
bmiTell weight height  
    | bmi &lt;&#x3D; skinny &#x3D; &quot;You&#39;re underweight, you emo, you!&quot;  
    | bmi &lt;&#x3D; normal &#x3D; &quot;You&#39;re supposedly normal. Pffft, I bet you&#39;re ugly!&quot;  
    | bmi &lt;&#x3D; fat    &#x3D; &quot;You&#39;re fat! Lose some weight, fatty!&quot;  
    | otherwise     &#x3D; &quot;You&#39;re a whale, congratulations!&quot;  
    where bmi &#x3D; weight &#x2F; height ^ 2  
          skinny &#x3D; 18.5  
          normal &#x3D; 25.0  
          fat &#x3D; 30.0<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>⚠️注意</p><ul><li><p><code>where</code> 绑定中定义的名字只对本函数可见, 其中的名字都是一列垂直排开</p></li><li><p><code>where</code> 绑定也可以使用模式匹配, 前面那段代码可以改成：</p><p><pre class="line-numbers language-haskell" data-language="haskell"><code class="language-haskell">where bmi &#x3D; weight &#x2F; height ^ 2  
      (skinny, normal, fat) &#x3D; (18.5, 25.0, 30.0)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre></p></li><li><p><code>where</code>可以嵌套使用</p></li></ul><h4 id="let绑定">Let绑定</h4><p>与<code>where</code>类似, 作用域不同. <code>where</code>绑定在函数底部, 在<strong>所有<code>guard</code>内</strong>可见, 但<code>let</code>只对<code>let-in</code>绑定的<code>in</code><strong>表达式</strong>可见, 例如</p><pre class="line-numbers language-haskell" data-language="haskell"><code class="language-haskell">cylinder :: (RealFloat a) &#x3D;&gt; a -&gt; a -&gt; a  
cylinder r h &#x3D; 
    let sideArea &#x3D; 2 * pi * r * h  
        topArea &#x3D; pi * r ^2  
    in  sideArea + 2 * topArea<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="case表达式">Case表达式</h4><p>与命令式编程的<code>case</code>类似, 同样支持模式匹配</p><pre class="line-numbers language-haskell" data-language="haskell"><code class="language-haskell">case expression of pattern -&gt; result  
                   pattern -&gt; result  
                   pattern -&gt; result  
                   ...<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>例如</p><pre class="line-numbers language-haskell" data-language="haskell"><code class="language-haskell">describeList :: [a] -&gt; String  
describeList xs &#x3D; &quot;The list is &quot; ++ case xs of [] -&gt; &quot;empty.&quot;  
                                               [x] -&gt; &quot;a singleton list.&quot;   
                                               xs -&gt; &quot;a longer list.&quot;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><h4 id="将函数定义为中缀函数">将函数定义为中缀函数</h4><p>不使用反引号也可以定义中缀函数. 但是, 函数名只能使用<code>:|!@#$%^&amp;*-+./&lt;&gt;?\~</code>, 之后可以使用下面任意方式定义</p><pre class="line-numbers language-haskell" data-language="haskell"><code class="language-haskell">a |+| b   &#x3D; method1
(|+|) a b &#x3D; method1 a b 
(|+|)     &#x3D; method1<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><h4 id="定义函数的结合性与优先级">定义函数的结合性与优先级</h4><p>例如</p><pre class="line-numbers language-haskell" data-language="haskell"><code class="language-haskell">infixr 9 op<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><ul><li><code>infi*</code>定义结合性<br><code>infixr</code>是右结合, <code>infixl</code>是左结合, <code>infix</code>无左右优先性.</li><li>数字定义优先级<br>优先级一共有十个, <code>0-9</code>, 数字越大越高, 如果定义时省略了数字, 则默认为9. 预定义的有</li></ul><table><thead><tr class="header"><th>值</th><th>左结合</th><th>无结合</th><th>右结合</th></tr></thead><tbody><tr class="odd"><td>9</td><td>!!</td><td></td><td>.</td></tr><tr class="even"><td>8</td><td></td><td></td><td>^, ^^, **</td></tr><tr class="odd"><td>7</td><td>*,/,<code>div</code></td><td></td><td></td></tr><tr class="even"><td>6</td><td>+, -</td><td></td><td></td></tr><tr class="odd"><td>5</td><td></td><td></td><td>:, ++</td></tr><tr class="even"><td>4</td><td></td><td>==,/=,&lt;,&lt;=,&gt;,&gt;=,<code>elem</code>,<code>notElem</code></td><td></td></tr><tr class="odd"><td>3</td><td></td><td></td><td>&amp;&amp;</td></tr><tr class="even"><td>2</td><td></td><td></td><td></td></tr><tr class="odd"><td>1</td><td>&gt;&gt;, &gt;&gt;=</td><td></td><td></td></tr><tr class="even"><td>0</td><td></td><td></td><td><span class="math inline">\(,\)</span>!,<code>seq</code></td></tr></tbody></table><h3 id="递归">递归</h3><p>🪆使用模式匹配与递归可以优雅的实现递归. 在实现递归时最需要关注的就是<strong>边界条件</strong>. <strong>而递归的的实现思路就是描述问题是如何定义的</strong></p><ul><li><p>实现<code>List</code>的<code>max</code>函数</p><p>命令式思路: 设一个变量来存储当前的最大值，然后用循环遍历该 <code>List</code>，若存在比这个值更大的元素，则修改变量为这一元素的值</p><p>函数式思路: <code>List</code>的最大值就是<code>head</code>和<code>tail</code>最大值的最大值. 空<code>List</code>的最大值为Error</p><pre class="line-numbers language-haskell" data-language="haskell"><code class="language-haskell">maximum&#39; :: (Ord a) &#x3D;&gt; [a] -&gt; a  
maximum&#39; [] &#x3D; error &quot;maximum of empty list&quot;  
maximum&#39; [x] &#x3D; x  
maximum&#39; (x:xs)   
    | x &gt; maxTail &#x3D; x  
    | otherwise &#x3D; maxTail  
    where maxTail &#x3D; maximum&#39; xs<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li><li><p>实现<code>replicate n x</code>函数(将<code>x</code>重复<code>n</code>次)</p><pre class="line-numbers language-haskell" data-language="haskell"><code class="language-haskell">replicate&#39; :: (Num i, Ord i) &#x3D;&gt; i -&gt; a -&gt; [a]  
replicate&#39; n x  
    | n &lt;&#x3D; 0    &#x3D; []  
    | otherwise &#x3D; x:replicate&#39; (n-1) x<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>⚠️这里使用<code>Guard</code>而不是模式匹配是因为模式匹配无法匹配<code>&lt;0</code></p></li><li><p>实现<code>take</code>函数</p><pre class="line-numbers language-haskell" data-language="haskell"><code class="language-haskell">take&#39; :: (Num i, Ord i) &#x3D;&gt; i -&gt; [a] -&gt; [a]  
take&#39; 0 _ &#x3D; []
take&#39; _ [] &#x3D; []
take&#39; n (x:xs) &#x3D; x : take&#39; (n-1) xs<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>更加周全的的代码(同样因为我们要匹配<code>n&lt;0</code>的情况, 所以不能用模式匹配了)</p><pre class="line-numbers language-haskell" data-language="haskell"><code class="language-haskell">take&#39; :: (Num i, Ord i) &#x3D;&gt; i -&gt; [a] -&gt; [a]  
take&#39; n _  
    | n &lt;&#x3D; 0   &#x3D; []  
take&#39; _ []     &#x3D; []  
take&#39; n (x:xs) &#x3D; x : take&#39; (n-1) xs<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre></li><li><p>实现<code>repeat</code>函数</p><pre class="line-numbers language-haskell" data-language="haskell"><code class="language-haskell">repeat&#39; :: a -&gt; [a]  
repeat&#39; x &#x3D; x:repeat&#39; x<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre></li><li><p>实现<code>zip</code>函数</p><pre class="line-numbers language-haskell" data-language="haskell"><code class="language-haskell">zip&#39; :: [a] -&gt; [b] -&gt; [(a, b)]
zip&#39; [] _ &#x3D; []
zip&#39; _ [] &#x3D; []
zip&#39; (x1:xs1) (x2:xs2) &#x3D; (x1,x2):zip&#39; xs1 xs2<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre></li><li><p>实现<code>elem</code>函数</p><pre class="line-numbers language-haskell" data-language="haskell"><code class="language-haskell">elem&#39; :: (Eq a) &#x3D;&gt; a -&gt; [a] -&gt; Bool
elem&#39; e [] &#x3D; False
elem&#39; e (x : xs) &#x3D; (e &#x3D;&#x3D; x) || elem&#39; e xs<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>但是有点不函数式, 改一改</p><pre class="line-numbers language-haskell" data-language="haskell"><code class="language-haskell">elem&#39; :: (Eq a) &#x3D;&gt; a -&gt; [a] -&gt; Bool
elem&#39; e (x : xs)
  | e &#x3D;&#x3D; x &#x3D; True
  | otherwise &#x3D; elem&#39; e xs
elem&#39; e _ &#x3D; False<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre></li><li><p>温习一下快速排序(并使用<code>where</code>让其看起来更像函数式)</p><pre class="line-numbers language-haskell" data-language="haskell"><code class="language-haskell">qsort :: (Ord a) &#x3D;&gt; [a] -&gt; [a]
qsort (target:xs) &#x3D; lowers ++ [target] ++ uppers 
  where lowers &#x3D; qsort [x|x&lt;-xs, x&lt;&#x3D;target]
        uppers &#x3D; qsort [x|x&lt;-xs, x&gt;target]
qsort _ &#x3D; []<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre></li></ul><p>⚠️思路: 定义边界条件, 再定义个函数, 让它从一堆元素中取一个并做点事情后, 把余下的元素重新交给这个函数</p><ul><li><p>实现埃筛</p><pre class="line-numbers language-haskell" data-language="haskell"><code class="language-haskell">primes &#x3D; filterPrime [2..]
  where filterPrime (p:xs) &#x3D;
          p : filterPrime [x | x &lt;- xs, x &#96;mod&#96; p &#x2F;&#x3D; 0]<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>这种生成器生成+验证器验证的模式值得学习<br></p></li><li><p>实现斐波那契</p><pre class="line-numbers language-haskell" data-language="haskell"><code class="language-haskell">fib :: Int -&gt; [Int]
fib n &#x3D; take n $ fibList [1, 1]
  where
    fibList [a, b] &#x3D; a : fibList [b, a + b]<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>注意学习如何存储递归中需要的调用值</p></li></ul><h3 id="函数pro">函数Pro</h3><p>😕函数式编程与数学表达式看起来太像了.</p><p>👼于是我天真的以为函数式编程就是用数学的方式描述问题, 然后将其表示为函数式编程语句.</p><p>🤔实际上函数式编程更加注重<strong>将函数作为"一等公民", 从而操作函数或是函数的一部分解决问题</strong></p><h4 id="函数柯里化与不全调用">函数柯里化与不全调用</h4><p>在JS中经常能听到这个函数柯里化这个词语, 在JS中, 柯里化就是把多参函数变成单参函数, 并返回一个单参数函数用于吃下下一个参数.</p><p>🍬但是, Haskell中所有函数都只有一个参数, 所有函数都是柯里化函数. 而多参函数只是一个语法糖!</p><p>😱拿<code>max</code>函数举例. <code>max</code>函数实际上只接受一个参数<code>x</code>, 然后返回一个和<code>x</code>比较大小的函数,例如</p><pre class="line-numbers language-haskell" data-language="haskell"><code class="language-haskell">comp x y &#x3D; x y  -- 接受x,y 返回x y的结果
maxWith5 &#x3D; max 5     -- 返回一个max 5函数
res &#x3D; zipWith comp (repeat maxWith5) [1 .. 10]
-- [5,5,5,5,5,6,7,8,9,10]<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>也就是说<code>maxWith5</code>就是一个函数, 函数接受一个参数, 返回和<code>5</code>比较大的那个, 也就是我们之前写的<code>max 5 6</code>可以写成<code>(max 5) 6</code></p><p>再看看<code>maxWith5</code>, 试试写出他的类型:<code>Ord a =&gt; a -&gt; a</code>. 显而易见, 接受一个<code>Ord</code>类型类的<code>a</code>类变量, 返回一个<code>a</code>类变量. 而之前那个<code>max</code>函数呢? 收到一个<code>a</code>类变量, 返回一个<code>Ord a =&gt; a -&gt; a</code>类函数. 试试写出<code>max</code>函数类型: <code>Ord a =&gt; a -&gt; (a-&gt;a)</code>这个括号没啥用(因为Haskell是自左向右解析的)于是简化成<code>Ord a =&gt; a -&gt; a -&gt; a</code>这也就解释了<strong>为什么把参数类型与结果用<code>-&gt;</code>连在一起是符合直觉的</strong></p><p>⚛像<code>max 5</code>这样的函数调用就是<strong>不全调用</strong>, 而中缀函数也存在不全调用, 例如<code>elem [1..]</code>, <code>==4</code>, <code>*5</code></p><h4 id="高阶函数">高阶函数</h4><p>🌌高阶函数: 接收函数作为参数或返回函数的函数就是高阶函数, 例如</p><pre class="line-numbers language-haskell" data-language="haskell"><code class="language-haskell">applyTwice :: (a -&gt; a) -&gt; a -&gt; a  
applyTwice f x &#x3D; f (f x)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>这个类型似乎有点特别, 多了一个括号, 表示第一个参数是一个函数而不是类型<code>a</code>(因为Haskell是右结合的)</p><p>结合函数柯里化与不全调用, 我们可以写出这样的表达式</p><pre class="line-numbers language-haskell" data-language="haskell"><code class="language-haskell">applyTwice (+3) 10         -- 16 (调用函数子  😲
applyTwice (++ &quot; HAHA&quot;) &quot;HEY&quot;  --&quot;HEY HAHA HAHA&quot;  
applyTwice (&quot;HAHA &quot; ++) &quot;HEY&quot;    -- &quot;HAHA HAHA HEY&quot;  
ghci&gt; applyTwice (multThree 2 2) 9  -- 144  
ghci&gt; applyTwice (3:) [1]           -- [3,3,1]<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>结合函数子可以实现多种炫酷的操作. 这就是把函数当成对象用</p><p>实现一个<code>zipWith</code>, 体验一下无参数的不全调用</p><pre class="line-numbers language-haskell" data-language="haskell"><code class="language-haskell">zipWith&#39; :: (a -&gt; b -&gt; c) -&gt; [a] -&gt; [b] -&gt; [c]
zipWith&#39; f (x : xs) (y : ys) &#x3D; f x y : zipWith&#39; f xs ys

zipWith&#39; (+) [4,2,5,6] [2,6,2,3]         --[6,8,7,9]  
zipWith&#39; max [6,3,2,1] [7,3,1,5]         -- [7,3,2,5]  
zipWith&#39; (++) [&quot;foo &quot;, &quot;bar &quot;, &quot;baz &quot;] [&quot;fighters&quot;, &quot;hoppers&quot;, &quot;aldrin&quot;]    
-- [&quot;foo fighters&quot;,&quot;bar hoppers&quot;,&quot;baz aldrin&quot;]  
zipWith&#39; (*) (replicate 5 2) [1..]       -- [2,4,6,8,10]  
zipWith&#39; (zipWith&#39; (*)) [[1,2,3],[3,5,6],[2,3,4]] [[3,2,2],[3,4,5],[5,4,3]]  
-- [[3,4,6],[9,20,30],[10,12,12]]<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>可以借助高阶函数实现命令式中的<code>for</code>、<code>while</code>、赋值、状态检测</p><p><code>flip</code>是一个常用高阶函数, 实现功能很简单</p><pre class="line-numbers language-haskell" data-language="haskell"><code class="language-haskell">flip :: (a -&gt; b -&gt; c) -&gt; b -&gt; a -&gt; c  
flip f y x &#x3D; f x y<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>也就是传入一个二元函数, 传回一个接受参数相反的二元函数(<strong>注意: 传回的是函数而不是函数的运行结果!</strong>)</p><p>⚠️<code>flip</code>经常用来对库函数进行改进, 例如我需要函数</p><pre class="line-numbers language-haskell" data-language="haskell"><code class="language-haskell">pushFont :: [a]-&gt;a-&gt;[a]
pushFont xs x &#x3D; x:xs<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>要是函数参数能反过来就好了, 于是我就可以写</p><pre class="line-numbers language-haskell" data-language="haskell"><code class="language-haskell">pushFont :: [a]-&gt;a-&gt;[a]
pushFont &#x3D; flip (:)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>不需要添加参数, 就算固执的添加上了参数, 函数只是变成这样</p><pre class="line-numbers language-haskell" data-language="haskell"><code class="language-haskell">pushFont :: [a]-&gt;a-&gt;[a]
pushFont x xs &#x3D; flip (:) x xs<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>都是在最后调用函数, 那么加不加参数没关系. 记住: <strong>我们定义的是函数, 而不是运算结果</strong></p><h4 id="lambda函数">Lambda函数</h4><p>与JS类型, 可以生成匿名函数, 通常在这个函数只是用一次的时候使用, 语法为<code>\参数1 参数2 -&gt; 表达式</code>, 例如</p><pre class="line-numbers language-haskell" data-language="haskell"><code class="language-haskell">flip&#39; :: (a -&gt; b -&gt; c) -&gt; b -&gt; a -&gt; c  
flip&#39; f x y &#x3D; \x y -&gt; f y x<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>尽管这与 <code>flip' f x y = f y x</code> 等价，它可以更明白地表示出它会产生一个新的函数</p><h4 id="mapfilterfoldscan">map&amp;filter&amp;fold&amp;scan</h4><p>这几个函数与JS的<code>Array.map</code>, <code>Array.filter</code>, <code>Array.reduce</code>很像, 所以十分重要</p><p>他们本身是List的方法, 但是在库函数加载的时候被自动引用了, 也就是类似于</p><pre class="line-numbers language-haskell" data-language="haskell"><code class="language-haskell">map &#x3D; Array.map<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><ul><li><p><code>map</code></p><pre class="line-numbers language-haskell" data-language="haskell"><code class="language-haskell">map :: (a -&gt; b) -&gt; [a] -&gt; [b]  
map _ [] &#x3D; []  
map f (x:xs) &#x3D; f x : map f xs<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>传入映射函数与<code>List</code>, 返回对每个元素映射后的结果</p><pre class="line-numbers language-haskell" data-language="haskell"><code class="language-haskell">map (+3) [1,5,3,1,6]                    -- [4,8,6,4,9]  
map (++ &quot;!&quot;) [&quot;BIFF&quot;, &quot;BANG&quot;, &quot;POW&quot;]    -- [&quot;BIFF!&quot;,&quot;BANG!&quot;,&quot;POW!&quot;]  
map (replicate 3) [3..6]               -- [[3,3,3],[4,4,4],[5,5,5],[6,6,6]]  
map (map (^2)) [[1,2],[3,4,5,6],[7,8]]  -- [[1,4],[9,16,25,36],[49,64]]  
map fst [(1,2),(3,5),(6,3),(2,6),(2,5)] -- [1,3,6,2,2]<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>使用函数子作为函数调用就让<code>map</code>炫酷多了</p><p>以上的所有代码都可以用 List Comprehension 来替代。<code>map (+3) [1,5,3,1,6]</code> 与 <code>[x+3 | x &lt;- [1,5,3,1,6]</code> 完全等价.</p></li><li><p><code>filter</code></p><pre class="line-numbers language-haskell" data-language="haskell"><code class="language-haskell">filter :: (a -&gt; Bool) -&gt; [a] -&gt; [a]  
filter _ [] &#x3D; []  
filter p (x:xs)   
    | p x       &#x3D; x : filter p xs  
    | otherwise &#x3D; filter p xs<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>传入判断函数, 传出符合要求的元素</p><pre class="line-numbers language-haskell" data-language="haskell"><code class="language-haskell">filter (&gt;3) [1,5,3,2,1,6,4,3,2,1]         -- [5,6,4]  
filter (&#x3D;&#x3D;3) [1,2,3,4,5]                  -- [3]  
filter even [1..10]                       -- [2,4,6,8,10]  
let notNull x &#x3D; not (null x) in filter notNull [[1,2,3],[],[3,4,5],[2,2],[],[],[]]  
-- [[1,2,3],[3,4,5],[2,2]]  
filter (&#96;elem&#96; [&#39;a&#39;..&#39;z&#39;]) &quot;u LaUgH aT mE BeCaUsE I aM diFfeRent&quot;  
-- &quot;uagameasadifeent&quot;  
filter (&#96;elem&#96; [&#39;A&#39;..&#39;Z&#39;]) &quot;i lauGh At You BecAuse u r aLL the Same&quot;  
-- &quot;GAYBALLS&quot;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>以上都可以用 <code>List Comprehension</code> 的限制条件来实现。并没有教条规定你必须在什么情况下用 <code>map</code> 和 <code>filter</code> 还是 <code>List Comprehension</code>. 如果有多个限制条件，只能连着套好几个 <code>filter</code> 或用 <code>&amp;&amp;</code> 等逻辑函数的组合之, 这时就不如 <code>List comprehension</code></p></li><li><p><code>fold</code>系列函数有<code>foldl</code>, <code>foldlr</code>,<code>foldl1</code>, <code>foldlr1</code></p><pre class="line-numbers language-haskell" data-language="haskell"><code class="language-haskell">foldl&#39; :: (b -&gt; a -&gt; b) -&gt; b -&gt; [a] -&gt; b
foldl&#39; _ pre [] &#x3D; pre
foldl&#39; f pre (tar : tails) &#x3D; fold&#39; f (f pre tar) tails<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>与<code>reduce</code>类似, 参数有: 指定返回累加值函数, 累加初始值, 数组. 例如:</p><p>实现数组求和</p><pre class="line-numbers language-haskell" data-language="haskell"><code class="language-haskell">sum&#39; :: (Num a) &#x3D;&gt; [a] -&gt; a  
sum&#39; &#x3D; foldl (+) 0<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>又省略参数了, 因为<strong>我们定义的是函数, 而不是运算结果</strong></p><p>实现<code>reverse</code>(看我是多蠢🙃)</p><pre class="line-numbers language-haskell" data-language="haskell"><code class="language-haskell">reverse&#39; :: [a] -&gt; [a]
reverse&#39; xs &#x3D; foldl (\acc x -&gt; x:acc) [] xs<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>首先<code>xs</code>是可以省略的(<strong>我们定义的是函数, 而不是运算结果</strong>)</p><p>其次<code>\acc x -&gt; x:acc</code>实际上就是<code>flip (:)</code>于是改成</p><pre class="line-numbers language-haskell" data-language="haskell"><code class="language-haskell">reverse&#39; :: [a] -&gt; [a]
reverse&#39; &#x3D; foldl (flip (:)) []<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p><code>foldr</code>与<code>foldl</code>的区别就是前者是自右向左遍历, 例如</p><pre class="line-numbers language-haskell" data-language="haskell"><code class="language-haskell">reverse&#39; :: [a] -&gt; [a]
reverse&#39; &#x3D; foldr (:) []

map&#39; :: (a -&gt; b) -&gt; [a] -&gt; [b]  
map&#39; f &#x3D; foldr (\x acc -&gt; f x : acc) []<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><code>foldl1</code> 与 <code>foldr1</code> 的行为与 <code>foldl</code> 和 <code>foldr</code> 相似，只是你无需明确提供初始值。他们假定 List 的首个(或末尾)元素作为起始值</p><p>实现一些库函数</p><pre class="line-numbers language-haskell" data-language="haskell"><code class="language-haskell">maximum&#39; :: (Ord a) &#x3D;&gt; [a] -&gt; a  
maximum&#39; &#x3D; foldr1 (\x acc -&gt; if x &gt; acc then x else acc)  
product&#39; :: (Num a) &#x3D;&gt; [a] -&gt; a  
product&#39; &#x3D; foldr1 (*)  

filter&#39; :: (a -&gt; Bool) -&gt; [a] -&gt; [a]  
filter&#39; p &#x3D; foldr (\x acc -&gt; if p x then x : acc else acc) []  

head&#39; :: [a] -&gt; a  
head&#39; &#x3D; foldr1 (\x _ -&gt; x)  

last&#39; :: [a] -&gt; a  
last&#39; &#x3D; foldl1 (\_ x -&gt; x)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li><li><p><code>scan</code>系列包括<code>scanl</code>,<code>scanr</code>, <code>scanl1</code>和<code>scanr1</code>. 可以简单理解为<code>scanl</code>,<code>scanr</code>返回的是<code>foldl</code>, <code>foldr</code>的每一步中间值. <code>scanl1</code>和<code>scanr1</code>与<code>foldl1</code>, <code>foldr1</code>类似</p><pre class="line-numbers language-haskell" data-language="haskell"><code class="language-haskell">scanl&#39; :: (a -&gt; b -&gt; b) -&gt; b -&gt; [a] -&gt; [b]
scanl&#39; f xs0 &#x3D; foldl (\aac x -&gt; aac ++ [f x (last aac)]) [xs0]<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>可以看到<code>scan*</code>似乎是调试<code>fold*</code>的好工具</p></li></ul><p>与之前的语法组合, 可以发现</p><ul><li><p><code>Lambda</code>表达式可以搭配这些函数实现炫酷效果</p></li><li><p>可以使用<code>takeWhile</code>方便的处理用上述函数处理无限长数组的结果</p><pre class="line-numbers language-haskell" data-language="haskell"><code class="language-haskell">takeWhile&#39; :: (a -&gt; Bool) -&gt; [a] -&gt; [a]
takeWhile&#39; _ [] &#x3D; []
takeWhile&#39; f (x : xs)
  | f x &#x3D; x : takeWhile&#39; f xs
  | otherwise &#x3D; []<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre></li></ul><h4 id="与.调用"><code>$</code>与<code>.</code>调用</h4><ul><li><p><code>$</code>也是一个函数</p><pre class="line-numbers language-haskell" data-language="haskell"><code class="language-haskell">($) :: (a -&gt; b) -&gt; a -&gt; b  
f $ x &#x3D; f x<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>🤨看起来就是将连个函数和参数连起来. 差不多, 但是别忘了在Haskell中函数调用具有最高优先级(且是左结合, 即: 同级表达式自右向左计算, 例如 f a b = (f a) b, 可以粗暴理解成将左边的结合在一起), 但是这里的<code>$</code>具有最低优先级(且是右结合, 即: 同级表达式自左向右计算, 例如 f $ a b = f (a b), 可以粗暴理解成将右边的结合在一起)</p><p>例如</p><pre class="line-numbers language-haskell" data-language="haskell"><code class="language-haskell">t &#x3D; max 5 max 6 7<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>在Haskell中会报错, 原因是Haskell将代码理解成了(左结合了)</p><pre class="line-numbers language-haskell" data-language="haskell"><code class="language-haskell">t &#x3D; ((max 5) max) 6 7<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>我们只能添加括号</p><pre class="line-numbers language-haskell" data-language="haskell"><code class="language-haskell">t &#x3D; max 5 (max 6 7)<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>另一个方式就是使用<code>$</code></p><pre class="line-numbers language-haskell" data-language="haskell"><code class="language-haskell">t &#x3D; max 5 $ max 6 7
--  |---| 先解析这一段返回一个函数
--        ^ 遇到了$于是无法解析, 解析右边
--          |------|解析这一段的得到7
--  (max 5) 7  变成了这样
-- 最后得到7<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>看<code>$</code>起来就像是为左右两边分别加了等优先级的隔离符(括号)<strong>从而保护两边分别计算</strong>, 例如</p><pre class="line-numbers language-haskell" data-language="haskell"><code class="language-haskell">map ($ 3) [(4+),(10*),(^2),sqrt]  
-- [7.0,30.0,9.0,1.7320508075688772]<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>⚠️但是注意<code>$</code>右结合的, 是单值函数(左边是<strong>函数</strong>右边是<strong>单参数</strong>). 可能你会想Haskell中的函数本身就是柯里化的函数🙄? 似乎没有什么影响?🤨 于是想当然的进行如下改进</p><pre class="line-numbers language-haskell" data-language="haskell"><code class="language-haskell">t :: [(Int, Int)]
t &#x3D; zip (map (+ 5) [1 .. 10]) (map (* 5) [10 .. 20])
-- 改为 --&gt;
t &#x3D; zip $ map (+ 5) [1 .. 10] $ map (* 5) [10 .. 20]<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>🤨看起来是可行的</p><pre class="line-numbers language-haskell" data-language="haskell"><code class="language-haskell">-- Step 1
zip $ [6..15] $ [10..100]
-- Step 2
(zip [6..15]) [10..100]
-- Step 3
newFunction [10..100]<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>💀执行就出问题, 别忘了<code>$</code>是低优先级右结合的, Haskell是这么理解代码的</p><pre class="line-numbers language-haskell" data-language="haskell"><code class="language-haskell">-- Step 1 $ 是低优先级的, 其他先计算
zip $ [6..15] $ [10..100]
-- Step 2 $ 是右结合的...
zip ([6..15] $ [10..100])<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>左边算出来是个List, 不是<code>$</code>接收的函数, 如何验证呢? 这样改</p><pre class="line-numbers language-haskell" data-language="haskell"><code class="language-haskell">t :: [b] -&gt; [(Integer, b)]
t &#x3D; zip $ map (+ 5) [1 .. 10]

tt :: [(Integer, Integer)]
tt &#x3D; t $ map (* 5) [10 .. 20]<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>实际上VSCode的HLint插件因为给我们提示</p><pre class="line-numbers language-haskell" data-language="haskell"><code class="language-haskell">However, $ has low, right-associative binding precedence, so it sometimes allows parentheses to be omitted; for example:

f $ g $ h x  &#x3D;  f (g (h x))
It is also useful in higher-order situations, such as map ($ 0) xs, or Data.List.zipWith ($) fs xs<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>看到了吧, 不能将<code>$</code>了理解为路障🚧, 简单的将代码左右加上括号, 而是一个网🕸️, 将<code>$</code>后面的都包起来</p><pre class="line-numbers language-haskell" data-language="haskell"><code class="language-haskell">f $ g x $ h x --理解为--&gt; f (g x) (h x)  💩
f $ g x $ h x --理解为--&gt; f (g x (h x))  👍<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p><del>毕竟<code>$</code>💵从来不是障碍🚧, 而是陷阱把你包起来🕸️</del></p><p>😲<code>$</code> <strong>还可以将数据作为函数使用</strong> 例如映射一个函数调用符到一组函数组成的 List：</p><pre class="line-numbers language-haskell" data-language="haskell"><code class="language-haskell">map ($ 3) [(4+),(10*),(^2),sqrt]<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></li><li><p><code>.</code>调用(Function composition, 函数组合)</p><pre class="line-numbers language-haskell" data-language="haskell"><code class="language-haskell">(.) :: (b -&gt; c) -&gt; (a -&gt; b) -&gt; a -&gt; c    
-- 注意, 这里要求函数的返回值与下一个函数的参数类型是相同的
f . g &#x3D; \x -&gt; f (g x)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>与数学中的复合函数类似, 我们可以这样表示组合函数 <span class="math display">\[ f(g(x)) = (f \circ g)(x) \]</span> 在Haskell中我们也可以将<code>f (g x)</code>(或者<code>f $ g x</code>)表示为<code>f . g x</code></p><pre class="line-numbers language-haskell" data-language="haskell"><code class="language-haskell">f &#x3D; (+ 1)
g &#x3D; (* 10)

t1 :: Integer -&gt; Integer
t1 x &#x3D; f (g x)   -- 最简单的形式

t2 :: Integer -&gt; Integer
t2 x &#x3D; f $ g x   -- 把括号干掉

-- t2&#39; :: Integer -&gt; Integer
-- t2&#39; &#x3D; f $ g   -- Error

t3 :: Integer -&gt; Integer
t3 &#x3D; f . g<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li>我们平时写的是<code>t1</code>的形式, 为了方便的写<span class="math inline">\(f ( g (x) )\)</span>, 我们引入<code>$</code>. 并实现了<code>t2</code>形式</li><li>我们想换成<span class="math inline">\((f \circ g)(x)\)</span>形式, 这时就需要<code>.</code>运算</li></ul><p>看起来<code>.</code>, <code>$</code>是等价的互换形式(<code>$</code>, <code>.</code>都是右结合的), 但是他们的类型有很大的区别</p><pre class="line-numbers language-haskell" data-language="haskell"><code class="language-haskell">($) :: (a -&gt; b) -&gt; a -&gt; b  
(.) :: (b -&gt; c) -&gt; (a -&gt; b) -&gt; a -&gt; c  <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><ul><li><code>$</code>接收<strong>函数与变量</strong>, 返回一个<strong>变量</strong></li><li><code>.</code>接收<strong>两个函数</strong>, 返回一个<strong>函数</strong></li></ul><p>没人说变量不能是一个函数, 函数不能是变量, 直觉看起来<code>$</code>用于表达式<code>.</code>用于函数, 例如</p><pre class="line-numbers language-haskell" data-language="haskell"><code class="language-haskell">map (\xs -&gt; negate (sum (tail xs))) [[1..5],[3..6],[1..7]]  
-- 优化为 --&gt;
map (negate . sum . tail) [[1..5],[3..6],[1..7]]  
[-14,-15,-27]<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>对于多参函数, 我们可以借用<code>()</code>或<code>$</code></p><pre class="line-numbers language-haskell" data-language="haskell"><code class="language-haskell">sum (replicate 5 (max 6.7 8.9))
(sum . replicate 5 . max 6.7) 8.9
sum . replicate 5 . max 6.7 $ 8.9<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>😲<code>.</code><strong>另一用途就是定义point free style</strong></p><ul><li><p>感谢柯里化函数, 当函数参数按顺序仅仅出现在实现的尾部时候时我们可以将参数省略, 例如</p><pre class="line-numbers language-haskell" data-language="haskell"><code class="language-haskell">myFun :: (Ord a) &#x3D;&gt; a -&gt; a -&gt; a
myFun x y &#x3D; max x y<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>简化为</p><pre class="line-numbers language-haskell" data-language="haskell"><code class="language-haskell">myFun :: (Ord a) &#x3D;&gt; a -&gt; a -&gt; a
myFun &#x3D; max<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre></li><li><p>如果参数顺序出现, 但是参数在括号内部呢?</p><pre class="line-numbers language-haskell" data-language="haskell"><code class="language-haskell">myFun x y &#x3D; (* 2) (max x y)<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>使用<code>.</code>将一个参数从括号中解放出来</p><pre class="line-numbers language-haskell" data-language="haskell"><code class="language-haskell">myFun x &#x3D; (* 2) . max x<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><code>.</code>是右结合的, 所以我们只能解放一个参数</p><p>这样的省略参数形式就是point free style</p></li></ul></li></ul><h3 id="模块">模块</h3><p>Haskell 中的模块是含有一组相关的函数，型别和型别类的组合。而 Haskell 进程的本质便是从主模块中引用其它模块并调用其中的函数来执行操作。其中缺省自动加载的函数均在<code>Prelude</code>模块中. Haskell模块加载规则与Python类似</p><pre class="line-numbers language-haskell" data-language="haskell"><code class="language-haskell">import Data.List             -- 加载List模块
import Data.List(sort, nub)   -- 仅加载List模块的sort&amp;nub
import Data.List hiding (nub) -- 引入除nub外的List模块(一般用于名字冲突)

sort [1,2,3]     -- 直接调用即可, 无需模块名

import qualified Data.Map     -- 引入Map模块, 但是使用需要指明模块(用于名字冲突)

Data.Map.sort [1,2,3]     -- 指明模块名引入

import qualified Data.Map as M -- 指明缩写

M.sort [1,2,3]     -- 指明模块名引入<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>在<code>ghci</code>中可以采用<code>:m 模块 [模块...]</code>的方式加载</p><pre class="line-numbers language-haskell" data-language="haskell"><code class="language-haskell">:m Data.List Data.Map Data.Set<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h4 id="data.list模块"><code>Data.List</code>模块</h4><blockquote><p>源码见: <span class="exturl" data-url="aHR0cHM6Ly9oYWNrYWdlLmhhc2tlbGwub3JnL3BhY2thZ2UvYmFzZS00LjE2LjAuMC9kb2NzL3NyYy9EYXRhLUxpc3QuaHRtbA==">List<i class="fa fa-external-link-alt"></i></span> <span class="exturl" data-url="aHR0cHM6Ly9oYWNrYWdlLmhhc2tlbGwub3JnL3BhY2thZ2UvYmFzZS00LjE2LjAuMC9kb2NzL3NyYy9EYXRhLU9sZExpc3QuaHRtbA==">OldList<i class="fa fa-external-link-alt"></i></span></p><p>两个模块关系:</p><pre class="line-numbers language-haskell" data-language="haskell"><code class="language-haskell">import Data.OldList hiding ( all, and, any, concat, concatMap, elem, find,
                             foldl, foldl1, foldl&#39;, foldr, foldr1, mapAccumL,
                             mapAccumR, maximum, maximumBy, minimum, minimumBy,
                             length, notElem, null, or, product, sum )<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre></blockquote><ul><li><p><code>intersperse</code>:</p><p>将元素置于 List 中每<strong>对</strong>元素的中间</p><pre class="line-numbers language-haskell" data-language="haskell"><code class="language-haskell">intersperse&#39; :: a -&gt; [a] -&gt; [a]
intersperse&#39; _ [] &#x3D; []
intersperse&#39; _ [x] &#x3D; [x]
intersperse&#39; e (x : xs) &#x3D; x : e : intersperse&#39; e xs

intersperse&#39;&#39; :: a -&gt; [a] -&gt; [a]
intersperse&#39;&#39; _ [] &#x3D; []
intersperse&#39;&#39; e arr &#x3D; init $ foldr (\x aac -&gt; x : e : aac) [] arr<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li><li><p><code>intercalate</code> 取两个 List 作参数. 它会将第一个 List 交叉插入第二个 List 中间，并返回一个 List.</p><pre class="line-numbers language-haskell" data-language="haskell"><code class="language-haskell">intercalate&#39; :: [a] -&gt; [[a]] -&gt; [a]
intercalate&#39; _ [] &#x3D; []
intercalate&#39; _ [x] &#x3D; x
intercalate&#39; item (x : xs) &#x3D; x ++ item ++ intercalate&#39; item xs

intercalate&#39;&#39; :: [a] -&gt; [[a]] -&gt; [a]
intercalate&#39;&#39; item xs &#x3D; take (length mid - length item) mid
  where
    mid &#x3D; foldl (\aac x -&gt; aac ++ x ++ item) [] xs<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li><li><p><code>transpose</code> 函数可以反转一组 List 的 List. 你若把一组 List 的 List 看作是个 2D 的矩阵，那 <code>transpose</code> 的操作就是将其列转为行</p><p>尝试实现一下</p><ul><li><p>最开始我想不到可以同时操作多数组同一位置的方法, 于是借助命令式编程的方法愚蠢实现🙃(使用List.Range实现循环)</p><p><pre class="line-numbers language-haskell" data-language="haskell"><code class="language-haskell">transpose :: [[a]] -&gt; [[a]]
transpose xss &#x3D; [heads cur xss | cur &lt;- [0 .. (max2D xss - 1)]]
  where
    max2D xss &#x3D; foldl max 0 (map length xss)
    heads cur xss&#39; &#x3D; flat (map (\xs -&gt; if length xs &lt;&#x3D; cur then [] else [xs !! cur]) xss&#39;)
      where
        flat [] &#x3D; []
        flat (x : xs) &#x3D; x ++ flat xs<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></p></li><li><p>后来想到</p><p>🤔如果这是C语言, 那么二维数组本质就是一维数组组合, 所以可以将第二行同一位置的元素移动到上一行同位置右边实现</p><p>但是在Haskell中没有指针这么底层的东西把线性结构分为二维数组, 但是我们可以手动分界</p><p>😎<code>transpose'</code>实现原理大概是</p><ol type="1"><li><p>将数组转为3D</p><p><pre class="line-numbers language-haskell" data-language="haskell"><code class="language-haskell">[
    [1,2,3],
    [4,5,6],
    [7,8,9]
]
--&gt;
[
    [[1],[2],[3]],
    [[4],[5],[6]],
    [[7],[8],[9]]
]<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></p></li><li><p>两两合并</p><p><pre class="line-numbers language-haskell" data-language="haskell"><code class="language-haskell">[
    [[1],[2],[3]],
    [[4],[5],[6]],
    [[7],[8],[9]]
]
--&gt;
[
    [[1,4],[2,5],[3,6]],
    [[7],[8],[9]]
]
--&gt;
[
    [[1,4,7],[2,5,8],[3,6,9]],
]<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></p></li><li><p><code>transpose'''</code>就是将不同长度数组都<code>repeat</code>到等长</p></li></ol><p>于是得到</p><p><pre class="line-numbers language-haskell" data-language="haskell"><code class="language-haskell">-- 普通款👇
----- 合并两行 [7,8,9]-&gt;[[1,4],[2,5],[3,6]]-&gt;[[1,4,7],[2,5,8],[3,6,9]] 
mergeRow :: [[a]] -&gt; [[a]] -&gt; [[a]]
mergeRow &#x3D; zipWith (++)

----- 将一个一维数组转化为二位 [1,2,3] -&gt; [[1],[2],[3]]
form2D :: [a] -&gt; [[a]]
form2D &#x3D; map (: [])

transpose&#39; :: [[a]] -&gt; [[a]]
transpose&#39; &#x3D; foldl1 mergeRow . stakedForm
  where
    stakedForm &#x3D; map form2D

-- 压行款👇😎
transpose&#39;&#39; :: [[a]] -&gt; [[a]]
transpose&#39;&#39; &#x3D; foldl1 (zipWith (++)) . map (map (: []))

-- 解决对不齐👇
transpose&#39;&#39;&#39; :: [[a]] -&gt; [[a]]
transpose&#39;&#39;&#39; &#x3D; foldl1 mergeRow&#39; . stakedForm
  where
    stakedForm &#x3D; map $ map (: [])
    mergeRow&#39; xs1 xs2 &#x3D; takeWhile (not . null) . zipWith (++) (infForm xs1) $ infForm xs2
      where
        infForm &#x3D; (++ repeat [])<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></p></li><li><p>😒但是不够函数化, 我们相当于告诉Haskell执行的方式就是把两个List连起来, 继续进行一下优化</p><p><pre class="line-numbers language-haskell" data-language="haskell"><code class="language-haskell">transpose&#39;&#39;&#39;&#39; :: [[a]] -&gt; [[a]]
transpose&#39;&#39;&#39;&#39; xs
  where
    zipWith&#39; _ [] yys &#x3D; yys
    zipWith&#39; _ xxs [] &#x3D; [[xx] | xx &lt;- xxs]
    zipWith&#39; f (xx : xxs) (yy : yys) &#x3D; f xx yy : zipWith&#39; f xxs yys
transpose&#39;&#39;&#39;&#39; [] &#x3D; []<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></p></li></ul></li><li><p><code>concat</code>将List连起来(去除一层嵌套)</p><pre class="line-numbers language-haskell" data-language="haskell"><code class="language-haskell">concat&#39; :: [[a]] -&gt; [a]
concat&#39; &#x3D; foldl1 (++)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre></li><li><p><code>concatMap</code>将List转换为二维List再<code>concat</code></p><pre class="line-numbers language-haskell" data-language="haskell"><code class="language-haskell">concatMap&#39; :: [a -&gt; [b]] -&gt; [a] -&gt; [b]
concatMap&#39; f &#x3D; concat . (map f)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre></li><li><p><code>and</code>取一组布尔值<code>List</code>作参数. 只有其中的值全为<code>True</code>的情况下才会返回<code>True</code>.</p><pre class="line-numbers language-haskell" data-language="haskell"><code class="language-haskell">and&#39; :: [Bool] -&gt; Bool
and&#39; &#x3D; foldl1 (&amp;&amp;)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre></li><li><p><code>or</code>一组布尔值<code>List</code>中若存在一个<code>True</code>它就返回<code>True</code></p><pre class="line-numbers language-haskell" data-language="haskell"><code class="language-haskell">or&#39; :: [Bool] -&gt; Bool
or&#39; &#x3D; foldl1 (||)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre></li><li><p><code>any</code>与<code>all</code></p><pre class="line-numbers language-haskell" data-language="haskell"><code class="language-haskell">any&#39; :: [a -&gt; Bool] -&gt; [a]
any&#39; f &#x3D; or . (map f)

all&#39; :: [a -&gt; Bool] -&gt; [a]
all&#39; f &#x3D; and . (map f)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre></li><li><p><code>iterate</code>: 取一个函数和一个值作参数. 它会用该值去调用该函数并用所得的结果再次调用该函数，产生一个无限的 List.</p><pre class="line-numbers language-haskell" data-language="haskell"><code class="language-haskell">iterate&#39; :: (a -&gt; a) -&gt; a -&gt; [a]
iterate&#39; f x &#x3D; x : iterate&#39; f (f x)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre></li><li><p><code>splitAt</code>取一个 List 和数值作参数，将该 List 在特定的位置断开。返回一个包含两个 List 的二元组.</p><pre class="line-numbers language-haskell" data-language="haskell"><code class="language-haskell">splitAt&#39; :: Int -&gt; [b] -&gt; ([b], [b])
splitAt&#39; n xs &#x3D; (lefts xs, rights)
  where
    len &#x3D; max 0 $ min (length xs) n
    lefts &#x3D; take len
    rights &#x3D; reverse . take (length xs - len) $ reverse xs<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>例如</p><pre class="line-numbers language-haskell" data-language="haskell"><code class="language-haskell">let (a,b) &#x3D; splitAt 3 &quot;foobar&quot; in b ++ a  
-- &quot;barfoo&quot;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre></li><li><p><code>takeWhile</code>从一个 List 中取元素，一旦遇到不符合条件的某元素就停止.</p><pre class="line-numbers language-haskell" data-language="haskell"><code class="language-haskell">takeWhile&#39; :: (a -&gt; Bool) -&gt; [a] -&gt; [a]
takeWhile&#39; f (x : xs)
  | f x &#x3D; x : takeWhile&#39; f xs
  | otherwise &#x3D; []
takeWhile&#39; _ [] &#x3D; []<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre></li><li><p><code>dropWhile</code>与<code>takeWhile</code>相似，不过是扔掉符合条件的元素。一旦限制条件返回 <code>False</code>，它就返回 List 的余下部分.</p><pre class="line-numbers language-haskell" data-language="haskell"><code class="language-haskell">dropWhile&#39; :: (a -&gt; Bool) -&gt; [a] -&gt; [a]
dropWhile&#39; f (x : xs)
  | f x &#x3D; dropWhile&#39; f xs
  | otherwise &#x3D; xs
dropWhile&#39; _ [] &#x3D; []<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre></li><li><p><code>span</code>与<code>break</code>返回首次失败/成功左右数据</p><pre class="line-numbers language-haskell" data-language="haskell"><code class="language-haskell">span&#39; :: (a -&gt; Bool) -&gt; [a] -&gt; ([a], [a])
span&#39; f xs &#x3D; (takeWhile f xs, dropWhile f xs)

break&#39; :: (a -&gt; Bool) -&gt; [a] -&gt; ([a], [a])
break&#39; f &#x3D; span (not . f)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre></li><li><p><code>sort</code>排序一个<code>List</code></p><pre class="line-numbers language-haskell" data-language="haskell"><code class="language-haskell">sort&#39; :: (Ord a)&#x3D;&gt;[a] -&gt; [a]
sort&#39; (tar:xs) &#x3D; lowers ++ [tar] ++ uppers
  where lowers &#x3D; sort&#39; [x|x&lt;-xs, x&lt;&#x3D;tar]
        uppers &#x3D; sort&#39; [x|x&lt;-xs, x&gt;tar]
sort&#39; [] &#x3D; []<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre></li><li><p><code>group</code>取一个 List 作参数，并将其中相邻并相等的元素各自归类，组成一个个子 List.</p><pre class="line-numbers language-haskell" data-language="haskell"><code class="language-haskell">group&#39; :: Eq a &#x3D;&gt; [a] -&gt; [[a]]
group&#39; (x : xs)
  | null res &#x3D; [[x]]
  | x &#x3D;&#x3D; head headx &#x3D; (x : headx) : tail res
  | otherwise &#x3D; [x] : res
  where
    res &#x3D; group&#39; xs
    headx &#x3D; head res
group&#39; [] &#x3D; []

-- 看下源码的实现模式

group&#39; :: Eq a &#x3D;&gt; [a] -&gt; [[a]]
group&#39; [] &#x3D; []
group&#39; (x : xs) &#x3D; (x : ys) : group&#39; zs
  where
    (ys, zs) &#x3D; span (&#x3D;&#x3D; x) xs<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>统计元素出现次数</p><pre class="line-numbers language-haskell" data-language="haskell"><code class="language-haskell">ghci&gt; map (\l@(x:xs) -&gt; (x,length l)) . group . sort $ [1,1,1,1,2,2,2,2,3,3,2,2,2,5,6,7]  
-- [(1,4),(2,7),(3,2),(5,1),(6,1),(7,1)]<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre></li><li><p><code>inits</code> 和 <code>tails</code> 与 <code>init</code> 和 <code>tail</code> 相似，只是它们会递归地调用自身直到什么都不剩</p><pre class="line-numbers language-haskell" data-language="haskell"><code class="language-haskell">inits&#39; :: [a] -&gt; [[a]]
inits&#39; xs &#x3D; scanr (\_ acc -&gt; init acc) xs xs

tails&#39; :: [a] -&gt; [[a]]
tails&#39; xs &#x3D; scanl (\acc _ -&gt; tail acc) xs xs<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre></li><li><p><code>isInfixOf</code>数组模式匹配</p><pre class="line-numbers language-haskell" data-language="haskell"><code class="language-haskell">import Data.List (tails)

isInfixOf&#39; :: Eq a &#x3D;&gt; [a] -&gt; [a] -&gt; Bool
isInfixOf&#39; needle haystack &#x3D; foldl (\acc x -&gt; acc || take len x &#x3D;&#x3D; needle) False $ tails haystack
  where
    len &#x3D; length needle<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li><li><p><code>isPrefixOf</code>与<code>isSuffixOf</code>分别检查一个 List 是否以某子 List 开头或者结尾.</p><pre class="line-numbers language-haskell" data-language="haskell"><code class="language-haskell">isPrefixOf&#39; :: (Eq a) &#x3D;&gt; [a] -&gt; [a] -&gt; Bool
isPrefixOf&#39; needle haystack &#x3D; needle &#x3D;&#x3D; take len haystack
  where
    len &#x3D; length needle

isSuffixOf&#39; :: (Eq a) &#x3D;&gt; [a] -&gt; [a] -&gt; Bool
isSuffixOf&#39; needle haystack &#x3D; reverse needle &#x3D;&#x3D; take len (reverse haystack)
  where
    len &#x3D; length needle<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li><li><p><code>elem</code>与<code>notElem</code>检查一个 List 是否包含某元素.</p><pre class="line-numbers language-haskell" data-language="haskell"><code class="language-haskell">elem&#39; :: Eq a &#x3D;&gt; a -&gt; [a] -&gt; Bool
elem&#39; v &#x3D; foldl (\acc x -&gt; acc || x &#x3D;&#x3D; v) False

notElem&#39; :: Eq a &#x3D;&gt; a -&gt; [a] -&gt; Bool
notElem&#39; v xs &#x3D; not (elem&#39; v xs)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre></li><li><p><code>partition</code> 取一个限制条件和 List 作参数，返回两个 List，第一个 List 中包含所有符合条件的元素，而第二个 List 中包含余下的.</p><pre class="line-numbers language-haskell" data-language="haskell"><code class="language-haskell">partition&#39; :: (a -&gt; Bool) -&gt; [a] -&gt; ([a], [a])
partition&#39; p &#x3D; foldr (select&#39; p) ([], [])

select&#39; :: (a -&gt; Bool) -&gt; a -&gt; ([a], [a]) -&gt; ([a], [a])
select&#39; p x (ts, fs)
  | p x &#x3D; (x : ts, fs)
  | otherwise &#x3D; (ts, x : fs)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><code>partition</code>与<code>span</code> 和 <code>break</code> 不同, <code>span</code> 和 <code>break</code> 会在遇到第一个符合或不符合条件的元素处断开，而 <code>partition</code> 则会遍历整个 List</p></li><li><p><code>find</code> 取一个 List 和限制条件作参数，并返回首个符合该条件的元素，而这个元素是个 <code>Maybe</code> 值，<code>Maybe</code> 值是 <code>Just something</code> 或 <code>Nothing</code>。与一个 List 可以为空也可以包含多个元素相似，一个 <code>Maybe</code> 可以为空，也可以是单一元素。同样与 List 类似，一个 Int 型的 List 可以写作 <code>[Int]</code>，<code>Maybe</code>有个 Int 型可以写作 <code>Maybe Int</code>。先试一下 <code>find</code> 函数再说.</p><pre class="line-numbers language-haskell" data-language="haskell"><code class="language-haskell">find (&gt;4) [1,2,3,4,5,6]  
-- Just 5  
find (&gt;9) [1,2,3,4,5,6]  
-- Nothing  
:t find  
-- find :: (a -&gt; Bool) -&gt; [a] -&gt; Maybe a<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li><li><p><code>elemIndex</code> 与 <code>elem</code> 相似，只是它返回的不是布尔值，它只是'可能' (Maybe)返回我们找的元素的索引，若这一元素不存在，就返回 <code>Nothing</code>。</p><pre class="line-numbers language-haskell" data-language="haskell"><code class="language-haskell">:t elemIndex  
elemIndex :: (Eq a) &#x3D;&gt; a -&gt; [a] -&gt; Maybe Int  
4 &#96;elemIndex&#96; [1,2,3,4,5,6]  
-- Just 3  
10 &#96;elemIndex&#96; [1,2,3,4,5,6]  
-- Nothing<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li><li><p><code>elemIndices</code>与 <code>elemIndex</code> 相似，只不过它返回的是所有满足条件的<code>List</code></p><pre class="line-numbers language-haskell" data-language="haskell"><code class="language-haskell">elemIndices&#39; :: (Eq a) &#x3D;&gt; a -&gt; [a] -&gt; [Integer]
elemIndices&#39; target xs &#x3D; [cur| (x, cur) &lt;- zip xs [0..], x &#x3D;&#x3D; target]<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre></li><li><p><code>findIndex</code>与<code>elemIndices</code>类似, 但之返回第一个满足条件的索引的Maybe</p></li><li><p><code>zip*</code>, <code>zipWith*</code>支持多数组<code>zip</code>(最大到<code>zip7</code>)</p><pre class="line-numbers language-haskell" data-language="haskell"><code class="language-haskell">zip4 [2,3,3] [2,2,2] [5,5,3] [2,2,2]  
-- [(2,2,5,2),(3,2,5,2),(3,2,3,2)]<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre></li><li><p><code>lines</code>根据换行符<code>split</code></p><pre class="line-numbers language-haskell" data-language="haskell"><code class="language-haskell">lines&#39; :: String -&gt; [String]
lines&#39; xs
  | null snds &#x3D; [fsts]
  | otherwise &#x3D; fsts : lines&#39; (tail snds)
  where
    (fsts, snds) &#x3D; span (&#x2F;&#x3D; &#39;\n&#39;) xs<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li><li><p><code>unlines</code>是 <code>lines</code> 的反函数，它取一组字串的 <code>List</code>，并将其通过 <code>'\n'</code>合并到一块.</p><pre class="line-numbers language-haskell" data-language="haskell"><code class="language-haskell">unlines&#39; :: [String] -&gt; String
unlines&#39; &#x3D; foldl (\acc x -&gt; acc ++ x ++ [&#39;\n&#39;]) &quot;&quot;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre></li><li><p><code>words</code>和<code>unwords</code>可以把一个字串分为一组单词或执行相反的操作</p><pre class="line-numbers language-haskell" data-language="haskell"><code class="language-haskell">words &quot;hey these are the words in this\nsentence&quot;  
-- [&quot;hey&quot;,&quot;these&quot;,&quot;are&quot;,&quot;the&quot;,&quot;words&quot;,&quot;in&quot;,&quot;this&quot;,&quot;sentence&quot;]  
unwords [&quot;hey&quot;,&quot;there&quot;,&quot;mate&quot;]  
-- &quot;hey there mate&quot;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>其中间隔符判断采用<code>Data.Char.isSpace</code></p><pre class="line-numbers language-haskell" data-language="haskell"><code class="language-haskell">isSpace c
  | uc &lt;&#x3D; 0x377 &#x3D; uc &#x3D;&#x3D; 32 || uc - 0x9 &lt;&#x3D; 4 || uc &#x3D;&#x3D; 0xa0
  | otherwise &#x3D; iswspace (ord c) &#x2F;&#x3D; 0
  where
    uc &#x3D; fromIntegral (ord c) :: Word<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>即全部Unicode空格与 <code>\t</code>, <code>\n</code>, <code>\r</code>, <code>\f</code>, <code>\v</code></p></li><li><p><code>delete</code>取一个元素和 List 作参数，会删掉该 List 中首次出现的这一元素.</p><pre class="line-numbers language-haskell" data-language="haskell"><code class="language-haskell">delete &#39;h&#39; &quot;hey there ghang!&quot;  
-- &quot;ey there ghang!&quot;  <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre></li><li><p><code>\</code>类似查集, 在插入时检查元素是否已经存在, ⚠但不去重左操作数, 不去重右操作数</p><pre class="line-numbers language-haskell" data-language="haskell"><code class="language-haskell">ghci&gt; [1,2,2,3] \\ [2,2,3,3,4]
-- [1]
ghci&gt; [1,2,2,3] \\ [2,3,3,4]
-- [1,2]<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre></li><li><p><code>union</code>类似并集, 在插入时检查元素是否已经存在, ⚠不去重左操作数</p><pre class="line-numbers language-haskell" data-language="haskell"><code class="language-haskell">[1,2,3,3] &#96;union&#96; [2,2,5,9]
-- [1,2,3,3,5,9]<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre></li><li><p><code>intersect</code>类似交集, 在插入时检查元素是否已经存在, ⚠不去重左操作数</p><pre class="line-numbers language-haskell" data-language="haskell"><code class="language-haskell">intersect [1,2,2,3] [2,2,2,3,3,4]
-- [2,2,3]<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre></li><li><p><code>insert</code>可以将一个元素插入一个<strong>可排序(而不是已排序)</strong>的<code>List</code>, 并将其置于首个大于等于它的元素之前，如果使用 <code>insert</code> 来给一个排过序的 List 插入元素，返回的结果依然是排序的.</p><pre class="line-numbers language-haskell" data-language="haskell"><code class="language-haskell">insert 4 [1,2,3,5,6,7]  
--[1,2,3,4,5,6,7]  
insert &#39;g&#39; $ [&#39;a&#39;..&#39;f&#39;] ++ [&#39;h&#39;..&#39;z&#39;]  
-- &quot;abcdefghijklmnopqrstuvwxyz&quot;  
insert 3 [1,2,4,3,2,1]  
-- [1,2,3,4,3,2,1]<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li><li><p><code>length</code>,<code>take</code>,<code>drop</code>,<code>splitAt</code>,<code>!!</code>,<code>replicate</code>都有一个<code>generic*</code>版本, 区别就是将类型参数中的<code>Int</code>替换为<code>Num</code>, 例如</p><pre class="line-numbers language-haskell" data-language="haskell"><code class="language-haskell">:t genericLength 
-- genericLength :: Num i &#x3D;&gt; [a] -&gt; i
:t length 
-- length :: Foldable t &#x3D;&gt; t a -&gt; Int<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre></li><li><p><code>nub</code>, <code>delete</code>, <code>union</code>, <code>intsect</code> , <code>group</code> 都有<code>*By</code>版本, 它们的区别就是前一组函数使用 <code>(==)</code> 来测试是否相等，而带 <code>By</code> 的那组则取一个函数作参数来判定相等性，<code>group</code> 就与 <code>groupBy (==)</code> 等价</p><p>例如将相邻且同号元素放一起</p><pre class="line-numbers language-haskell" data-language="haskell"><code class="language-haskell">let values &#x3D; [-4.3,-2.4,-1.2,0.4,2.3,5.9,10.5,29.1,5.3,-2.4,-14.5,2.9,2.3]  
groupBy (\x y -&gt; (x &gt; 0) &#x3D;&#x3D; (y &gt; 0)) values  
-- [[-4.3,-2.4,-1.2],[0.4,2.3,5.9,10.5,29.1,5.3],[-2.4,-14.5],[2.9,2.3]]<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre></li><li><p><code>on</code>函数</p><pre class="line-numbers language-haskell" data-language="haskell"><code class="language-haskell">on :: (b -&gt; b -&gt; c) -&gt; (a -&gt; b) -&gt; a -&gt; a -&gt; c  
f &#96;on&#96; g &#x3D; \x y -&gt; f (g x) (g y)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>例如上面功能可以些为</p><pre class="line-numbers language-haskell" data-language="haskell"><code class="language-haskell">groupBy ((&#x3D;&#x3D;) &#96;on&#96; (&gt; 0)) values  
-- [[-4.3,-2.4,-1.2],[0.4,2.3,5.9,10.5,29.1,5.3],[-2.4,-14.5],[2.9,2.3]]<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre></li><li><p><code>sort</code>，<code>insert</code>，<code>maximum</code>, <code>min</code>都有<code>*By</code>, 判别函数返回<code>Ordering</code>类型(<code>LT</code>,<code>EQ</code>,<code>GT</code>)</p><p>例如按照<code>List</code>长度将二维<code>List</code>排序</p><pre class="line-numbers language-haskell" data-language="haskell"><code class="language-haskell">xs &#x3D; [[5,4,5,4,4],[1,2,3],[3,5,4,3],[],[2],[2,2]]  
sortBy (compare &#96;on&#96; length) xs  
-- [[],[2],[2,2],[1,2,3],[3,5,4,3],[5,4,5,4,4]]<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre></li></ul><h4 id="data.char模块"><code>Data.Char</code>模块</h4><ul><li><p>范围判断函数</p><ul><li><code>isControl</code>: 是否是控制字</li><li><code>isSpace</code>: 是否是空格</li><li><code>isUper</code>: 是否为大写</li><li><code>isAlpha</code>: 是否为字母</li><li><code>isAlphaNum</code>: 是否为字母或数字</li><li><code>isPrint</code>: 是否是可打印的</li><li><code>isDigit</code>: 是否为数字.</li><li><code>isOctDigit</code>: 是否为八进制数字</li><li><code>isHexDigit</code>: 是否为十六进制数字</li><li><code>isLetter</code>: 是否为字母</li><li><code>isMark</code>: 是否为<code>unicode</code>注音字符(如: <code>é</code>).</li><li><code>isNumber</code>: 是否为数字</li><li><code>isPunctuation</code>:是否为标点符号</li><li><code>isSymbol</code>: 是否为货币符号</li><li><code>isSeperater</code>: 是否为<code>unicode</code>空格或分隔符.</li><li><code>isAscii</code>: 是否在<code>unicode</code>字母表的前 128 位</li><li><code>isLatin1</code>: 是否在<code>unicode</code>字母表的前 256 位.</li><li><code>isAsciiUpper</code>: 是否为大写的 ascii 字符</li><li><code>isAsciiLower</code>: 是否为小写的 ascii 字符</li></ul><p>实现<code>words</code>函数</p><pre class="line-numbers language-haskell" data-language="haskell"><code class="language-haskell">words xs&#x3D; filter (not . any isSpace) . groupBy ((&#x3D;&#x3D;) &#96;on&#96; isSpace) $ xs<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><ul><li><p><code>generalCategory</code>获取字符属于哪个分类, 函数类型为<code>generalCategory :: Char -&gt; GeneralCategory</code>, 这里的<code>GeneralCategory</code>与<code>Ordering</code>类似, 为枚举类型</p><pre class="line-numbers language-haskell" data-language="haskell"><code class="language-haskell">ghci&gt; generalCategory &#39; &#39;  
Space  
ghci&gt; generalCategory &#39;A&#39;  
UppercaseLetter  
ghci&gt; generalCategory &#39;a&#39;  
LowercaseLetter  
ghci&gt; generalCategory &#39;.&#39;  
OtherPunctuation  
ghci&gt; generalCategory &#39;9&#39;  
DecimalNumber  
ghci&gt; map generalCategory &quot; \t\nA9?|&quot;  
[Space,Control,Control,UppercaseLetter,DecimalNumber,OtherPunctuation,MathSymbol]<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li></ul></li><li><p>转换函数</p><ul><li><code>toUpper</code>: 将一个字符转为大写字母</li><li><code>toLower</code>: 将一个字符转为小写字母</li><li><code>toTitle</code>: 将一个字符转为<code>title-case</code>，对大多数字元而言，<code>title-case</code> 就是大写.</li><li><code>digitToInt</code>: 将一个<strong>字符(不支持字符串)</strong>转为<code>Int</code>值，而这一字符必须得在<code>'1'..'9','a'..'f'</code>或<code>'A'..'F'</code> 的范围之内(相当于转换为16进制, 但因为是给字符转换, 所以没什么问题)</li><li><code>intToDigit</code>是<code>digitToInt</code>的反函数, 取一个 <code>0</code> 到 <code>15</code> 的 <code>Int</code> 值作参数，并返回一个小写的字符.</li><li><code>ord</code>与<code>char</code> 函数可以将字符与其对应的数字相互转换.</li></ul></li></ul><h4 id="data.map模块"><code>Data.Map</code>模块</h4><p>通过树实现的Map. 由于Map中函数与其他函数冲突较多, 最好采用<code>qualified import</code></p><ul><li><p><code>fromList</code>: <code>List</code>转<code>Map</code>, List为K-V二元组, Key相同会覆盖</p><pre class="line-numbers language-haskell" data-language="haskell"><code class="language-haskell">Map.fromList :: (Ord k) &#x3D;&gt; [(k,v)] -&gt; Map.Map k v

Map.fromList [(&quot;betty&quot;,&quot;555-2938&quot;),(&quot;bonnie&quot;,&quot;452-2928&quot;),(&quot;lucille&quot;,&quot;205-2928&quot;),(&quot;lucille&quot;,&quot;205-000&quot;)] 
-- fromList [(&quot;betty&quot;,&quot;555-2938&quot;),(&quot;bonnie&quot;,&quot;452-2928&quot;),(&quot;lucille&quot;,&quot;205-000&quot;)] <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre></li><li><p><code>fromListWith</code>用来解决重复K的问题</p><pre class="line-numbers language-haskell" data-language="haskell"><code class="language-haskell">import qualified Data.Map as M

res &#x3D; M.fromListWith (\v1 v2 -&gt; v1 ++ &quot;, &quot; ++ v2) [(&quot;betty&quot;, &quot;555-2938&quot;), (&quot;bonnie&quot;, &quot;452-2928&quot;), (&quot;lucille&quot;, &quot;205-2928&quot;), (&quot;lucille&quot;, &quot;205-000&quot;)]

-- fromList [(&quot;betty&quot;,&quot;555-2938&quot;),(&quot;bonnie&quot;,&quot;452-2928&quot;),(&quot;lucille&quot;,&quot;205-000, 205-2928&quot;)]<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre></li><li><p><code>empty</code>返回空<code>Map</code></p><pre class="line-numbers language-haskell" data-language="haskell"><code class="language-haskell">empty
-- fromList []<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre></li><li><p><code>insert K V</code>插入</p><pre class="line-numbers language-haskell" data-language="haskell"><code class="language-haskell">Map.insert 3 100 Map.empty
-- fromList [(3,100)] 
Map.insert 5 600 (Map.insert 4 200 ( Map.insert 3 100  Map.empty)) 
-- fromList [(3,100),(4,200),(5,600)]<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre></li><li><p><code>insertWith</code>用于处理重复K</p><pre class="line-numbers language-haskell" data-language="haskell"><code class="language-haskell">import qualified Data.Map as M
res &#x3D; M.insertWith (+) 3 100 $ M.fromList [(3, 4), (5, 103), (6, 339)]

-- fromList [(3,104),(5,103),(6,339)]<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre></li><li><p><code>null</code>判空Map</p><pre class="line-numbers language-haskell" data-language="haskell"><code class="language-haskell">Data.Map.null empty
-- True<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre></li><li><p><code>size</code>返回Map大小</p><pre class="line-numbers language-haskell" data-language="haskell"><code class="language-haskell">Data.Map.size $ Data.Map.fromList [(2,4),(3,3),(4,2),(5,4),(6,4)] 
-- 5<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre></li><li><p><code>singleton K V</code>返回一个K-V的Map</p><pre class="line-numbers language-haskell" data-language="haskell"><code class="language-haskell">Map.singleton 3 9 
-- fromList [(3,9)] <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre></li><li><p><code>lookup K</code>返回<code>Maybe V</code>/<code>Nothing</code></p><pre class="line-numbers language-haskell" data-language="haskell"><code class="language-haskell">import qualified Data.Map as M
t &#x3D; M.fromList [(&quot;betty&quot;, &quot;555-2938&quot;), (&quot;bonnie&quot;, &quot;452-2928&quot;), (&quot;lucille&quot;, &quot;205-2928&quot;), (&quot;lucille&quot;, &quot;205-000&quot;)]
res &#x3D; M.lookup &quot;bonnie&quot; t
-- Just &quot;452-2928&quot;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre></li><li><p><code>member K map</code>判断Ke y是否存在</p><pre class="line-numbers language-haskell" data-language="haskell"><code class="language-haskell">import qualified Data.Map as M

t &#x3D; M.fromList [(&quot;betty&quot;, &quot;555-2938&quot;), (&quot;bonnie&quot;, &quot;452-2928&quot;), (&quot;lucille&quot;, &quot;205-2928&quot;), (&quot;lucille&quot;, &quot;205-000&quot;)]

res &#x3D; M.member &quot;bonnie&quot; t<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre></li><li><p><code>map</code>, <code>filter</code>同<code>List</code></p></li><li><p><code>toList</code> 是 <code>fromList</code> 的反函数。</p><pre class="line-numbers language-haskell" data-language="haskell"><code class="language-haskell">Map.toList . Map.insert 9 2 $ Map.singleton 4 3 
-- [(4,3),(9,2)]<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre></li><li><p><code>keys</code>/<code>elems</code>返回<code>K/V</code>组成的<code>List</code></p><pre class="line-numbers language-haskell" data-language="haskell"><code class="language-haskell">import qualified Data.Map as M

t &#x3D; M.fromList [(&quot;betty&quot;, &quot;555-2938&quot;), (&quot;bonnie&quot;, &quot;452-2928&quot;), (&quot;lucille&quot;, &quot;205-2928&quot;), (&quot;lucille&quot;, &quot;205-000&quot;)]

res &#x3D; M.elems t
-- [&quot;555-2938&quot;,&quot;452-2928&quot;,&quot;205-000&quot;]
res&#39; &#x3D; M.keys t
-- [&quot;betty&quot;,&quot;bonnie&quot;,&quot;lucille&quot;]<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li></ul><h4 id="data.set-模块"><code>Data.Set</code> 模块</h4><p>使用树实现的集合, 建议使用<code>qualified import</code>引入</p><ul><li><p><code>fromList</code>, <code>List</code>转<code>Set</code></p><pre class="line-numbers language-haskell" data-language="haskell"><code class="language-haskell">import qualified Data.Set as S

a &#x3D; S.fromList [1,2,3,4,3,2,1]
-- fromList [1,2,3,4]<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre></li><li><p><code>intersection</code>交集, <code>difference</code>差集</p><pre class="line-numbers language-haskell" data-language="haskell"><code class="language-haskell">import qualified Data.Set as S

a &#x3D; S.fromList [1, 2, 3, 4, 3, 2, 1]
b &#x3D; S.fromList [1, 2, 2, 1]

S.intersection a b
-- fromList [1,2]

S.difference a b
-- fromList [3,4]

S.union a b
-- fromList [1,2,3,4]<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li><li><p><code>null</code>, <code>size</code>, <code>member</code>, <code>empty</code>, <code>singleton</code>, <code>insert</code>, <code>delete</code>与List类似</p></li><li><p><code>isSubsetOf</code>, <code>isProperSubsetOf</code>判断是不是子集与真子集</p><pre class="line-numbers language-haskell" data-language="haskell"><code class="language-haskell">import qualified Data.Set as S

a &#x3D; S.fromList [1, 2, 3, 4, 3, 2, 1]
b &#x3D; S.fromList [1, 2, 2, 1]
c &#x3D; S.fromList [1, 2]

b &#96;S.isSubsetOf&#96; a
-- True

c &#96;S.isProperSubsetOf&#96; b
-- False<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li><li><p>支持<code>Map</code>, <code>Filter</code></p><pre class="line-numbers language-haskell" data-language="haskell"><code class="language-haskell">import qualified Data.Set as S

S.filter odd $ S.fromList [3, 4, 5, 6, 7, 2, 3, 4]
-- fromList [3,5,7]
S.map (+ 1) $ S.fromList [3, 4, 5, 6, 7, 2, 3, 4]
-- fromList [3,4,5,6,7,8]<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li><li><p>通常使用<code>Set</code>完成<code>List</code>的去重操作, 其速度优于<code>List.nub</code></p><pre class="line-numbers language-haskell" data-language="haskell"><code class="language-haskell">setNub xs &#x3D; Set.toList $ Set.fromList xs  <span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>唯一的缺点是会丢失顺序</p></li></ul><h4 id="声明模块">声明模块</h4><ul><li><p>声明单模块</p><ul><li><p>创建文件, 文件名为<code>模块名.hs</code>, 模块名需开头大写</p></li><li><p>文件首部写出模块名与需要导出的方法, 例如<code>Demo.hs</code></p><pre class="line-numbers language-haskell" data-language="haskell"><code class="language-haskell">module Demo
  ( demo1,
    demo2,
  )
where

demo1 :: Integer -&gt; Integer
demo1 &#x3D; demo3 . (1 +)

demo2 :: Integer -&gt; Integer
demo2 &#x3D; demo3 . (1 -)

-- demo3仅作为内部调用使用, 无需导出, 可以不在module中写
demo3 :: Integer -&gt; Integer
demo3 &#x3D; (* 2)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li><li><p>将模块放在同级目录, 例如</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">.
├── Demo.hs
└── test.hs<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>就可以在<code>test.hs</code>中调用</p><pre class="line-numbers language-haskell" data-language="haskell"><code class="language-haskell">import Demo

res :: Integer
res &#x3D; demo1 1
-- 4<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre></li></ul></li><li><p>也可以分层设计模块, 只需要将其放入子文件中并使用<code>.</code>引入</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">.
├── Demos
│   ├── DemoA.hs
│   └── DemoB.hs
└── test.hs<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>其中</p><ul><li><p><code>DemoA.hs</code></p><pre class="line-numbers language-haskell" data-language="haskell"><code class="language-haskell">module Demos.DemoA
  ( demo1,
    demo2,
  )
where

demo1 :: Integer -&gt; Integer
demo1 &#x3D; demo3 . (1 +)

demo2 :: Integer -&gt; Integer
demo2 &#x3D; demo3 . (1 -)

demo3 :: Integer -&gt; Integer
demo3 &#x3D; (* 2)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li><li><p><code>DemoB.hs</code></p><pre class="line-numbers language-haskell" data-language="haskell"><code class="language-haskell">module Demos.DemoB
  ( demo1,
    demo2,
  )
where

demo1 :: Integer -&gt; Integer
demo1 &#x3D; demo3 . (2 +)

demo2 :: Integer -&gt; Integer
demo2 &#x3D; demo3 . (2 -)

demo3 :: Integer -&gt; Integer
demo3 &#x3D; (* 4)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li><li><p><code>test.hs</code></p><pre class="line-numbers language-haskell" data-language="haskell"><code class="language-haskell">import qualified Demos.DemoA as A
import qualified Demos.DemoB as B

a &#x3D; A.demo1 1
-- 4
b &#x3D; B.demo1 1
-- 12<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li></ul></li></ul><h3 id="声明类型与类型类">声明类型与类型类</h3><h4 id="代数数据类型">代数数据类型</h4><p>代数数据类型: 由值的一些集合, 以及这些集合之间的一些函数构成的类型. 这些函数都是一阶函数, 不能以其他函数作为参数.</p><ul><li><p>例如<code>Bool</code>类型的定义</p><p><pre class="line-numbers language-haskell" data-language="haskell"><code class="language-haskell">data Bool &#x3D; False | True<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></p><ul><li><p><code>data</code>关键字用于声明新类别</p></li><li><p><code>=</code>右边是<strong>值构造子</strong>, 包含了这个类型的所有可能值(即<code>True</code>, <code>False</code>, 用<code>|</code>分开)</p></li><li><p>什么是值构造子呢? 听起来很像命令式编程中的构造函数🤔. 不妨执行<code>:t False</code>. 得到<code>False :: Bool</code>, 我们可以这样想: <code>False</code>是一个函数, 这个函数是一个常函数, 不接受任何参数, 返回一个<code>Bool</code>类型的数据</p><p><strong>值构造子的本质是个函数，可以返回一个型别的值</strong></p></li></ul></li><li><p>例如定义一个支持圆形或正方形的<code>Shape</code>类型.</p><ul><li><p>首先我们知道这个类型的取值应该是圆/正方形:</p><p><pre class="line-numbers language-haskell" data-language="haskell"><code class="language-haskell">data Shape &#x3D; Circle | Rectangle<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></p></li><li><p>有点反直觉, 这里的<code>Circle</code>与<code>Rectangle</code>是什么?</p><p>是值构造子, 也就是说他们就是一个一个独立的<strong>值</strong>, 这里的<code>Circle</code>和之前的<code>False</code>是一个东西</p></li><li><p>如何表示一个<code>Circle</code>呢, 可以使用三个参数(项)表示<code>x, y, r</code>. 可以将参数类型附在值构造子后表示这个构造子的类型. 同理可以用<code>x1, y1, x2, y2</code>表示长方形</p><p><pre class="line-numbers language-haskell" data-language="haskell"><code class="language-haskell">data Shape &#x3D; Circle Float Float Float | Rectangle Float Float Float Float<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></p></li><li><p>尝试检查<code>Circle</code>类型:</p><p><pre class="line-numbers language-haskell" data-language="haskell"><code class="language-haskell">Circle :: Float -&gt; Float -&gt; Float -&gt; Shape<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></p><p>是一个函数, 接受三个<code>Float</code>, 返回一个<code>Shape</code>. 看起来与命令式编程相差甚远🤔, 我们并没有<strong>实现值构造字</strong>, 没有描述我们是如何将三个<code>Float</code>类型的变量表示为一个<code>Shape</code>类型的圆的. 别忘了Haskell的函数是纯函数😆. 使用相同的三个参数就可以获取同一个圆. 可以这样理解: <code>Circle 1 1 1</code>就代表一个圆, 他的类型就是<code>Shape</code>,</p></li></ul></li></ul><p><strong>不要将值构造子与类混淆, 一个很好的方法是记住例子: <code>Bool</code>是类型, <code>True</code>是值构造子</strong>, 在函数声明类型的应该使用类型而不是值构造子. 例如: 实现获取圆面积的函数</p><pre class="line-numbers language-haskell" data-language="haskell"><code class="language-haskell">data Shape &#x3D; Circle Float Float Float | Rectangle Float Float Float Float

getCiecleSize :: Shape -&gt; Float       -- 👍
getCiecleSize :: Circle -&gt; Float      -- 👎<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>千万不要把值构造子用作类型声明, 这就和你将<code>True</code>用作类型声明一样愚蠢</p><pre class="line-numbers language-haskell" data-language="haskell"><code class="language-haskell">tellMessage :: Bool -&gt; String      -- 👍
tellMessage :: True -&gt; String      -- 👎
tellMessage True &#x3D; &quot;Wow, it is true&quot;
tellMessage False &#x3D; &quot;Opps, it is false&quot;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>问题来了, 我们只想计算<code>Circle</code>的面积, 但是我们在函数声明的时候只要求参数是<code>Shape</code>, 没法过滤<code>Rectangle</code>啊🤯! 好好想想, 如果我们只是想实现输入<code>True</code>返回字符串, 输入<code>Fasle</code>不管, 应该如何实现呢? 模式匹配</p><pre class="line-numbers language-haskell" data-language="haskell"><code class="language-haskell">tellMessage :: Bool -&gt; String
tellMessage True &#x3D; &quot;Wow, it is true&quot;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>一样样的, 不过<code>Circle</code>构造子有参数, 我们要一并匹配</p><pre class="line-numbers language-haskell" data-language="haskell"><code class="language-haskell">getCiecleSize :: Shape -&gt; Float
getCiecleSize (Circle _ _ r) &#x3D; pi * r ^ 2<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>再实现一个获取<code>Shape</code>面积的方法</p><pre class="line-numbers language-haskell" data-language="haskell"><code class="language-haskell">surface :: Shape -&gt; Float
surface (Circle _ _ r) &#x3D; pi * r ^ 2
surface (Rectangle x1 y1 x2 y2) &#x3D; (abs $ x2 - x1) * (abs $ y2 - y1)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>😆最后优化一下, 定义一个<code>Point</code>类</p><pre class="line-numbers language-haskell" data-language="haskell"><code class="language-haskell">data Point &#x3D; Point Float Float
data Shape &#x3D; Circle Point Float | Rectangle Point Point

surface :: Shape -&gt; Float
surface (Circle _ r) &#x3D; pi * r ^ 2
surface (Rectangle (Point x1 y1) (Point x2 y2)) &#x3D; (abs $ x2 - x1) * (abs $ y2 - y1)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>值得注意的是类型<code>Point</code>与值构造子<code>Point</code>重名了. 没啥稀奇的,</p><ul><li>前面的<code>Point</code>是类型, 用于类型声明, 类似于<code>Bool</code></li><li>后面的<code>Point</code>是值构造子, 用于表示值, 类似于<code>True</code></li></ul><p>🧰我们还可以将<code>Shape</code>的定义与方法打包成模块</p><pre class="line-numbers language-haskell" data-language="haskell"><code class="language-haskell">module Shapes
( Point(..)
, Shape(..)
, surface
) where<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>类型后的<code>(..)</code>表示导出类型的全部值构造子. 这样导入者就可以直接定义类型了. 如果我们不希望导入者直接构造实例, 我们可以声明像<code>Map.fromList</code>的函数构造类型</p><h4 id="record-syntax">Record Syntax</h4><p>🏷︎Haskell提供了<code>record syntax</code>, 可以在定义类型的同时, 为每个字段指定读取器. 就像命令式编程一样, 我们可以为每项赋予标识, 例如定义<code>Person</code>类型时, 我们可以写下</p><pre class="line-numbers language-haskell" data-language="haskell"><code class="language-haskell">data Person &#x3D; Person &#123; firstName :: String
                     , lastName :: String
                     , age :: Int
                     , height :: Float
                     , phoneNumber :: String
                     , flavor :: String
                     &#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>这样就为<code>Person</code>值构造子参数赋予了标签</p><p>与直接使用<code>Person :: Person String String...</code>声明不同的是<strong><code>Haskell</code>为每一个参数绑定的标识符绑定了一个函数</strong>, 例如</p><pre class="line-numbers language-haskell" data-language="haskell"><code class="language-haskell">ghci&gt; :t flavor
flavor :: Person -&gt; String<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>这个函数取<code>Person</code>类型值, 返回这个值中该元素所在位值</p><pre class="line-numbers language-haskell" data-language="haskell"><code class="language-haskell">data Person &#x3D; Person
  &#123; firstName :: String,
    lastName :: String,
    age :: Int,
    height :: Float,
    phoneNumber :: String,
    flavor :: String
  &#125;

per &#x3D; Person &quot;Kairui&quot; &quot;Liu&quot; 12 123 &quot;13456789022&quot; &quot;i do not know&quot;

flavor per   -- &quot;i do not know&quot;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>等价于</p><pre class="line-numbers language-haskell" data-language="haskell"><code class="language-haskell">flavor&#39; :: Person -&gt; String
flavor&#39; (Person _ _ _ _ _ f) &#x3D; f<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><h4 id="类型参数">类型参数</h4><p>类似于命令式编程中的"模板", 可以在声明类型的时候加入类型变量参数, 例如<code>Maybe</code>类型</p><pre class="line-numbers language-haskell" data-language="haskell"><code class="language-haskell">data Maybe a &#x3D; Nothing | Just a<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>接受一个类型参数并在<code>Just</code>中使用, 在调用<code>Just X</code>的时候, Haskell会自动判断类型并返回</p><p>甚至可以在类型定义时限定类型变量类型(<strong>但是强烈不建议</strong>), 因为在函数类型定义时我们还是需要声明类型的类型类</p><pre class="line-numbers language-haskell" data-language="haskell"><code class="language-haskell">data (Ord k) &#x3D;&gt; Map k v &#x3D; ...<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>实现一个矢量加法</p><pre class="line-numbers language-haskell" data-language="haskell"><code class="language-haskell">data Vector a &#x3D; Vector a a a deriving (Show)

plusV :: (Num a) &#x3D;&gt; Vector a -&gt; Vector a -&gt; Vector a
plusV (Vector x1 y1 z1) (Vector x2 y2 z2) &#x3D; Vector (x1 + x2) (y1 + y2) (z1 + z2)

plusV (Vector 1 2 3) (Vector 1 2 3)
-- Vector 2 4 6<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="递归定义类型">递归定义类型</h4><p>定义值构造子的时候使用本身的类型就构成了数据类型递归定义.</p><ul><li><p>定义一个<code>List</code>. 一个<code>List</code>要么是空的<code>[]</code>, 要么是<code>elem:List</code></p><p><pre class="line-numbers language-haskell" data-language="haskell"><code class="language-haskell">data List a &#x3D; Empty | Cons a (List a) <span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></p><p>其中<code>Cons</code>就是<code>:</code></p><p><pre class="line-numbers language-haskell" data-language="haskell"><code class="language-haskell">ghci&gt; :t (:)
(:) :: a -&gt; [a] -&gt; [a]<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre></p><p>也就是: <code>List</code>有两个值, 要么是<code>Empty</code>值构造子要么是<code>Cons</code>值构造子. 其中<code>Cons</code>值构造子有两个参数, <code>a</code>与<code>List a</code></p><p>同样也可以使用<code>Record Syntax</code>定义<code>List</code></p><p><pre class="line-numbers language-haskell" data-language="haskell"><code class="language-haskell">data List a &#x3D; Empty | Cons &#123; listHead :: a, listTail :: List a&#125; <span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></p><p>例如<code>[1,2,3]</code>相当于<code>1:2:3:[]</code></p><p><pre class="line-numbers language-haskell" data-language="haskell"><code class="language-haskell">Cons 1 $ Cons 2 $ Cons 3 Empty<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></p><p>定义<code>++</code></p><p><pre class="line-numbers language-haskell" data-language="haskell"><code class="language-haskell">infixr 5  ++
(++) :: [a] -&gt; [a] -&gt; [a]
[]     ++ ys &#x3D; ys
(x:xs) ++ ys &#x3D; x : (xs ++ ys)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre></p></li><li><p>定义搜索二叉树(先不管<code>deriving...</code>)</p><p><pre class="line-numbers language-haskell" data-language="haskell"><code class="language-haskell">data BST a &#x3D; EmptyTree | Node a (BST a) (BST a) deriving (Show, Eq)

-- 获取单元素
getOne :: a -&gt; BST a
getOne a &#x3D; Node a EmptyTree EmptyTree

insertNode :: (Ord a, Eq a) &#x3D;&gt; a -&gt; BST a -&gt; BST a
insertNode x EmptyTree &#x3D; getOne x
insertNode x (Node a lt rt)
  | x &lt; a &#x3D; Node a (insertNode x lt) rt
  | x &gt; a &#x3D; Node a lt (insertNode x rt)
  | x &#x3D;&#x3D; a &#x3D; Node a lt rt

elemNode :: (Ord a, Eq a) &#x3D;&gt; a -&gt; BST a -&gt; Bool
elemNode x EmptyTree &#x3D; False
elemNode x (Node a lt rt)
  | x &#x3D;&#x3D; a &#x3D; True
  | x &lt; a &#x3D; elemNode x lt
  | x &gt; a &#x3D; elemNode x rt

t1 :: BST Integer
t1 &#x3D; insertNode 10 . insertNode 5 $ getOne 7
-- Node 7 (Node 5 EmptyTree EmptyTree) (Node 10 EmptyTree EmptyTree)

t2 :: Bool
t2 &#x3D; elemNode 3 t1
-- False

t3 :: Bool
t3 &#x3D; elemNode 10 t1
-- True<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></p></li></ul><h4 id="类型别名">类型别名</h4><p>👻与命令式编程中类型别名类似.</p><ul><li><p>看看<code>String</code>语法糖是如何定义的</p><p><pre class="line-numbers language-haskell" data-language="haskell"><code class="language-haskell">type String &#x3D; [Char]<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></p><p>就是将类型映射到另一个类型组</p></li><li><p>定义一个电话簿</p><p><pre class="line-numbers language-haskell" data-language="haskell"><code class="language-haskell">-- 正常款
phoneBook :: [(String,String)]
phoneBook &#x3D;
    [(&quot;betty&quot;,&quot;555-2938&quot;)
    ,(&quot;penny&quot;,&quot;853-2492&quot;)
    ]
    
-- 别名款
type PhoneBook &#x3D; [(String,String)]

-- Record Syntax 别名款
type PhoneNumber &#x3D; String
type Name &#x3D; String
type PhoneBook &#x3D; [(Name,PhoneNumber)]<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></p></li></ul><h4 id="派生">派生</h4><p>类似命令式编程的接口与派生, 在Haskell中当类型可以通过派生的方式归属于一个类型类</p><p><strong>我们只讨论如何声明类型为预定于<code>Type Classes</code></strong>, 不过等自己会定义<code>Type Class</code>时自然也就会派生了</p><p>类型是可以属于一个类型类的(例如<code>Bool</code>是一个<code>Eq</code>类型类的), 我们也可以声明自己的类型属于某个类型类. 例如</p><ul><li><p>定义<code>Shape</code>派生自<code>Show</code>(使其可以被打印)</p><pre class="line-numbers language-haskell" data-language="haskell"><code class="language-haskell">data Shape &#x3D; Circle Float Float Float | Rectangle Float Float Float Float deriving (Show)<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>只需使用<code>deriving (Show)</code>即可声明类型派生自<code>Show</code>. 之后就可以在<code>ghci</code>中打印<code>Shape</code>了</p><p>🎁同时, 若类似是通过<code>Record Syntax</code>定义的 , <code>show</code>到处的形式会略有不同</p><pre class="line-numbers language-haskell" data-language="haskell"><code class="language-haskell">data Shape &#x3D; Circle Float Float Float | Rectangle Float Float Float Float deriving (Show)

data Shape&#39; &#x3D; Circle&#39; &#123;x :: Float, y :: Float, r :: Float&#125; | Rectangle&#39; &#123;x1 :: Float, y1 :: Float, x2 :: Float, y2 :: Float&#125; deriving (Show)

t &#x3D; show (Circle 1 2 3)
-- &quot;Circle 1.0 2.0 3.0&quot;
t&#39; &#x3D; show (Circle&#39; 1 2 3)
-- &quot;Circle&#39; &#123;x &#x3D; 1.0, y &#x3D; 2.0, r &#x3D; 3.0&#125;&quot;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>🤔有点小问题, 从头到尾我们都没有实现<code>Show</code>类型类中的一个函数啊. 怎么就打印出来了呢?</p><p>这是因为<code>Show</code>类型类中存在默认实现, 我们也可以手动重写</p><pre class="line-numbers language-haskell" data-language="haskell"><code class="language-haskell">data Shape &#x3D; Circle Float Float Float | Rectangle Float Float Float Float    -- 注意没有&quot;deriving&quot;

-- 实现接口
instance Show Shape where
  show (Circle x y r) &#x3D; &quot;Look! it is a circle, with origin (&quot; ++ show x ++ &quot;, &quot; ++ show y ++ &quot;), and r &#x3D; &quot; ++ show r
  show (Rectangle x1 y1 x2 y2) &#x3D; &quot;Look! it is a rectangle, from (&quot; ++ show x1 ++ &quot;, &quot; ++ show y1 ++ &quot;), to (&quot; ++ show x2 ++ &quot;, &quot; ++ show y2 ++ &quot;)&quot;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-haskell" data-language="haskell"><code class="language-haskell">ghci&gt; show (Circle 1 2 3)
&quot;Look! it is a circle, with origin (1.0, 2.0), and r &#x3D; 3.0&quot;
ghci&gt; show (Rectangle  1 2 3 4)
&quot;Look! it is a rectangle, from (1.0, 2.0), to (3.0, 4.0)&quot;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre></li><li><p>定义<code>Shape</code>派生自<code>Eq</code></p><p>默认<code>Eq</code>实现为: 分别比较每一个元素是否相等</p><pre class="line-numbers language-haskell" data-language="haskell"><code class="language-haskell">data Person &#x3D; Person &#123; firstName :: String
                     , lastName :: String
                     , age :: Int
                     &#125; deriving (Eq)

mikeD &#x3D; Person &#123;firstName &#x3D; &quot;Michael&quot;, lastName &#x3D; &quot;Diamond&quot;, age &#x3D; 43&#125;
adRock &#x3D; Person &#123;firstName &#x3D; &quot;Adam&quot;, lastName &#x3D; &quot;Horovitz&quot;, age &#x3D; 41&#125;
mca &#x3D; Person &#123;firstName &#x3D; &quot;Adam&quot;, lastName &#x3D; &quot;Yauch&quot;, age &#x3D; 44&#125;
mca &#x3D;&#x3D; adRock         -- False
mikeD &#x3D;&#x3D; adRock       -- False
mikeD &#x3D;&#x3D; mikeD        -- True
mikeD &#x3D;&#x3D; Person &#123;firstName &#x3D; &quot;Michael&quot;, lastName &#x3D; &quot;Diamond&quot;, age &#x3D; 43&#125;  
-- True<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>重写时需要实现<code>==</code></p><pre class="line-numbers language-haskell" data-language="haskell"><code class="language-haskell">data Shape &#x3D; Circle Float Float Float | Rectangle Float Float Float Float

instance Eq Shape where
  (Circle x1 y1 r1) &#x3D;&#x3D; (Circle x2 y2 r2) &#x3D; x1 &#x3D;&#x3D; x2 &amp;&amp; y1 &#x3D;&#x3D; y2 &amp;&amp; r1 &#x3D;&#x3D; r2
  (Rectangle x11 y11 x21 y21) &#x3D;&#x3D; (Rectangle x12 y12 x22 y22) &#x3D; x11 &#x3D;&#x3D; x12 &amp;&amp; y11 &#x3D;&#x3D; y12 &amp;&amp; x21 &#x3D;&#x3D; x22 &amp;&amp; y21 &#x3D;&#x3D; y22
  _ &#x3D;&#x3D; _ &#x3D; False

-- 别看不懂, 只是简单的中缀表达式

t1 &#x3D; Circle 1 1 1 &#x3D;&#x3D; Circle 1 1 1            -- True
t2 &#x3D; Circle 1 1 2 &#x3D;&#x3D; Circle 1 1 1            -- False
t3 &#x3D; Rectangle 1 1 2 3 &#x3D;&#x3D; Rectangle 1 1 2 3  -- True
t4 &#x3D; Rectangle 1 1 2 3 &#x3D;&#x3D; Rectangle 1 1 2 4  -- False
t5 &#x3D; Circle 1 1 2 &#x3D;&#x3D; Rectangle 1 1 2 4       -- False<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li><li><p>定义<code>Bool</code>类型派生自<code>Ord</code>. 使得其支持<code>&lt;</code>, <code>&gt;</code>, <code>==</code>, <code>succ</code>, <code>pred</code>, <code>minBound</code>, <code>maxBound</code>, <code>..</code></p><pre class="line-numbers language-haskell" data-language="haskell"><code class="language-haskell">data Bool &#x3D; False | True deriving (Ord)

succ False      -- True
pred True       -- False<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p><code>Ord</code>的顺序就是定义类型时<code>|</code>的顺序.</p></li></ul><h4 id="定义typeclasses">定义<code>TypeClasses</code></h4><p><code>Haskell</code>的<code>TypeClasses</code>与命令式编程中的接口类似. 我们需要定义<code>TypeClasses</code>与<code>TypeClasses</code>中函数. 使用<code>class</code>关键字定义🙃(多少有点嘲讽), 其需要实现的方法在<code>where</code>中. 例如</p><ul><li><p><code>Eq</code>类型类的定义</p><pre class="line-numbers language-haskell" data-language="haskell"><code class="language-haskell">class Eq a where
    (&#x3D;&#x3D;) :: a -&gt; a -&gt; Bool
    (&#x2F;&#x3D;) :: a -&gt; a -&gt; Bool
    x &#x3D;&#x3D; y &#x3D; not (x &#x2F;&#x3D; y)
    x &#x2F;&#x3D; y &#x3D; not (x &#x3D;&#x3D; y)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>😲看起来有点离谱, 这波循环定义属实是没想到...要是真是这么定义的可太离谱了. 可是人家真的是这么定义的. 毕竟, 这是默认定义, 我们在实现接口的时候可以重写</p><p>实现一个红绿灯类型, 并派生自<code>Eq</code></p><pre class="line-numbers language-haskell" data-language="haskell"><code class="language-haskell">data TrafficLight &#x3D; Red | Yellow | Green

instance Eq TrafficLight where
    Red &#x3D;&#x3D; Red &#x3D; True
    Green &#x3D;&#x3D; Green &#x3D; True
    Yellow &#x3D;&#x3D; Yellow &#x3D; True
    _ &#x3D;&#x3D; _ &#x3D; False<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>我们定义了红绿灯的三个值, 并且重写了<code>==</code>(只有三种情况是True, 其他都是<code>False</code>)</p><p>然后就不用定义<code>/=</code>了, <code>Haskell</code>直接使用默认的<code>/=</code>定义</p></li></ul><p>其中类型定义也可以对类型参数变量进行定义, 定义<code>Mybe</code>类型的元素派生自<code>Eq</code></p><pre class="line-numbers language-haskell" data-language="haskell"><code class="language-haskell">instance (Eq m) &#x3D;&gt; Eq (Maybe m) where
    Just x &#x3D;&#x3D; Just y &#x3D; x &#x3D;&#x3D; y
    Nothing &#x3D;&#x3D; Nothing &#x3D; True
    _ &#x3D;&#x3D; _ &#x3D; False<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>可以使用<code>:info</code>获取类型所派生的<code>TypeClasses</code></p><pre class="line-numbers language-haskell" data-language="haskell"><code class="language-haskell">ghci&gt; :info Maybe
type Maybe :: * -&gt; *
data Maybe a &#x3D; Nothing | Just a
        -- Defined in ‘GHC.Maybe’
instance Applicative Maybe -- Defined in ‘GHC.Base’
instance Eq a &#x3D;&gt; Eq (Maybe a) -- Defined in ‘GHC.Maybe’
instance Functor Maybe -- Defined in ‘GHC.Base’
instance Monad Maybe -- Defined in ‘GHC.Base’
instance Semigroup a &#x3D;&gt; Monoid (Maybe a) -- Defined in ‘GHC.Base’
instance Ord a &#x3D;&gt; Ord (Maybe a) -- Defined in ‘GHC.Maybe’
instance Semigroup a &#x3D;&gt; Semigroup (Maybe a)
  -- Defined in ‘GHC.Base’
instance Show a &#x3D;&gt; Show (Maybe a) -- Defined in ‘GHC.Show’
instance Read a &#x3D;&gt; Read (Maybe a) -- Defined in ‘GHC.Read’
instance MonadFail Maybe -- Defined in ‘Control.Monad.Fail’
instance Foldable Maybe -- Defined in ‘Data.Foldable’
instance Traversable Maybe -- Defined in ‘Data.Traversable’<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>看一个例子: <code>yes-no typeclass</code></strong>😎</p><p><code>yes-no typeclass</code>类似弱类型的<code>Bool</code></p><pre class="line-numbers language-haskell" data-language="haskell"><code class="language-haskell">class YesNo a where
    yesno :: a -&gt; Bool
    
instance YesNo Int where
    yesno 0 &#x3D; False
    yesno _ &#x3D; True
 
instance YesNo [a] where
    yesno [] &#x3D; False
    yesno _ &#x3D; True
    
instance YesNo Bool where
    yesno &#x3D; id    -- id的作用就是返回参数<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>实现一个方法</p><pre class="line-numbers language-haskell" data-language="haskell"><code class="language-haskell">yesnoIf :: (YesNo y) &#x3D;&gt; y -&gt; a -&gt; a -&gt; a
yesnoIf yesnoVal yesResult noResult &#x3D;
    if yesno yesnoVal then yesResult else noResult<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><h4 id="functor-typeclass">Functor typeclass</h4><p>🚧<code>Functor typeclass</code>是Haskell中很重要的<code>TypeClasses</code>, 其仅定义了<code>fmap</code>方法, 该方法用于实现该类型的<code>map</code>, 怎么处理<code>f x</code>到<code>y</code></p><pre class="line-numbers language-haskell" data-language="haskell"><code class="language-haskell">class Functor f where
    fmap :: (a -&gt; b) -&gt; f a -&gt; f b<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>例如在<code>List</code>中</p><pre class="line-numbers language-haskell" data-language="haskell"><code class="language-haskell">instance Functor [] where
    fmap &#x3D; map
    
fmap (*2) [1..3]
-- [2,4,6]<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>在<code>Maybe</code>中实现</p><pre class="line-numbers language-haskell" data-language="haskell"><code class="language-haskell">instance Functor Maybe where
    fmap f (Just x) &#x3D; Just (f x)
    fmap f Nothing &#x3D; Nothing<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>在<code>Either</code>中实现(如果是<code>Right</code>就映射, 如果是<code>Left</code>就不)</p><pre class="line-numbers language-haskell" data-language="haskell"><code class="language-haskell">data Either a b &#x3D; Left a | Right b  -- Either 定义

instance Functor (Either a) where
    fmap f (Right x) &#x3D; Right (f x)
    fmap f (Left x) &#x3D; Left x<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="kind">Kind</h4><p>在定义<code>Type</code>的时候我们可以通过给定类型参数而实现类似"模板"("多态")的功能. 也就是说, 定义<code>Type</code>的时候可以给一个参数类型, 返回一个"具体"的<code>Type</code>. 🤔看起来有点像函数?</p><p>还有个问题, 看看<code>Just 5</code>的类型<code>(Just 5) :: Num a =&gt; Maybe a</code>, 他是怎么知道<code>5</code>是<code>Num</code>类型的呢? 🤔很简单, <code>5</code>上边绑定了一个<code>Type</code>标签🏷. 可以使用<code>:k</code>查看</p><pre class="line-numbers language-haskell" data-language="haskell"><code class="language-haskell">ghci&gt; :k Int
-- Int :: *<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p><code>*</code>标记表示一个"具体"的Type, 就是定义类型的时候没有类型参数.</p><pre class="line-numbers language-haskell" data-language="haskell"><code class="language-haskell">ghci&gt; :k Maybe
-- Maybe :: * -&gt; *<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>与<code>:t</code>类似, 这个<code>Kind</code>的意思是接受一个<code>*</code>(具体的类型), 返回一个<code>*</code>(具体的类型), 同理</p><pre class="line-numbers language-haskell" data-language="haskell"><code class="language-haskell">ghci&gt; :k Maybe Int
-- Maybe Int :: *<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>表示<code>Maybe Int</code>是一个具体的类型. <code>Kind</code>也支持柯里化</p><pre class="line-numbers language-haskell" data-language="haskell"><code class="language-haskell">ghci&gt; :k Either
-- Either :: * -&gt; * -&gt; *
ghci&gt; :k Either String
-- Either String :: * -&gt; *
ghci&gt; :k Either String Int
-- Either String Int :: *<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><hr><h3 id="输入与输出">输入与输出</h3><p>在命令式语言中轻而易举实现的IO, 在<code>Haskell</code>却是一件难事, Terminal显示的内容本身是一个变量, 而<code>Haskell</code>的函数是无副作用的纯函数. 向屏幕输出意味着修改了外部变量. 就像将IPv6数据包打包成IPv4数据包以通过IPv4环境一样. <code>Haslell</code>采取了类似"隧道"的方法解决这一问题🪆</p><ul><li>将需要输出的数据"包装"成一种特殊的类型送出函数, 这个特殊的类型可以与非纯函数环境接触, 非纯函数环境中函数获取包装中的数据并输出</li><li>在获取输入时, 非纯函数环境将数据"包装"为特殊类型, 将特殊类型数据传入<code>Haskell</code>, <code>Haskell</code>取出其内部的数据</li></ul><h4 id="基础io函数">基础IO函数</h4><ul><li><p><strong><code>main</code>&amp;<code>do</code>方法</strong>📇</p><p>首先要了解的是<code>main</code>, <strong>所有IO相关动作都必须直接或间接绑定在<code>main</code>函数上才会被执行</strong></p><p><pre class="line-numbers language-haskell" data-language="haskell"><code class="language-haskell">main &#x3D; putStrLn &quot;hello, world&quot;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></p><p><code>main</code>中不可能只绑定一个IO函数, 可以使用<code>do</code>可以链接一串IO指令</p><pre class="line-numbers language-haskell" data-language="haskell"><code class="language-haskell">main &#x3D; do
    putStrLn &quot;Hello&quot;
    putStrLn &quot;Helloha&quot;
    putStrLn &quot;nihao&quot;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>将所有IO都直接写在<code>main</code>上是在有点冗长, 我们可以间接绑定IO函数</p><pre class="line-numbers language-haskell" data-language="haskell"><code class="language-haskell">main &#x3D; do
  putStrLn &quot;hi&quot;
  name &lt;- getLine
  demo name

demo name &#x3D; putStrLn (&quot;Hi &quot; ++ name ++ &quot; !&quot;)

demo2 &#x3D; putStrLn &quot;hiii&quot; -- 没绑在main上就不执行
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li><li><p><strong>"包装"的类型</strong>🎁</p><ul><li><p>虽然并不知道IO函数有那些, 但是隐隐约约还是知道上面的<code>putStrLn</code>是用来输出的, 尝试看看其包装的类型</p><p><pre class="line-numbers language-haskell" data-language="haskell"><code class="language-haskell">ghci&gt; :t putStrLn 
putStrLn :: String -&gt; IO ()<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre></p><p>收入一个<code>String</code>, 得到一个<code>IO ()</code>类型(<code>IO action</code>), 这里的<code>IO</code>就是包装, 后面接着一个空Tuple, 作为一个输出函数, 我们将数据放在盒子里面输出, 外部环境接受并拿走数据, 这个包装里面就成空的了, 所以返回一个空包装</p></li><li><p>虽然并不知道IO函数有那些, 但是隐隐约约还是知道上面的<code>getLine</code>是用来输入的, 尝试看看其包装的类型</p><p><pre class="line-numbers language-haskell" data-language="haskell"><code class="language-haskell">ghci&gt; :t getLine
getLine :: IO String<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre></p><p>没毛病, 就是一个IO包装, 包装内是一个<code>String</code>.</p><p>那么如何获取包装中的数据呢? , 使用<code>&lt;-</code>符号将包装类型<code>IO String</code>解包为<code>String</code>, <strong>注意: <code>&lt;-</code>符号只能用于<code>do</code>语句, 这保证了不纯粹的东西只存在于do中</strong></p></li><li><p><code>main</code>的类型: <code>main</code>的类型为<code>do</code>的最后一条指令决定, 而<code>do</code>返回类型必须是<code>IO *</code></p><p><pre class="line-numbers language-haskell" data-language="haskell"><code class="language-haskell">main &#x3D; do
  putStrLn &quot;hi&quot;       -- 👍, 类型为IO ()

main &#x3D; do
  putStrLn &quot;hi&quot;
  getLine             -- 👍, 类型为IO String

main &#x3D; do
  putStrLn &quot;hi&quot;
  name &lt;- getLine     -- 👎, 类型为String<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></p></li></ul></li><li><p><code>let binding</code></p><p>在函数中, 我们可以使用<code>where</code>/<code>let-in</code>指定局部函数, 但是在<code>do</code>语句中我们只能使用<code>let</code>(因为<code>do</code>是一个表达式)</p><pre class="line-numbers language-haskell" data-language="haskell"><code class="language-haskell">import Data.Char

main &#x3D; do
    putStrLn &quot;What&#39;s your first name?&quot;
    firstName &lt;- getLine
    putStrLn &quot;What&#39;s your last name?&quot;
    lastName &lt;- getLine
    let bigFirstName &#x3D; map toUpper firstName
        bigLastName &#x3D; map toUpper lastName
    putStrLn $ &quot;hey &quot; ++ bigFirstName ++ &quot; &quot; ++ bigLastName ++ &quot;, how are you?&quot;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li><li><p><strong><code>do-block</code>与<code>return</code></strong></p><p>以下函数实现了不断从Terminal读取字符串, 并将句子中的单词反转</p><pre class="line-numbers language-haskell" data-language="haskell"><code class="language-haskell">main &#x3D; do
    line &lt;- getLine
    if null line
        then return ()
        else do
            putStrLn $ reverseWords line
            main

reverseWords :: String -&gt; String
reverseWords &#x3D; unwords . map reverse . words<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li><p>可以看到<code>main</code>也可以递归调用, 但是在这个<code>else</code>语句中我们顺序调用了两个语句, 所以应该用<code>do</code>包起来</p></li><li><p>注意<code>line=null</code>后的<code>then return ()</code>, 这个<code>return</code>的作用是<strong>使用一个 <code>pure value</code>构造一个<code>IO action</code></strong>, 也就是说这里<code>return ()</code>只是构造了一个<code>IO Action ()</code>, 作为<code>do-block</code>的最后一句, <code>IO Action ()</code>成为了返回值</p></li><li><p>谨记: <code>return</code>函数只是构造了一个<code>IO Action</code>, 绝不是命令式编程中的停止解析返回, 下面的代码会返回<code>IO ()</code>(因为<code>putStrLn</code>)</p><pre class="line-numbers language-haskell" data-language="haskell"><code class="language-haskell">main &#x3D; do
    return ()
    return &quot;HAHAHA&quot;
    line &lt;- getLine
    return &quot;BLAH BLAH BLAH&quot;
    return 4
    putStrLn line<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li></ul></li><li><p>常见IO函数</p><ul><li><code>putStrLn string</code>将<code>string</code>打印在Terminal中并<strong>换行</strong></li><li><code>putStr string</code> 跟 <code>putStrLn</code> 只是不换行</li><li><code>putChar char</code> 接受一个字符，并回传一个 <code>IO action</code> 将他打印到终端上</li><li><code>print</code>接受<code>Show</code>类型的值，调用 <code>show</code> 来将值变成字串然后将其输出到终端上. 基本上, 他就是 <code>putStrLn . show</code></li><li><code>getChar</code> 是一个从输入读进一个字符的 <code>IO action</code></li><li><code>when</code>传入<code>Bool</code>与<code>IO Action</code>, 若为<code>True</code>则回传<code>IO Action</code>, 为<code>False</code>则回传<code>IO ()</code></li></ul></li><li><p>IO函数中的"<code>Functor</code>"</p><ul><li><p><code>sequence</code>: 接收<code>IO Action</code>的<code>List</code>, 依次执行并返回<code>IO 返回值的List</code>即: <code>[IO a] -&gt; IO [a]</code></p><pre class="line-numbers language-haskell" data-language="haskell"><code class="language-haskell">main &#x3D; do
  xs &lt;- sequence [getLine, getLine, getLine]
  print xs<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>记得, <code>sequence</code>返回的是<code>IO [a]</code>, 所以还用<code>&lt;-</code>返回</p><pre class="line-numbers language-haskell" data-language="haskell"><code class="language-haskell">main &#x3D; do
  xs &lt;- sequence . map print $ [1 .. 3]
  print xs        -- [(),(),()] print返回的是空Tuple, 这里也是<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre></li><li><p><code>mapM</code>相当于先<code>map</code>再<code>sequence</code>. 即</p><pre class="line-numbers language-haskell" data-language="haskell"><code class="language-haskell">main &#x3D; do
  xs &lt;- mapM print [1, 2, 3]
  print xs<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>相当于</p><pre class="line-numbers language-haskell" data-language="haskell"><code class="language-haskell">main &#x3D; do
  xs &lt;- mapM&#39; print [1, 2, 3]
  print xs

mapM&#39; :: (a -&gt; IO b) -&gt; [a] -&gt; IO [b]
mapM&#39; f &#x3D; (sequence . map f)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><code>mapM_</code>就是返回为<code>return ()</code>的<code>mapM</code></p></li><li><p><code>forever</code>是<code>Monad</code>的方法, 其接收一个<code>IO Action</code>并死循环执行, 如</p><pre class="line-numbers language-haskell" data-language="haskell"><code class="language-haskell">import Control.Monad.Logic (forever)
import Unicode.Char (toUpper)

main &#x3D; forever $ do
  t &lt;- getLine
  putStrLn $ map toUpper t<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>等价于</p><pre class="line-numbers language-haskell" data-language="haskell"><code class="language-haskell">import Control.Monad.Logic (forever)
import Unicode.Char (toUpper)

main &#x3D; do
  t &lt;- getLine
  putStrLn $ map toUpper t
  main<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li><li><p><code>forM</code>是<code>Monad</code>的方法, <code>forM</code>之于<code>forever</code>相当于<code>mapM</code>之于<code>sequence</code>. 作用是先Map, 再对每一项执行函数.</p><p>实现输入四个字符串并输出</p><pre class="line-numbers language-haskell" data-language="haskell"><code class="language-haskell">import Control.Monad

main &#x3D; do
    colors &lt;- forM [1,2,3,4] (\a -&gt; do
        putStrLn $ &quot;Which color do you associate with the number &quot; ++ show a ++ &quot;?&quot;
        color &lt;- getLine
        return color)
    putStrLn &quot;The colors that you associate with 1, 2, 3 and 4 are: &quot;
    mapM putStrLn colors<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>等价于</p><pre class="line-numbers language-haskell" data-language="haskell"><code class="language-haskell">main &#x3D; do
  t &lt;-
    forM&#39;
      [1, 2, 3, 4]
      ( \a -&gt; do
          putStrLn $ show a ++ &quot;: &quot;
          i &lt;- getLine
          return i
      )
  mapM putStrLn t

forM&#39; (x : xs) f &#x3D; f x : forM&#39; xs f
forM&#39; [] _ &#x3D; []<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li></ul></li></ul><h4 id="文件与字符流">文件与字符流</h4><ul><li><p><code>getContents</code>: 从Terminal读取<code>String</code>直到<code>EOF</code>, 且<code>getContents</code>是惰性的, 需要多少从内存中拿多少, 之前<code>forever</code>大写的程序可以改成</p><pre class="line-numbers language-haskell" data-language="haskell"><code class="language-haskell">import Unicode.Char (toUpper)
main &#x3D; do
  t &lt;- getContents
  putStrLn $ map toUpper t<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>正因为是惰性的, 我们可以分批输入内容(只有在<code>map</code>的时候才会调入)🫗</p></li><li><p>读写文件📄</p><pre class="line-numbers language-haskell" data-language="haskell"><code class="language-haskell">import System.IO

main &#x3D; do
    handle &lt;- openFile &quot;girlfriend.txt&quot; ReadMode
    contents &lt;- hGetContents handle
    putStr contents
    hClose handle<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>其中, <code>openFile</code>获取文件Handle(可以理解成一个文件指针及其<code>Context</code>)类型定义</p><pre class="line-numbers language-haskell" data-language="haskell"><code class="language-haskell">openFile :: FilePath -&gt; IOMode -&gt; IO Handle<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><code>IOMode</code>描述了文件读写的模式, 定义</p><pre class="line-numbers language-haskell" data-language="haskell"><code class="language-haskell">data IOMode &#x3D; ReadMode | WriteMode | AppendMode | ReadWriteMode<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><code>FilePath</code>定义</p><pre class="line-numbers language-haskell" data-language="haskell"><code class="language-haskell">type FilePath &#x3D; String<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><code>openFile</code>返回<code>IO Handle</code>, 之后使用<code>hGetContents</code>将文件Handle中数据取出得到<code>IO String</code>. <code>hGetContents</code>与<code>getContents</code>类似, 也是Lazy的, 在读取文件时并不会将文件全部读入内存. 文件操作结束后使用<code>hClose</code>关闭文件</p></li><li><p>另一种读写文件的方式是<code>withFile</code>, 定义</p><pre class="line-numbers language-haskell" data-language="haskell"><code class="language-haskell">withFile :: FilePath -&gt; IOMode -&gt; (Handle -&gt; IO a) -&gt; IO a<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>即: 接收两个参数与文件处理函数, 最后返回一个<code>IO</code>, 例如</p><pre class="line-numbers language-haskell" data-language="haskell"><code class="language-haskell">import System.IO

main &#x3D; do
    withFile &quot;girlfriend.txt&quot; ReadMode (\handle -&gt; do
            contents &lt;- hGetContents handle
            putStr contents)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>容易实现<code>withFile</code></p><pre class="line-numbers language-haskell" data-language="haskell"><code class="language-haskell">withFile&#39; :: FilePath -&gt; IOMode -&gt; (Handle -&gt; IO a) -&gt; IO a
withFile&#39; path mode f &#x3D; do
    handle &lt;- openFile path mode
    result &lt;- f handle
    hClose handle
    return result<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li><li><p>与<code>hGetContents</code>比起来更加容易的文件读入函数有<code>hGetLine</code>, <code>hPutStr</code>, <code>hPutStrLn</code>, <code>hGetChar</code>, 他们都接受一个<code>IO Handle</code>, 行为与去掉<code>h</code>前缀函数相同</p></li><li><p>也可以省略<code>IO Handle</code>与<code>hClose</code>使用如下<code>readFile</code>, <code>writeFile</code>, <code>appendFile</code>函数读写文件</p><pre class="line-numbers language-haskell" data-language="haskell"><code class="language-haskell">import System.IO

main &#x3D; do
    contents &lt;- readFile &quot;girlfriend.txt&quot;
    putStr contents<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-haskell" data-language="haskell"><code class="language-haskell">import System.IO

main &#x3D; do
    contents &lt;- readFile &quot;girlfriend.txt&quot;
    writeFile &quot;girlfriendcaps.txt&quot; &quot;123456&quot;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-haskell" data-language="haskell"><code class="language-haskell">import System.IO

main &#x3D; do
    todoItem &lt;- getLine      -- getLine 不包含回车
    appendFile &quot;todo.txt&quot; (todoItem ++ &quot;\n&quot;)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre></li><li><p>IO函数是惰性的, 可以手动使用<code>hSetBuffering</code>配置buffer, 类型定义我i哦</p><pre class="line-numbers language-haskell" data-language="haskell"><code class="language-haskell">hSetBuffering -&gt; IO Handle -&gt; BufferMode<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>其中</p><pre class="line-numbers language-haskell" data-language="haskell"><code class="language-haskell">type BufferMode &#x3D; NoBuffering | LineBuffering | BlockBuffering (Maybe Int)<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>最后一项表示Buffer大小为多少Byte</p></li><li><p><code>openTempFile</code>函数可以在当前目录下创建并打开一个随机名字的文件, 用于暂存数据</p></li></ul><h4 id="命令行参数">命令行参数</h4><p><code>System.Environment</code>的<code>getArgs</code>与<code>getProgName</code>定义了命令行相关参数</p><ul><li><p><code>getArgs</code>返回参数数组, 最后一个元素是所有参数String</p></li><li><p><code>getProgName</code>返回程序名, 例如</p><pre class="line-numbers language-haskell" data-language="haskell"><code class="language-haskell">import System.Environment
import Data.List

main &#x3D; do
    args &lt;- getArgs
    progName &lt;- getProgName
    putStrLn &quot;The arguments are:&quot;
    mapM putStrLn args
    putStrLn &quot;The program name is:&quot;
    putStrLn progName<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-haskell" data-language="haskell"><code class="language-haskell">$ .&#x2F;arg-test first second w00t &quot;multi word arg&quot;
The arguments are:
first
second
w00t
multi word arg
The program name is:
arg-test<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li></ul><h3 id="函数式地解决问题">函数式地解决问题</h3><p>一个不错的思考思路是</p><ol type="1"><li>明确我们输入与输出的数据类型</li><li>忘掉<code>Haskell</code>, 想想我们自己是怎么一步步解题的</li><li>思考如何在<code>Haskell</code>中表达我们的数据, 应该如何定义我们的行为</li><li>在 Haskell 中要如何对这些数据做运算来产生出解答</li></ol><h4 id="求解逆波兰表达式">求解逆波兰表达式</h4><p><span class="exturl" data-url="aHR0cHM6Ly96aC53aWtpcGVkaWEub3JnL3poLWNuLyVFOSU4MCU4NiVFNiVCMyVBMiVFNSU4NSVCMCVFOCVBMSVBOCVFNyVBNCVCQSVFNiVCMyU5NQ==">逆波兰表示法-wiki<i class="fa fa-external-link-alt"></i></span></p><p>在命令式编程中, 我们可以使用一个栈轻松处理, 在<code>Haskell</code>中, 向后加入元素很麻烦, 不如向前加入元素</p><ol type="1"><li>明确我们输入与输出的数据类型: <code>String-&gt;Num</code></li><li>忘掉<code>Haskell</code>, 想想我们自己是怎么一步步解题的<ol type="1"><li>如果数字则压栈, 遇到符号则弹两个元素, 计算后压栈</li></ol></li><li>思考如何在<code>Haskell</code>中表达我们的数据, 应该如何定义我们的行为<ol type="1"><li>将<code>String</code>变为一个个元素<code>String</code>(数字/符号)的<code>List</code></li><li>计算到最后就得到了一个单元素<code>List</code></li><li>取出这个元素</li></ol></li><li>在 Haskell 中要如何对这些数据做运算来产生出解答<ol type="1"><li>使用<code>words</code>解析</li><li>使用<code>flodl</code>遍历</li><li>使用<code>guard</code>判断元素类型</li><li>使用<code>x:xs</code>压栈</li><li>使用<code>(x:y:ys)</code>模式匹配获取tops与剩下内容</li></ol></li></ol><pre class="line-numbers language-haskell" data-language="haskell"><code class="language-haskell">solveRPN :: (Fractional a, Read a) &#x3D;&gt; String -&gt; a
solveRPN xs &#x3D; head $ foldl foldingNum [] (words xs)
  where
    foldingNum (x : y : ys) &quot;+&quot; &#x3D; x + y : ys
    foldingNum (x : y : ys) &quot;-&quot; &#x3D; x - y : ys
    foldingNum (x : xs) &quot;-&quot; &#x3D; (-x) : xs    -- 只有双目运算匹配失败才会匹配
    foldingNum (x : y : ys) &quot;*&quot; &#x3D; x * y : ys
    foldingNum (x : y : ys) &quot;&#x2F;&quot; &#x3D; x &#x2F; y : ys
    foldingNum ys nums &#x3D; read nums : ys<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="最短路搜索">最短路搜索</h4><p>有两个起点与两个终点, 你可以指定起点与终点, 求起点到终点最小值</p><p>有两条主要道路，他们中间有很多小路连接彼此。如果你要走小路的话都会花掉一定的时间。你的问题就是要选一条最佳路径让你可以尽快前往终点,</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">ST &#x3D;&#x3D;50&#x3D;&#x3D;+&#x3D;&#x3D;05&#x3D;&#x3D;+&#x3D;&#x3D;40&#x3D;&#x3D;+&#x3D;&#x3D;10&#x3D;&#x3D; ED
        ||     ||     ||
        30     20     25
        ||     ||     ||
ST &#x3D;&#x3D;10&#x3D;&#x3D;+&#x3D;&#x3D;90&#x3D;&#x3D;+&#x3D;&#x3D;02&#x3D;&#x3D;+&#x3D;&#x3D;8&#x3D;&#x3D; ED<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>输入格式: 路径按照自左向右每组: 上下右的模式输入(最后两个ED之间长度为0), 例如上例</p><pre class="line-numbers language-haskell" data-language="haskell"><code class="language-haskell">[50, 10, 30, 5, 90, 20, 40, 2, 25, 10, 8, 0]<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><ol type="1"><li>明确我们输入与输出的数据类型: <code>[Num]-&gt;[Char]</code></li><li>忘掉<code>Haskell</code>, 想想我们自己是怎么一步步解题的<ol type="1"><li>分别计算每走到一个上下岔路口的最小距离</li></ol></li><li>思考如何在<code>Haskell</code>中表达我们的数据, 应该如何定义我们的行为<ol type="1"><li>我们需要下一组路径的上方路线花费, 下方路线花费, 岔路之间花费, 到达前一个上下岔路口花费, 转移到下一个岔路</li></ol></li><li>在 Haskell 中要如何对这些数据做运算来产生出解答<ol type="1"><li><code>到达上方路口花费=min(前一个上方路口花费+上方路线花费, 前一个下方路口花费+下方路线花费+上下路口花费)</code></li><li>到达下方路口花费同理</li></ol></li></ol><pre class="line-numbers language-haskell" data-language="haskell"><code class="language-haskell">pathGet :: (Num a, Ord a) &#x3D;&gt; [a] -&gt; a -&gt; a -&gt; [Char]
pathGet (t : b : r : xs) ct cb
  | cct &lt; ccb &#x3D; &#39;A&#39; : pathGet xs cct ccb
  | otherwise &#x3D; &#39;B&#39; : pathGet xs cct ccb
  where
    cct &#x3D; min (ct + t) (cb + b + r)
    ccb &#x3D; min (ct + t + r) (cb + b)
pathGet _ ct cb
  | ct &lt; cb &#x3D; &quot;A&quot;
  | otherwise &#x3D; &quot;B&quot;

res &#x3D; pathGet [50, 10, 30, 5, 90, 20, 40, 2, 25, 10, 8, 0] 0 0<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="从functor到monoids">从Functor到Monoids</h3><h4 id="functor是什么">Functor是什么</h4><p>在Haskell中, <code>Functor</code>是一个类型类, 其仅定义了一个<code>fmap</code>方法用于描述Type是如何被Map Over的. 什么是map over呢?</p><p>Haskell的<code>List</code>中有一个<code>map</code>方法, 允许传入一个函数与<code>List</code>, 返回一个将List的中每一个元素都执行函数的结果. 这与JS的<code>Array.map</code>类似. 所以我们当时认为<code>Map</code>就是一个映射. 然而, <code>Map</code>不止可以应用于<code>List</code>. <code>Map</code>可以用于任何定义了<code>fmap</code>的对象</p><p>我们将对象分为简单对象与高阶对象. 简单对象也可以称之为"值", 例如数字, Char就是简单对象, 我们可以直接对其进行朴素操作. 高阶对象好像一个用盒子包装过的对象🎁, 回顾List的定义</p><pre class="line-numbers language-haskell" data-language="haskell"><code class="language-haskell">data List a &#x3D; Empty | Cons a (List a) <span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>在这里, 我们将List当作一个整体. 其中包含了一些相对"简单"的对象. 我们无法用普通函数直接操作这些普通对象. 例如我们没法对一个<code>[1,2,3]</code>这个整体执行<code>(+1)</code>操作, 如何刺入高阶对象🤺, 让普通函数操作高阶对象内部的普通元素呢? 将Type定义为使用<code>Functor</code>并使用<code>fmap</code>, 例如我想将<code>Maybe</code>中的值<code>(+1)</code>:</p><pre class="line-numbers language-haskell" data-language="haskell"><code class="language-haskell">ghci&gt; t &#x3D; Just 2
ghci&gt; t + 1
-- &lt;interactive&gt;:2:1: error:
--     • Non type-variable argument in the constraint: Num (Maybe a)
--       (Use FlexibleContexts to permit this)
--     • When checking the inferred type
--         it :: forall &#123;a&#125;. (Num a, Num (Maybe a)) &#x3D;&gt; Maybe a
ghci&gt; fmap (+1) t
-- Just 3<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><code>Maybe</code>是一个高阶对象, 也是<code>Functor</code>的派生Type. 因此, 我们可以使用<code>fmap</code>对内部元素进行操作. 那, 其中<code>fmap</code>拿到函数与<code>Maybe</code>之后的行为由<code>Maybe</code>类型定义时实现(类比, <code>map</code>拿到函数与<code>List</code>之后怎么知道要将函数应用于每个元素呢? 这也是由<code>List</code>派生<code>Functor</code>时候实现的)</p><p>📊<strong>总结: <code>Functor</code>是一个类型类, 定义了一个<code>fmap</code>函数, 该函数描述如何用一个普通函数对高阶对象进行操作</strong></p><p><code>fmap</code>的定义如下</p><pre class="line-numbers language-haskell" data-language="haskell"><code class="language-haskell">fmap :: (Functor f) &#x3D;&gt; (b -&gt; c) -&gt; f b -&gt; f c<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>可以看看<code>Maybe</code>的<code>Functor</code>实现</p><pre class="line-numbers language-haskell" data-language="haskell"><code class="language-haskell">instance Functor Maybe where  
    fmap f (Just x) &#x3D; Just (f x)  
    fmap f Nothing &#x3D; Nothing<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>也可以仿制一个<code>List</code>的<code>Functor</code>实现</p><pre class="line-numbers language-haskell" data-language="haskell"><code class="language-haskell">data List&#39; a &#x3D; Empty | Cons a (List&#39; a) deriving (Show)

instance Functor List&#39; where
  fmap _ Empty &#x3D; Empty
  fmap f (Cons x xs) &#x3D; Cons (f x) (fmap f xs)

t &#x3D; fmap (+ 1) $ Cons 1 $ Cons 2 $ Cons 3 Empty<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>⚖<strong>最后: <code>Functor</code>的<code>fmap</code>实现应该遵循如下法则</strong></p><ul><li>如果我们对 functor 做 map <code>id</code>，那得到的新的 functor 应该要跟原来的一样. 即: <code>fmap id = id</code></li><li>先将两个函数合成并将结果<code>map over</code>一个<code>functor</code>的结果, 应该跟先将第一个函数<code>map over</code>一个<code>functor</code>，再将第二个函数<code>map over</code>那个<code>functor</code>的结果是一样的. 即: <code>fmap (f . g) = fmap f . fmap g</code>或<code>fmap (f . g) F = fmap f (fmap g F)</code></li></ul><h4 id="applicative-functors">Applicative Functors</h4><p>仔细看<code>fmap</code>的类型定义, 我们的函数只能接收一个参数, 并返回一个参数. 我们无法让函数接收多个参数, 例如<code>\ x y -&gt; x + y</code></p><p>✨为此, 我们可以采用<code>Functors</code>的升级版<code>Applicative Functors</code>, 即<code>Applicative</code>类型类, 其类型定义如下</p><pre class="line-numbers language-haskell" data-language="haskell"><code class="language-haskell">class (Functor f) &#x3D;&gt; Applicative f where  
    pure :: a -&gt; f a  
    (&lt;*&gt;) :: f (a -&gt; b) -&gt; f a -&gt; f b
    (&lt;$&gt;) :: (a -&gt; b) -&gt; f a -&gt; f b<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><ul><li><code>(Functor f) =&gt; Applicative f</code>说明<code>Applicative Functors</code>必须是<code>Functors</code></li><li><code>pure</code>方法接收一个值, 返回一个值为该类型的高阶对象</li><li><code>&lt;*&gt;</code>接收一个包裹着函数的高阶对象, 再接收一个高阶对象, 得到另一个高阶对象. 看起来与<code>fmap</code>类似, 只不过接收的函数用高阶对象包起来了</li><li><code>&lt;$&gt;</code>看起来就是函数不包对象的<code>&lt;*&gt;</code></li></ul><p><strong>可以看看<code>Maybe</code>的<code>Applicative Functors</code>定义</strong></p><pre class="line-numbers language-haskell" data-language="haskell"><code class="language-haskell">instance Applicative Maybe where  
  pure &#x3D; Just  
  Nothing &lt;*&gt; _ &#x3D; Nothing  
  (Just f) &lt;*&gt; something &#x3D; fmap f something
  f &lt;$&gt; x &#x3D; fmap f x<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>使用</p><pre class="line-numbers language-haskell" data-language="haskell"><code class="language-haskell">ghci&gt; Just (+3) &lt;*&gt; Just 9  
-- Just 12
ghci&gt; pure (+) &lt;*&gt; Just 3 &lt;*&gt; Just 5    -- 也可以使用pure进行转换
-- Just 8  
ghci&gt; (+) &lt;$&gt; Just 3 &lt;*&gt; Just 4         -- 还可以直接使用&lt;$&gt;
-- Just 7
ghci&gt; (++) &lt;$&gt; Just &quot;johntra&quot; &lt;*&gt; Just &quot;volta&quot;  
Just &quot;johntravolta&quot;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>于是我们可以用<code>pure f &lt;*&gt; p1 &lt;*&gt; p2 &lt;*&gt; ...</code> / <code>f &lt;$&gt; p1 &lt;*&gt; p2 &lt;*&gt; ...</code>进行多参数调用了</p><p><strong>再看下<code>List</code>的<code>Applicative Functors</code>定义</strong></p><pre class="line-numbers language-haskell" data-language="haskell"><code class="language-haskell">instance Applicative [] where  
    pure x &#x3D; [x]  
    fs &lt;*&gt; xs &#x3D; [f x | f &lt;- fs, x &lt;- xs]<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><ul><li>第一行还好理解, 收入一个普通元素, 返回单元素<code>List</code></li><li>第二行说<code>&lt;*&gt;</code>收入两个<code>List</code>, 用第一个<code>List</code>的每个元素执行第二个<code>List</code></li><li>😒为什么List的<code>&lt;*&gt;</code>是这样定义的呢, 为啥不能像<code>zipWith</code>一样工作呢? 😱这是Haskell的List的定义, 不要纠结...</li></ul><p>例如</p><pre class="line-numbers language-haskell" data-language="haskell"><code class="language-haskell">ghci&gt; [(*0),(+100),(^2)] &lt;*&gt; [1,2,3]  
-- [0,0,0,101,102,103,1,4,9]
ghci&gt; (++) &lt;$&gt; [&quot;ha&quot;,&quot;heh&quot;,&quot;hmm&quot;] &lt;*&gt; [&quot;?&quot;,&quot;!&quot;,&quot;.&quot;]  
-- [&quot;ha?&quot;,&quot;ha!&quot;,&quot;ha.&quot;,&quot;heh?&quot;,&quot;heh!&quot;,&quot;heh.&quot;,&quot;hmm?&quot;,&quot;hmm!&quot;,&quot;hmm.&quot;]
-- 等价于
ghci&gt; [ x ++ y | x &lt;- [&quot;ha&quot;,&quot;heh&quot;,&quot;hmm&quot;], y &lt;- [&quot;?&quot;,&quot;!&quot;,&quot;.&quot;]]     
-- 等价于
ghci&gt; [(++)] &lt;*&gt; [&quot;ha&quot;, &quot;heh&quot;, &quot;hmm&quot;] &lt;*&gt; [&quot;?&quot;, &quot;!&quot;, &quot;.&quot;]<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>看看<code>IO</code>的<code>Applicative Functors</code>定义</strong></p><pre class="line-numbers language-haskell" data-language="haskell"><code class="language-haskell">instance Applicative IO where  
    pure &#x3D; return  
    a &lt;*&gt; b &#x3D; do  
        f &lt;- a  
        x &lt;- b  
        return (f x)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>例如</p><pre class="line-numbers language-haskell" data-language="haskell"><code class="language-haskell">main &#x3D; do  
    a &lt;- (++) &lt;$&gt; getLine &lt;*&gt; getLine  
    putStrLn $ &quot;The two lines concatenated turn out to be: &quot; ++ a<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p><strong>还有一个比较难理解的<code>(-&gt;) r</code>的<code>Applicative Functors</code></strong></p><pre class="line-numbers language-haskell" data-language="haskell"><code class="language-haskell">instance Applicative ((-&gt;) r) where  
    pure x &#x3D; (\_ -&gt; x)  
    f &lt;*&gt; g &#x3D; \x -&gt; f x (g x)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p><code>(-&gt;) r</code>表示一个接收参数类型为<code>r</code>的函数, 例如</p><pre class="line-numbers language-haskell" data-language="haskell"><code class="language-haskell">ghci&gt; (\x y z -&gt; [x,y,z]) &lt;$&gt; (+3) &lt;*&gt; (*2) &lt;*&gt; (&#x2F;2) $ 5  
-- [8.0,10.0,2.5]<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p><strong>还有类似于<code>Zip</code>的<code>List</code> <code>ZipList</code></strong></p><pre class="line-numbers language-haskell" data-language="haskell"><code class="language-haskell">instance Applicative ZipList where  
        pure x &#x3D; ZipList (repeat x)  
        ZipList fs &lt;*&gt; ZipList xs &#x3D; ZipList (zipWith (\f x -&gt; f x) fs xs)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>这样的操作很棒, <code>&lt;*&gt;</code>允许我们像使用<code>zipWith</code>一样使用<code>&lt;*&gt; zipList</code></p><pre class="line-numbers language-haskell" data-language="haskell"><code class="language-haskell">ghci&gt; getZipList $ (+) &lt;$&gt; ZipList [1,2,3] &lt;*&gt; ZipList [100,100,100]  
-- [101,102,103]  
ghci&gt; getZipList $ (+) &lt;$&gt; ZipList [1,2,3] &lt;*&gt; ZipList [100,100..]  
-- [101,102,103]  (zipWith要求结果以短List为准)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>⚖<strong>最后: <code>Applicative Functors</code>的<code>fmap</code>实现应该遵循如下法则</strong></p><ul><li>`pure f &lt;*&gt; x = fmap f x``</li><li>`pure id &lt;*&gt; v = v``</li><li>`pure (.) &lt;<em>&gt; u &lt;</em>&gt; v &lt;<em>&gt; w = u &lt;</em>&gt; (v &lt;*&gt; w)``</li><li>`pure f &lt;*&gt; pure x = pure (f x)``</li><li><code>u &lt;*&gt; pure y = pure ($ y) &lt;*&gt; u</code></li></ul><h4 id="newtype">newtype</h4><p>可以通过<code>data</code>声明一个<code>Type</code>, 然而, 如果我们的<code>Type</code>中只有<strong>一个值构造子, 值构造子只有一个字段</strong>, 我们可以使用<code>newtype</code>定义</p><pre class="line-numbers language-haskell" data-language="haskell"><code class="language-haskell">data ZipList a &#x3D; ZipList &#123; getZipList :: [a] &#125;
-- 等价于
newtype ZipList a &#x3D; ZipList &#123; getZipList :: [a] &#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>优点有</p><ul><li>🏃‍♂️<code>newtype</code>比较快, Haskell会将<code>newtype</code>理解为现有类型的二次包装, 在调用的时候只需要解包即可, 无需关心值到底匹配到了哪个值构造子</li><li>😴<code>newtype</code>是惰性的, 类型只有在需要的时候才会解包, 然后计算</li></ul><h4 id="monoids">Monoids</h4><p><code>Monoids</code>的意思是中译是幺半群, 相关数学定义如下</p><ul><li><p><span class="math inline">\(G\)</span>为非空集合，如果在<span class="math inline">\(G\)</span>上定义的二元运算 <em>，满足</em></p><ul><li>封闭性: 对于任意<span class="math inline">\(a, b \in G\)</span>, 有<span class="math inline">\(a * b \in G\)</span></li><li>结合律: 对于任意<span class="math inline">\(a, b, c \in G\)</span>, 有<span class="math inline">\((a*b)*c=a*(b*c)\)</span></li><li>幺元: 存在幺元<span class="math inline">\(e\)</span>, 使得对于任意<span class="math inline">\(a\in G\)</span>, <span class="math inline">\(e*a=a*e=a\)</span></li><li>逆元: 对于任意<span class="math inline">\(a\in G\)</span>，存在逆元<span class="math inline">\(a^{-1}\)</span>，使得<span class="math inline">\(a^{-1}*a=a*a^{-1}=e\)</span></li></ul><p>则称<span class="math inline">\((G, *)\)</span>是群，简称<span class="math inline">\(G\)</span>是群</p></li><li><p>如果仅满足封闭性和结合律, 则称<span class="math inline">\(G\)</span>是一个半群</p></li><li><p>如果仅满足封闭性, 结合律并且有幺元, 则称G是一个含幺半群</p></li></ul><p>再看下<code>Monoid</code>在Haskell中的定义</p><pre class="line-numbers language-haskell" data-language="haskell"><code class="language-haskell">class Monoid m where  
    mempty :: m              -- 常数, 表示幺元
    mappend :: m -&gt; m -&gt; m   -- 函数, 表示幺半群中的二元运算函数
    mconcat :: [m] -&gt; m      -- 函数, 将一堆Monoid&quot;压缩&quot;为一个
    mconcat &#x3D; foldr &#96;mappend&#96; mempty -- 缺省实现, 使用幺元作为起始, 使用二元运算合并<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>其中二元运算需要满足幺元与结合律, 即</p><ul><li><code>mempty `mappend` x = x</code></li><li><code>x `mappend` mempty = x</code></li><li><code>(x `mappend` y) `mappend` z = x `mappend` (y `mappend` z)</code></li></ul><p><strong>看看熟悉类型的<code>Monoids</code>是如何定义二元运算与幺元的</strong></p><ul><li><p><code>List</code></p><pre class="line-numbers language-haskell" data-language="haskell"><code class="language-haskell">instance Monoid [a] where  
    mempty &#x3D; []  
    mappend &#x3D; (++)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><ul><li>幺元为<code>[]</code></li><li>二元运算为<code>++</code></li></ul><p>例如</p><pre class="line-numbers language-haskell" data-language="haskell"><code class="language-haskell">ghci&gt; [1,2,3] &#96;mappend&#96; [4,5,6]  
-- [1,2,3,4,5,6]  
ghci&gt; (&quot;one&quot; &#96;mappend&#96; &quot;two&quot;) &#96;mappend&#96; &quot;tree&quot;  
-- &quot;onetwotree&quot;  
ghci&gt; &quot;one&quot; &#96;mappend&#96; (&quot;two&quot; &#96;mappend&#96; &quot;tree&quot;)  
-- &quot;onetwotree&quot;  
ghci&gt; &quot;one&quot; &#96;mappend&#96; &quot;two&quot; &#96;mappend&#96; &quot;tree&quot;  
-- &quot;onetwotree&quot;  
ghci&gt; &quot;pang&quot; &#96;mappend&#96; mempty  
-- &quot;pang&quot;  
ghci&gt; mconcat [[1,2],[3,6],[9]]  
-- [1,2,3,6,9]  
ghci&gt; mempty :: [a]  
-- []<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li><li><p>数集上的<code>*</code>与<code>+</code></p><p>Haskell定义了<code>Sum</code>与<code>Product</code></p><ul><li>幺元分别为<code>0</code>, <code>1</code></li><li>二元运算分别为<code>+</code>, <code>*</code></li></ul><pre class="line-numbers language-haskell" data-language="haskell"><code class="language-haskell">newtype Product a &#x3D;  Product &#123; getProduct :: a &#125;  
    deriving (Eq, Ord, Read, Show, Bounded)

instance Num a &#x3D;&gt; Monoid (Product a) where  
    mempty &#x3D; Product 1  
    Product x &#96;mappend&#96; Product y &#x3D; Product (x * y)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>例如</p><pre class="line-numbers language-haskell" data-language="haskell"><code class="language-haskell">ghci&gt; getProduct $ Product 3 &#96;mappend&#96; Product 9  
-- 27  
ghci&gt; getProduct $ Product 3 &#96;mappend&#96; mempty  
-- 3  
ghci&gt; getProduct $ Product 3 &#96;mappend&#96; Product 4 &#96;mappend&#96; Product 2  
-- 24  
ghci&gt; getProduct . mconcat . map Product $ [3,4,2]  
-- 24<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li><li><p><code>Any</code>与<code>All</code></p><p>类似于数学中的存在与任意</p><ul><li>幺元分别为<code>false</code>, <code>true</code></li><li>二元运算分别为<code>||</code>, <code>&amp;&amp;</code></li></ul><pre class="line-numbers language-haskell" data-language="haskell"><code class="language-haskell">newtype Any &#x3D; Any &#123; getAny :: Bool &#125;  
    deriving (Eq, Ord, Read, Show, Bounded)
    
instance Monoid Any where  
    mempty &#x3D; Any False  
    Any x &#96;mappend&#96; Any y &#x3D; Any (x || y)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-haskell" data-language="haskell"><code class="language-haskell">newtype All &#x3D; All &#123; getAll :: Bool &#125;  
        deriving (Eq, Ord, Read, Show, Bounded)

instance Monoid All where  
        mempty &#x3D; All True  
        All x &#96;mappend&#96; All y &#x3D; All (x &amp;&amp; y)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>例如</p><pre class="line-numbers language-haskell" data-language="haskell"><code class="language-haskell">ghci&gt; getAny $ Any True &#96;mappend&#96; Any False  
-- True  
ghci&gt; getAny $ mempty &#96;mappend&#96; Any True  
-- True  
ghci&gt; getAny . mconcat . map Any $ [False, False, False, True]  
-- True  
ghci&gt; getAny $ mempty &#96;mappend&#96; mempty  
-- False
ghci&gt; getAll $ mempty &#96;mappend&#96; All True  
-- True  
ghci&gt; getAll $ mempty &#96;mappend&#96; All False  
-- False  
ghci&gt; getAll . mconcat . map All $ [True, True, True]  
-- True  
ghci&gt; getAll . mconcat . map All $ [True, True, False]  
-- False<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li><li><p><code>Maybe</code></p><ul><li>幺元为<code>Nothing</code></li><li>二元运算见下</li></ul><pre class="line-numbers language-haskell" data-language="haskell"><code class="language-haskell">instance Monoid a &#x3D;&gt; Monoid (Maybe a) where  
    mempty &#x3D; Nothing  
    Nothing &#96;mappend&#96; m &#x3D; m  
    m &#96;mappend&#96; Nothing &#x3D; m  
    Just m1 &#96;mappend&#96; Just m2 &#x3D; Just (m1 &#96;mappend&#96; m2)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>例如</p><pre class="line-numbers language-haskell" data-language="haskell"><code class="language-haskell">ghci&gt; Nothing &#96;mappend&#96; Just &quot;andy&quot;  
-- Just &quot;andy&quot;  
ghci&gt; Just LT &#96;mappend&#96; Nothing  
-- Just LT  
ghci&gt; Just (Sum 3) &#96;mappend&#96; Just (Sum 4)  
-- Just (Sum &#123;getSum &#x3D; 7&#125;)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li></ul><p><strong>看看<code>Monoids</code>中的<code>mconcat</code>有什么用</strong></p><p>与<code>fmap</code>类似的使用方式, 其使用<code>fold*</code>调用, 只不过这个<code>fold*</code>并非preclude的<code>List.fold*</code>, 需要手动引入</p><pre class="line-numbers language-haskell" data-language="haskell"><code class="language-haskell">import qualified Foldable as F

ghci&gt; :t F.foldr  
-- F.foldr :: (F.Foldable t) &#x3D;&gt; (a -&gt; b -&gt; b) -&gt; b -&gt; t a -&gt; b<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>例如<code>Maybe</code>的<code>fold*</code></p><pre class="line-numbers language-haskell" data-language="haskell"><code class="language-haskell">ghci&gt; F.foldl (+) 2 (Just 9)  
-- 11  
ghci&gt; F.foldr (||) False (Just True)  
-- True<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>⚖<strong>最后: <code>Monad</code>实现应该遵循如下法则</strong></p><ul><li><code>retrun x &gt;&gt;= f</code>应该等于 <code>f x</code></li><li><code>m &gt;&gt;= return</code> 会等于 <code>m</code></li><li><code>(m &gt;&gt;= f) &gt;&gt;= g</code> 跟 <code>m &gt;&gt;= (\x -&gt; f x &gt;&gt;= g)</code> 是相等的</li></ul><h3 id="monad应用">Monad应用</h3><p><code>Monad</code>封装了高阶对象之间的计算与转换方式, 从而使高阶对象可以被轻易的用朴素的方法操作</p><h4 id="monad上的方法"><code>Monad</code>上的方法</h4><pre class="line-numbers language-haskell" data-language="haskell"><code class="language-haskell">class Monad m where  
    return :: a -&gt; m a  

    (&gt;&gt;&#x3D;) :: m a -&gt; (a -&gt; m b) -&gt; m b  

    (&gt;&gt;) :: m a -&gt; m b -&gt; m b  
    x &gt;&gt; y &#x3D; x &gt;&gt;&#x3D; \_ -&gt; y  

    fail :: String -&gt; m a  
    fail msg &#x3D; error msg<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li><code>return</code>与<code>Applicative</code>中的<code>pure</code>类似</li><li><code>&gt;&gt;=</code>函数,接受一个<code>Monad</code>与一个普通值到<code>Monad</code>的函数, 返回一个<code>Monad</code></li><li><code>&gt;&gt;</code>函数接受两个<code>Monad</code>, 返回后者</li><li><code>fail</code>接受一个<code>String</code>, 抛出一个异常</li></ul><p>看看<code>Maybe</code>的<code>Monad</code>实现</p><pre class="line-numbers language-haskell" data-language="haskell"><code class="language-haskell">instance Monad Maybe where  
    return x &#x3D; Just x  
    Nothing &gt;&gt;&#x3D; f &#x3D; Nothing  
    Just x &gt;&gt;&#x3D; f  &#x3D; f x  
    fail _ &#x3D; Nothing<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="维护两个数">维护两个数</h4><p>杆子两端有若干只鸟🐦, 当左右两端鸟数差小于等于2时, 杆子平衡, 否则杆子失衡. 给若干加减鸟的操作, 返回杆子状态</p><p>我们可以用<code>Maybe</code>的<code>Just</code>表示平衡状态, 用<code>Nothing</code>表示失衡</p><pre class="line-numbers language-haskell" data-language="haskell"><code class="language-haskell">type Birds &#x3D; Int  
type Pole &#x3D; (Birds,Birds)

landLeft :: Birds -&gt; Pole -&gt; Maybe Pole  
landLeft n (left,right)  
    | abs ((left + n) - right) &lt; 4 &#x3D; Just (left + n, right)  
    | otherwise                    &#x3D; Nothing  

landRight :: Birds -&gt; Pole -&gt; Maybe Pole  
landRight n (left,right)  
    | abs (left - (right + n)) &lt; 4 &#x3D; Just (left, right + n)  
    | otherwise                    &#x3D; Nothing<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>可以使用<code>&gt;&gt;=</code>连续调用函数⛓</p><pre class="line-numbers language-haskell" data-language="haskell"><code class="language-haskell">ghci&gt; return (0,0) &gt;&gt;&#x3D; landRight 2 &gt;&gt;&#x3D; landLeft 2 &gt;&gt;&#x3D; landRight 2  
-- Just (2,4)
ghci&gt; return (0,0) &gt;&gt;&#x3D; landLeft 1 &gt;&gt;&#x3D; landRight 4 &gt;&gt;&#x3D; landLeft (-1) &gt;&gt;&#x3D; landRight (-2)  
-- Nothing<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>可以使用<code>&gt;&gt;</code>直接设置状态</p><pre class="line-numbers language-haskell" data-language="haskell"><code class="language-haskell">ghci&gt; return (0,0) &gt;&gt;&#x3D; landLeft 1 &gt;&gt; Nothing &gt;&gt;&#x3D; landRight 1  
-- Nothing<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p><strong>看来<code>(&gt;&gt;=)</code>可以方便的实现一个<code>Monad</code>被多个函数调用, 而<code>&lt;$&gt; ... &lt;*&gt;</code>可以实现一个函数调用多个参数</strong></p><h4 id="do表示法"><code>do</code>表示法</h4><p>可以将<code>&gt;&gt;=</code>表达式链</p><pre class="line-numbers language-haskell" data-language="haskell"><code class="language-haskell">foo :: Maybe String  
foo &#x3D; Just 3   &gt;&gt;&#x3D; (\x -&gt; 
      Just &quot;!&quot; &gt;&gt;&#x3D; (\y -&gt; 
      Just (show x ++ y)))<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>用<code>do</code>语句表示</p><pre class="line-numbers language-haskell" data-language="haskell"><code class="language-haskell">foo :: Maybe String  
foo &#x3D; do  
    x &lt;- Just 3  
    y &lt;- Just &quot;!&quot;  
    Just (show x ++ y)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>看起来<code>do</code>就像是命令式变成的一个<code>Block</code>, 允许用户存一些变量进去, 再返回结果, 这里也要采用<code>&lt;-</code>将值从高阶对象中取出</p><p>的但是这个就比较离谱</p><pre class="line-numbers language-haskell" data-language="haskell"><code class="language-haskell">routine :: Maybe Pole
routine &#x3D; do
  start &lt;- return (0, 0)
  first &lt;- landLeft 2 start
  Nothing
  second &lt;- landRight 2 first
  final &lt;- landLeft 1 second
  return final<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>不论<code>return final</code>还是<code>start</code>, <code>first</code>, <code>second</code>都是<code>Nothing</code>...</p><p>当我们在 <code>do</code> 表示法写了一行运算，但没有用到 <code>&lt;-</code> 来绑定值的话，其实实际上就是用了 <code>&gt;&gt;</code>, 相当于设置了状态, 不是很理解</p><pre class="line-numbers language-haskell" data-language="haskell"><code class="language-haskell">routine :: [Int]
routine &#x3D; do
  start &lt;- return 1
  []
  return (start + 1)

-- []<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-haskell" data-language="haskell"><code class="language-haskell">routine :: Maybe [Int]
routine &#x3D; do
  start &lt;- return [1]
  Just [1,2,3,4,5,6]
  return (999:start)
  
-- Just [999,1]<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-haskell" data-language="haskell"><code class="language-haskell">main &#x3D; do
  start &lt;- getLine
  first &lt;- getLine
  return &quot;opps&quot;
  second &lt;- getLine
  print start

-- 1\n2\n3\n
-- 1<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="list的monad定义"><code>List</code>的<code>Monad</code>定义</h4><pre class="line-numbers language-haskell" data-language="haskell"><code class="language-haskell">instance Monad [] where  
    return x &#x3D; [x]  
    xs &gt;&gt;&#x3D; f &#x3D; concat (map f xs)  
    fail _ &#x3D; []<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>与<code>Applicative</code>有些区别, 例如</p><pre class="line-numbers language-haskell" data-language="haskell"><code class="language-haskell">ghci&gt; (*) &lt;$&gt; [1,2,3] &lt;*&gt; [10,100,1000]  
-- [10,100,1000,20,200,2000,30,300,3000]
ghci&gt; [3,4,5] &gt;&gt;&#x3D; \x -&gt; [x,-x]  
-- [3,-3,4,-4,5,-5]<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><h4 id="随机数">随机数</h4><p>在命令式编程中可以借助<code>random</code>类似的函数轻松实现随机数. 然而Haskell中函数都是纯函数, 这意味着每次<code>random</code>的结果都应该是定值😰, 为了解决这一问题, Haskell将<code>random</code>定义为了一个特别的类型</p><pre class="line-numbers language-haskell" data-language="haskell"><code class="language-haskell">random :: (RandomGen g, Random a) &#x3D;&gt; g -&gt; (a, g)<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>我们需要传入一个<code>RandomGen</code>然后获得一个随机数<code>a</code>与一个<code>RandomGen</code>. <code>RandomGen</code>像是一个生成器🧫, 通过同一个生成器调用<code>random</code>可以得到相同的结果. 每次<code>random</code>后我们可以获得一个全新的<code>RandomGen</code>用于下次<code>random</code>. 可以利用<code>mkStdGen</code>生成一个<code>RandomGen</code></p><pre class="line-numbers language-haskell" data-language="haskell"><code class="language-haskell">mkStdGen :: Int -&gt; StdGen
ghci&gt; random (mkStdGen 100)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>于是我们可以生成一些不同类型的<code>random</code></p><pre class="line-numbers language-haskell" data-language="haskell"><code class="language-haskell">ghci&gt; random (mkStdGen 949488) :: (Float, StdGen)
-- (0.8938442,1597344447 1655838864)
ghci&gt; random (mkStdGen 949488) :: (Bool, StdGen)
-- (False,1485632275 40692)
ghci&gt; random (mkStdGen 949488) :: (Integer, StdGen)
-- (1691547873,1597344447 1655838864)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>🪙生成三次投硬币的结果</p><pre class="line-numbers language-haskell" data-language="haskell"><code class="language-haskell">threeCoins :: StdGen -&gt; (Bool, Bool, Bool)
threeCoins gen &#x3D;
    let (firstCoin, newGen) &#x3D; random gen
    (secondCoin, newGen&#39;) &#x3D; random newGen
    (thirdCoin, newGen&#39;&#39;) &#x3D; random newGen&#39;
    in  (firstCoin, secondCoin, thirdCoin)
    

ghci&gt; threeCoins (mkStdGen 21)
-- (True,True,True)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>Haskell还提供<code>randomR</code>定义随机数上下界</p><pre class="line-numbers language-haskell" data-language="haskell"><code class="language-haskell">ghci&gt; randomR (1,6) (mkStdGen 359353)
-- (6,1494289578 40692)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>也提供了生成无限个有限随机数的<code>randomRs</code></p><pre class="line-numbers language-haskell" data-language="haskell"><code class="language-haskell">ghci&gt; take 10 $ randomRs (&#39;a&#39;,&#39;z&#39;) (mkStdGen 3) :: [Char]
-- &quot;ndkxbvmomg&quot;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><h4 id="bytestring">ByteString</h4><p>在读取大文件的时候<code>[Char]</code>的效率往往很低, 可以使用ByteString, 其每个元素都是一个<code>Byte</code>. 存在两个<code>ByteString</code></p><ul><li><code>strict</code>型: 位于<code>Data.ByteString</code>, 非惰性, 无<code>Thunk</code>, 保证了不会出现"over head"</li><li><code>Lazy</code>型: 位于<code>Data.ByteString.Lazy</code>, 保存在64K的chunks中(这似的其大概率可以被装入L2 Cache)</li></ul><p>其定义了方法</p><ul><li><p><code>pack :: [Word8] -&gt; ByteString</code></p><p>接受一个<code>Word8</code>数组, 返回<code>ByteString</code>, 其中<code>Word8</code>就是<code>0-255</code>的<code>Int</code></p><pre class="line-numbers language-haskell" data-language="haskell"><code class="language-haskell">import qualified Data.ByteString.Lazy as B
import qualified Data.ByteString as S

ghci&gt; B.pack [99,97,110]
-- Chunk &quot;can&quot; Empty
ghci&gt; B.pack [98..120]
-- Chunk &quot;bcdefghijklmnopqrstuvwx&quot; Empty<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li><li><p><code>unpack</code>与<code>pack</code>相反, 把一个<code>bytestring</code>变成一个<code>byte list</code></p></li><li><p><code>fromChunks</code>接受一串<code>strict</code>的<code>bytestrings</code>并把他变成一串<code>lazy bytestring</code></p></li><li><p><code>toChunks</code>接受一个<code>lazy bytestrings</code>并将他变成一串<code>strict bytestrings</code></p></li><li><p><code>ByteString</code>也支持<code>:</code>, 其中<code>B.empty</code>相当于<code>[]</code></p></li></ul><h4 id="write-monad"><code>Write Monad</code></h4><p>✍️我们希望维护一个状态, 并在每次apply函数的时候为其加上日志, 此时就可以使用<code>Write Monad</code></p><pre class="line-numbers language-haskell" data-language="haskell"><code class="language-haskell">instance (Monoid w) &#x3D;&gt; Monad (Writer w) where  
    return x &#x3D; Writer (x, mempty)  
    (Writer (x,v)) &gt;&gt;&#x3D; f &#x3D; let (Writer (y, v&#39;)) &#x3D; f x in Writer (y, v &#96;mappend&#96; v&#39;)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>例如</p><pre class="line-numbers language-haskell" data-language="haskell"><code class="language-haskell">import Control.Monad.Writer  

newtype Writer w a &#x3D; Writer &#123; runWriter :: (a, w) &#125;

logNumber :: Int -&gt; Writer [String] Int  
logNumber x &#x3D; Writer (x, [&quot;Got number: &quot; ++ show x])  

multWithLog :: Writer [String] Int  
multWithLog &#x3D; do  
    a &lt;- logNumber 3  
    b &lt;- logNumber 5  
    return (a*b)
    
-- ghci&gt; runWriter multWithLog  
-- (15,[&quot;Got number: 3&quot;,&quot;Got number: 5&quot;])<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>可以使用difference-lists提高写log的效率</strong></p><p>简单理解我们之前使用的List在执行<code>[1,2]++[3,4]</code>时是同步的, 但是<code>DiffList</code>在执行的时候是惰性的, 这保证了可以快速<code>++</code>, 只有在读取时才执行, 实现也很简单</p><pre class="line-numbers language-haskell" data-language="haskell"><code class="language-haskell">instance Monoid (DiffList a) where  
    mempty &#x3D; DiffList (\xs -&gt; [] ++ xs)  
    (DiffList f) &#96;mappend&#96; (DiffList g) &#x3D; DiffList (\xs -&gt; f (g xs))<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><h4 id="reader-monad"><code>Reader Monad</code></h4><p><code>Reader Monad</code>是将一个柯里化函数作为<code>Monad</code>对象</p><pre class="line-numbers language-haskell" data-language="haskell"><code class="language-haskell">instance Monad ((-&gt;) r) where  
    return x &#x3D; \_ -&gt; x  
    h &gt;&gt;&#x3D; f &#x3D; \w -&gt; f (h w) w<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><h4 id="state-monad"><code>State Monad</code></h4><p><code>State Monad</code>用于实现状态转换, 他保存了计算结果与下一次执行的state, 例如之前随机数就用到了<code>State Monad</code></p><pre class="line-numbers language-haskell" data-language="haskell"><code class="language-haskell">instance Monad (State s) where  
    return x &#x3D; State $ \s -&gt; (x,s)  
    (State h) &gt;&gt;&#x3D; f &#x3D; State $ \s -&gt; let (a, newState) &#x3D; h s  
                                        (State g) &#x3D; f a  
                                    in  g newState<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="error-monad"><code>Error Monad</code></h4><p>就是<code>Either</code>的<code>Monad</code>实现. 相比<code>Maybe</code>他可以记录错误信息</p><pre class="line-numbers language-haskell" data-language="haskell"><code class="language-haskell">instance (Error e) &#x3D;&gt; Monad (Either e) where  
    return x &#x3D; Right x   
    Right x &gt;&gt;&#x3D; f &#x3D; f x  
    Left err &gt;&gt;&#x3D; f &#x3D; Left err  
    fail msg &#x3D; Left (strMsg msg)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="其他monad方法">其他<code>Monad</code>方法</h4><ul><li><p><code>leftM</code>相当于<code>functor</code>的<code>fmap</code></p><pre class="line-numbers language-haskell" data-language="haskell"><code class="language-haskell">liftM :: (Monad m) &#x3D;&gt; (a -&gt; b) -&gt; m a -&gt; m b<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></li><li><p><code>join</code>相当于去掉一层包裹</p><pre class="line-numbers language-haskell" data-language="haskell"><code class="language-haskell">join :: (Monad m) &#x3D;&gt; m (m a) -&gt; m a<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><pre class="line-numbers language-haskell" data-language="haskell"><code class="language-haskell">ghci&gt; join (Just (Just 9))  
Just 9  
ghci&gt; join (Just Nothing)  
Nothing  
ghci&gt; join Nothing  
Nothing<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li><li><p><code>filterM</code>将一个<code>List</code>转换为合法的<code>Monad List</code></p><pre class="line-numbers language-haskell" data-language="haskell"><code class="language-haskell">filterM :: (Monad m) &#x3D;&gt; (a -&gt; m Bool) -&gt; [a] -&gt; m [a]<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></li><li><p><code>foldM</code>折叠一个<code>List</code>并转为<code>Monad</code></p><pre class="line-numbers language-haskell" data-language="haskell"><code class="language-haskell">foldM :: (Monad m) &#x3D;&gt; (a -&gt; b -&gt; m a) -&gt; a -&gt; [b] -&gt; m a<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>例如</p><pre class="line-numbers language-haskell" data-language="haskell"><code class="language-haskell">ghci&gt; foldl (\acc x -&gt; acc + x) 0 [2,8,3,1]  
-- 14<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre></li></ul><h3 id="用zippers保存状态">用Zippers保存状态</h3><p>Haskell的函数是纯函数式, 这意味着对函数传入相同的变量, 函数会有相同的输出, 但是有些时候我们也需要记录执行的状态📹(例如需要维护一个树, 然而当我锁定并修改子树后Haskell只能返回一个新子树, 不能修改原树), 这时可以定义一个<code>Zippers</code>数据结构保存状态🤐</p><h4 id="维护二叉搜索树">维护二叉搜索树</h4><p>之前定义过二叉搜索树</p><pre class="line-numbers language-haskell" data-language="haskell"><code class="language-haskell">data Tree a &#x3D; Empty | Node a (Tree a) (Tree a) deriving (Show)<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>检索树上元素时候需要向左/向右/向上走, 而纯函数的特性让我们只能定义这样的函数</p><pre class="line-numbers language-haskell" data-language="haskell"><code class="language-haskell">goLeft :: Tree a -&gt; Tree a<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>我们的函数只能返回一个树的子树, 这导致实现向上走是非常困难的🤦‍♂️. 同时, 如果专门存储原树, 我们将无法获取原树</p><pre class="line-numbers language-haskell" data-language="haskell"><code class="language-haskell">tree &#x3D; geLeft (Node 1 (Empty) (Empty))<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>此时<code>tree</code>是<code>Empty</code>, 但是原树是什么我们不知道. 我们需要将原树作为状态存储起来, 对于一棵树</p><pre class="mermaid">graph TB
 Root(Root_cur) --> L
 Root --> R</pre><p>当我们要将位置从Root转换到L时, 我们可以像之前Log一样把<code>Root</code>与<code>R</code>存储起来, 我们定义一个数据结构<code>Crumb</code>🥯, <code>LeftCrumb</code>表示其走向了L, 此时存储了<code>LeftCrumb Root (Tree R)</code>, 反之类似</p><pre class="line-numbers language-haskell" data-language="haskell"><code class="language-haskell">data Crumb a &#x3D; LeftCrumb a (Tree a) | RightCrumb a (Tree a) deriving (Show)<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>可以将状态们存储为<code>[Crumb]</code>, 用<code>Tuple</code>存储当前位置与状态, 最后得到了</p><pre class="line-numbers language-haskell" data-language="haskell"><code class="language-haskell">data Crumb a &#x3D; LeftCrumb a (Tree a) | RightCrumb a (Tree a) deriving (Show)
type Breadcrumbs a &#x3D; [Crumb a]

goLeft :: (Tree a, Breadcrumbs a) -&gt; (Tree a, Breadcrumbs a)
goLeft (Node x l r, bs) &#x3D; (l, LeftCrumb x r:bs)    -- 当前为左子树, root与右子树压入Breadcrumbs

goRight :: (Tree a, Breadcrumbs a) -&gt; (Tree a, Breadcrumbs a)  
goRight (Node x l r, bs) &#x3D; (r, RightCrumb x l:bs)

goUp :: (Tree a, Breadcrumbs a) -&gt; (Tree a, Breadcrumbs a)  
goUp (t, LeftCrumb x r:bs) &#x3D; (Node x t r, bs)    -- top的root做当前位置, 展开右子树
goUp (t, RightCrumb x l:bs) &#x3D; (Node x l t, bs)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>我们还, 可以为这样的存储模式起个别名</p><pre class="line-numbers language-haskell" data-language="haskell"><code class="language-haskell">type Zipper a &#x3D; (Tree a, Breadcrumbs a)<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>最后实现一下节点的维护操作</p><pre class="line-numbers language-haskell" data-language="haskell"><code class="language-haskell">modify :: (a -&gt; a) -&gt; Zipper a -&gt; Zipper a  
modify f (Node x l r, bs) &#x3D; (Node (f x) l r, bs)  
modify f (Empty, bs) &#x3D; (Empty, bs)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>操作</p><pre class="line-numbers language-haskell" data-language="haskell"><code class="language-haskell">x -: f &#x3D; f x
freeTree &#x3D; ...
-- 向左, 向右, 替换为P 
newFocus &#x3D; (freeTree,[]) -: goLeft -: goRight -: modify (\_ -&gt; &#39;P&#39;)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><h4 id="维护list">维护<code>List</code></h4><p>可以将一个List分为<code>cur</code>及其右边的<code>List</code>与<code>cur</code>左边的<code>List</code>的逆序</p><pre class="line-numbers language-haskell" data-language="haskell"><code class="language-haskell">goForward :: ListZipper a -&gt; ListZipper a  
goForward (x:xs, bs) &#x3D; (xs, x:bs)  

goBack :: ListZipper a -&gt; ListZipper a  
goBack (xs, b:bs) &#x3D; (b:xs, bs)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>例如</p><pre class="line-numbers language-haskell" data-language="haskell"><code class="language-haskell">ghci&gt; let xs &#x3D; [1,2,3,4]  
ghci&gt; goForward (xs,[])  
-- ([2,3,4],[1])  
ghci&gt; goForward ([2,3,4],[1])  
-- ([3,4],[2,1])  
ghci&gt; goForward ([3,4],[2,1])  
-- ([4],[3,2,1])  
ghci&gt; goBack ([4],[3,2,1])  
-- ([3,4],[2,1])<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="维护一个文件系统">维护一个文件系统</h4><p>📁一个文件系统就是一个多叉树, 树上有两种类型(文件与文件夹), 他们都有文件(夹)名, 文件夹中应该还包含一颗子树, 文件中应该包含文件中的数据</p><pre class="line-numbers language-haskell" data-language="haskell"><code class="language-haskell">import Data.List (break)  

type Name &#x3D; String  
type Data &#x3D; String  
-- 一个文件&#x2F;文件夹
data FSItem &#x3D; File Name Data | Folder Name [FSItem] deriving (Show)

-- 上层文件夹名 文件夹中该文件前面的文件 文件夹中该文件之后的文件
data FSCrumb &#x3D; FSCrumb Name [FSItem] [FSItem] deriving (Show)
type FSZipper &#x3D; (FSItem, [FSCrumb])

-- 向上走就是将他前后的文件和他合在一起
fsUp :: FSZipper -&gt; FSZipper  
fsUp (item, FSCrumb name ls rs:bs) &#x3D; (Folder name (ls ++ [item] ++ rs), bs)

-- 进入文件夹
fsTo :: Name -&gt; FSZipper -&gt; FSZipper  
fsTo name (Folder folderName items, bs) &#x3D;   
  let (ls, item:rs) &#x3D; break (nameIs name) items  
  in  (item, FSCrumb folderName ls rs:bs)  

-- 判断文件(夹)名
nameIs :: Name -&gt; FSItem -&gt; Bool  
nameIs name (Folder folderName _) &#x3D; name &#x3D;&#x3D; folderName  
nameIs name (File fileName _) &#x3D; name &#x3D;&#x3D; fileName

-- 重命名文件
fsRename :: Name -&gt; FSZipper -&gt; FSZipper  
fsRename newName (Folder name items, bs) &#x3D; (Folder newName items, bs)  
fsRename newName (File name dat, bs) &#x3D; (File newName dat, bs)

-- 新建文件
fsNewFile :: FSItem -&gt; FSZipper -&gt; FSZipper  
fsNewFile item (Folder folderName items, bs) &#x3D;   
    (Folder folderName (item:items), bs)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>例如</p><pre class="line-numbers language-haskell" data-language="haskell"><code class="language-haskell">-- myDisk &#x3D; ...

ghci&gt; let newFocus &#x3D; (myDisk,[]) -: fsTo &quot;pics&quot; -: fsTo &quot;skull_man(scary).bmp&quot;
ghci&gt; fst newFocus        -- 显示FSItem
-- File &quot;skull_man(scary).bmp&quot; &quot;Yikes!&quot;
ghci&gt; let newFocus2 &#x3D; (myDisk,[]) -: fsTo &quot;pics&quot; -: fsRename &quot;cspi&quot; -: fsUp<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>🧗<strong>最后, 注意考虑边界, 为我们的函数设置兜底条件, <code>Maybe</code>可以用于表示给出的动作是否合法</strong>, 例如:</p><pre class="line-numbers language-haskell" data-language="haskell"><code class="language-haskell">goUp :: Zipper a -&gt; Maybe (Zipper a)  
goUp (t, LeftCrumb x r:bs) &#x3D; Just (Node x t r, bs)  
goUp (t, RightCrumb x l:bs) &#x3D; Just (Node x l t, bs)  
goUp (_, []) &#x3D; Nothing<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><hr><p>参考资料:</p><ul><li><span class="exturl" data-url="aHR0cHM6Ly9sZWFybnlvdWFoYXNrZWxsLm1ubzIub3JnL3poLWNu">Haskell趣学指南<i class="fa fa-external-link-alt"></i></span></li><li><span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL3dpbnRlcmxhbmQxOTg5L21hZ2ljLWhhc2tlbGwv">魔力Haskell<i class="fa fa-external-link-alt"></i></span></li><li><span class="exturl" data-url="aHR0cHM6Ly93d3cuemhpaHUuY29tL3F1ZXN0aW9uLzQ1MDc3MzEzMS9hbnN3ZXIvMTgwNzMyMTExMA==">知乎 - 为什么国外大学计算机系本科生培养如此强调函数式编程?<i class="fa fa-external-link-alt"></i></span></li></ul></div><footer class="post-footer"><p class="post-end-coffee">-------- 本文结束 <i class="fa-solid fa-mug-hot"></i> 感谢阅读 --------</p><div class="popular-posts-header">相关文章</div><ul class="popular-posts"><li class="popular-posts-item"><div class="popular-posts-title"><a href="/article/常见的文件头格式/" rel="bookmark">常见的文件头格式</a></div></li></ul><script>let post_body = document.querySelector('.post-body');
  let theme_switch = document.getElementById('theme_switch');
  const theme = {};
  Object.defineProperty(theme, 'value', {
    set(v){
      post_body.setAttribute('theme', v);
      localStorage.setItem('md_theme', v);
      theme_switch.value = v;
    }
  })
  theme.value = localStorage.getItem('md_theme') || 'sneh';
  theme_switch.addEventListener('change',e=>theme.value = e.target.value)
  document.getElementById('theme_switch_wapper').classList.remove('hidden');</script><div class="reward-container"><div></div><button>赞赏</button><div class="post-reward"><div><img src="/images/wechatpay.png" alt="Liu Kairui 微信"> <span>微信</span></div><div><img src="/images/alipay.png" alt="Liu Kairui 支付宝"> <span>支付宝</span></div></div></div><div class="post-copyright"><ul><li class="post-copyright-author"><strong>本文作者： </strong>Liu Kairui</li><li class="post-copyright-link"><strong>本文链接：</strong> <a href="https://blog.liukairui.me/article/%E5%87%BD%E6%95%B0%E5%BC%8F%E7%BC%96%E7%A8%8BHaskell%E5%88%9D%E6%8E%A2/" title="函数式编程Haskell初探">https://blog.liukairui.me/article/函数式编程Haskell初探/</a></li><li class="post-copyright-license"><strong>版权声明： </strong>本博客所有文章除特别声明外，均采用 <span class="exturl" data-url="aHR0cHM6Ly9jcmVhdGl2ZWNvbW1vbnMub3JnL2xpY2Vuc2VzL2J5LW5jLXNhLzQuMC9kZWVkLnpo"><i class="fab fa-fw fa-creative-commons"></i>BY-NC-SA</span> 许可协议。转载请注明出处！</li></ul></div><div class="post-tags"><a href="/tags/%E7%9E%8E%E6%8A%98%E8%85%BE/" rel="tag"><i class="fa fa-tag"></i> 瞎折腾</a> <a href="/tags/%E5%87%BD%E6%95%B0%E5%BC%8F%E7%BC%96%E7%A8%8B/" rel="tag"><i class="fa fa-tag"></i> 函数式编程</a> <a href="/tags/Haskell/" rel="tag"><i class="fa fa-tag"></i> Haskell</a></div><div class="post-nav"><div class="post-nav-item"><a href="/article/JavaScript%E4%B8%A5%E6%A0%BC%E6%A8%A1%E5%BC%8F/" rel="prev" title="JavaScript严格模式"><i class="fa fa-chevron-left"></i> JavaScript严格模式</a></div><div class="post-nav-item"><a href="/article/%E6%95%B0%E7%91%9ECookie%E6%B7%B7%E6%B7%86%E6%98%AF%E5%A6%82%E4%BD%95%E5%B7%A5%E4%BD%9C%E7%9A%84/" rel="next" title="数瑞Cookie混淆是如何工作的">数瑞Cookie混淆是如何工作的 <i class="fa fa-chevron-right"></i></a></div></div></footer></article></div><div class="comments" id="valine-comments"></div></div></main><footer class="footer"><div class="footer-inner"><div class="copyright">&copy; 2019 – <span itemprop="copyrightYear">2022</span> <span class="with-love"><i class="fa fa-heart"></i> </span><span class="author" itemprop="copyrightHolder">Liu Kairui</span></div><div class="wordcount"><span class="post-meta-item"><span class="post-meta-item-icon"><i class="fa fa-chart-line"></i> </span><span>总字数：</span> <span title="总字数">1.4m</span></span></div><div class="busuanzi-count"><span class="post-meta-item" id="busuanzi_container_site_uv"><span class="post-meta-item-icon"><i class="fa fa-user"></i> </span><span class="site-uv" title="总访客量"><span id="busuanzi_value_site_uv"></span> </span></span><span class="post-meta-item" id="busuanzi_container_site_pv"><span class="post-meta-item-icon"><i class="fa fa-eye"></i> </span><span class="site-pv" title="总访问量"><span id="busuanzi_value_site_pv"></span></span></span></div><div class="powered-by">由 <span class="exturl" data-url="aHR0cHM6Ly9oZXhvLmlv">Hexo</span> & <span class="exturl" data-url="aHR0cHM6Ly90aGVtZS1uZXh0LmpzLm9yZy9taXN0Lw==">NexT.Mist</span> 强力驱动</div><div class="addthis_inline_share_toolbox"><script src="//s7.addthis.com/js/300/addthis_widget.js#pubid=ra-630c5bd30a606ba8" async></script></div><div id="time_and_count"></div><script src="https://cdn.jsdelivr.net/npm/moment@2.22.2/moment.min.js"></script><script src="https://cdn.jsdelivr.net/npm/moment-precise-range-plugin@1.3.0/moment-precise-range.min.js"></script><script>function timer() {
    var ages = moment.preciseDiff(moment(),moment(20201101,"YYYYMMDD"));
    ages = ages.replace(/years?/, "年");
    ages = ages.replace(/months?/, "月");
    ages = ages.replace(/days?/, "天");
    ages = ages.replace(/hours?/, "小时");
    ages = ages.replace(/minutes?/, "分");
    ages = ages.replace(/seconds?/, "秒");
    ages = ages.replace(/\d+/g, '<span class="daysCnt" style="color: #1890ff">$&</span>');
    div.innerHTML = `小站已悄悄运行了 ${ages}`;
    div.className="workDays";
  }
  let div = document.createElement("div");
  let time_and_count = document.getElementById("time_and_count");
  time_and_count.appendChild(div);
  timer();
  setInterval("timer()",1000)</script><script>let footer = document.querySelector('.footer-inner')

let wordCount = document.querySelector('.wordcount')
wordCount.innerHTML = wordCount.innerText.replace('：',': ').replace('m','M')
if(wordCount){
  time_and_count.appendChild(wordCount);
}

let busaunzi = document.querySelector('.busuanzi-count')
if(busaunzi){
  footer.appendChild(busaunzi);
}

let powerby = document.querySelector('.powered-by')
if(powerby){
  footer.appendChild(powerby);
}</script></div></footer><script src="https://cdnjs.cloudflare.com/ajax/libs/animejs/3.2.1/anime.min.js" integrity="sha256-XL2inqUJaslATFnHdJOi9GfQ60on8Wx1C2H8DYiN1xY=" crossorigin="anonymous"></script><script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.6.1/jquery.min.js" integrity="sha256-o88AwQnZB+VDvE9tvIXrMQaPlFFSUTR+nldQm1LuPXQ=" crossorigin="anonymous"></script><script src="https://cdnjs.cloudflare.com/ajax/libs/fancybox/3.5.7/jquery.fancybox.min.js" integrity="sha256-yt2kYMy0w8AbtF89WXb2P1rfjcP/HTHLT7097U8Y5b8=" crossorigin="anonymous"></script><script src="https://cdnjs.cloudflare.com/ajax/libs/pangu/4.0.7/pangu.min.js" integrity="sha256-j+yj56cdEY2CwkVtGyz18fNybFGpMGJ8JxG3GSyO2+I=" crossorigin="anonymous"></script><script src="/js/comments.js"></script><script src="/js/utils.js"></script><script src="/js/motion.js"></script><script src="/js/schemes/muse.js"></script><script src="/js/next-boot.js"></script><script src="https://cdnjs.cloudflare.com/ajax/libs/algoliasearch/4.14.2/algoliasearch-lite.umd.js" integrity="sha256-dImjLPUsG/6p3+i7gVKBiDM8EemJAhQ0VvkRK2pVsQY=" crossorigin="anonymous"></script><script src="https://cdnjs.cloudflare.com/ajax/libs/instantsearch.js/4.46.3/instantsearch.production.min.js" integrity="sha256-TDBtvQ4sIGgJS5bk8VOKto+yvrblCB/JxE/9odR5u+M=" crossorigin="anonymous"></script><script src="/js/third-party/search/algolia-search.js"></script><script class="next-config" data-name="pdf" type="application/json">{"object_url":{"url":"https://cdnjs.cloudflare.com/ajax/libs/pdfobject/2.2.8/pdfobject.min.js","integrity":"sha256-tu9j5pBilBQrWSDePOOajCUdz6hWsid/lBNzK4KgEPM="},"url":"/lib/pdf/web/viewer"}</script><script src="/js/third-party/tags/pdf.js"></script><script class="next-config" data-name="mermaid" type="application/json">{"enable":true,"theme":"forest","js":{"url":"https://cdnjs.cloudflare.com/ajax/libs/mermaid/9.1.7/mermaid.min.js","integrity":"sha256-G58AID1YoX5YaEtWfXSI0VLrZ6N4kvNvwg0BI8zUFxE="}}</script><script src="/js/third-party/tags/mermaid.js"></script><script src="/js/third-party/fancybox.js"></script><script src="/js/third-party/pace.js"></script><script async src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><script class="next-config" data-name="leancloud_visitors" type="application/json">{"enable":true,"app_id":"ABKlVtS4cyaWYEwunPyK3sXt-9Nh9j0Va","app_key":"xxGXdTTEGEVifs2TLB35844I","server_url":"https://abklvts4.lc-cn-e1-shared.com","security":false}</script><script src="/js/third-party/statistics/lean-analytics.js"></script><script class="next-config" data-name="enableMath" type="application/json">true</script><script class="next-config" data-name="mathjax" type="application/json">{"enable":true,"tags":"none","js":{"url":"https://cdnjs.cloudflare.com/ajax/libs/mathjax/3.2.2/es5/tex-mml-chtml.js","integrity":"sha256-MASABpB4tYktI2Oitl4t+78w/lyA+D7b/s9GEP0JOGI="}}</script><script src="/js/third-party/math/mathjax.js"></script><script src="https://cdnjs.cloudflare.com/ajax/libs/quicklink/2.3.0/quicklink.umd.js" integrity="sha256-yvJQOINiH9fWemHn0vCA5lsHWJaHs6/ZmO+1Ft04SvM=" crossorigin="anonymous"></script><script class="next-config" data-name="quicklink" type="application/json">{"enable":true,"home":false,"archive":false,"delay":true,"timeout":3000,"priority":true,"url":"https://blog.liukairui.me/article/%E5%87%BD%E6%95%B0%E5%BC%8F%E7%BC%96%E7%A8%8BHaskell%E5%88%9D%E6%8E%A2/"}</script><script src="/js/third-party/quicklink.js"></script><script src="https://unpkg.com/darkmode-js@1.5.7/lib/darkmode-js.min.js"></script><script>var options = {
  bottom: '71px',
  right: 'unset',
  left: '30px',
  time: '0s',
  mixColor: 'transparent',
  backgroundColor: 'transparent',
  buttonColorDark: '#222',
  buttonColorLight: '#222',
  saveInCookies: true,
  label: '',
  autoMatchOsTheme: true
}
const darkmode = new Darkmode(options);
window.darkmode = darkmode;
darkmode.showWidget();</script><script>NexT.utils.loadComments('#valine-comments', () => {
  NexT.utils.getScript('https://cdn.jsdelivr.net/npm/valine@1.4.14/dist/Valine.min.js', () => {
    new Valine(Object.assign({"enable":true,"appId":"ABKlVtS4cyaWYEwunPyK3sXt-9Nh9j0Va","appKey":"xxGXdTTEGEVifs2TLB35844I","serverURLs":"https://abklvts4.lc-cn-e1-shared.com","placeholder":"请开始你的表演","avatar":"identicon","meta":["nick","mail","link"],"pageSize":10,"lang":"zh-CN","visitor":false,"comment_count":true,"recordIP":true,"enableQQ":true,"requiredFields":[]}, {
      el: '#valine-comments',
      path: "/article/%E5%87%BD%E6%95%B0%E5%BC%8F%E7%BC%96%E7%A8%8BHaskell%E5%88%9D%E6%8E%A2/",
      serverURLs: "https://abklvts4.lc-cn-e1-shared.com"
    }));
  }, window.Valine);
});</script><script src="/live2dw/lib/L2Dwidget.min.js?094cbace49a39548bed64abff5988b05"></script><script>L2Dwidget.init({pluginRootPath:"live2dw/",pluginJsPath:"lib/",pluginModelPath:"assets/",tagMode:!1,log:!1,model:{jsonPath:"/live2dw/assets/hijiki.model.json"},display:{position:"right",width:150,height:300},mobile:{show:!1},react:{opacity:.7}})</script></body></html>