<!DOCTYPE html><html lang="zh-CN"><head><meta charset="UTF-8"><meta name="viewport" content="width=device-width"><meta name="theme-color" content="#222"><meta name="generator" content="Hexo 6.3.0"><link rel="preconnect" href="https://fonts.googleapis.com" crossorigin><link rel="preconnect" href="https://cdnjs.cloudflare.com" crossorigin><link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon.png"><link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32.png"><link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16.png"><link rel="mask-icon" href="/images/logo.svg" color="#222"><link rel="manifest" href="/images/manifest.json"><link rel="stylesheet" href="/css/main.css"><link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Lato:300,300italic,400,400italic,700,700italic%7CPT+Sans:300,300italic,400,400italic,700,700italic%7CFira+Code:300,300italic,400,400italic,700,700italic&display=swap&subset=latin,latin-ext"><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.2.0/css/all.min.css" integrity="sha256-AbA177XfpSnFEvgpYu1jMygiLabzPCJCRIBtR5jGc0k=" crossorigin="anonymous"><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/animate.css/3.1.1/animate.min.css" integrity="sha256-PR7ttpcvz8qrF57fur/yAx1qXMFJeJFiA6pSzWi0OIE=" crossorigin="anonymous"><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/fancybox/3.5.7/jquery.fancybox.min.css" integrity="sha256-Vzbj7sDDS/woiFS3uNKo8eIuni59rjyNGtXfstRzStA=" crossorigin="anonymous"><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/pace/1.2.4/themes/greem/pace-theme-minimal.css"><script src="https://cdnjs.cloudflare.com/ajax/libs/pace/1.2.4/pace.min.js" integrity="sha256-gqd7YTjg/BtfqWSwsJOvndl0Bxc8gFImLEkXQT8+qj0=" crossorigin="anonymous"></script><script class="next-config" data-name="main" type="application/json">{"hostname":"blog.liukairui.me","root":"/","images":"/images","scheme":"Mist","darkmode":false,"version":"8.13.1","exturl":true,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"width":320},"copycode":{"enable":true,"style":"flat"},"bookmark":{"enable":false,"color":"#222","save":"auto"},"mediumzoom":false,"lazyload":false,"pangu":true,"comments":{"style":"tabs","active":"valine","storage":true,"lazyload":false,"nav":null,"activeClass":"valine"},"stickytabs":false,"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"fadeInDown","post_body":"fadeInDown","coll_header":"fadeInLeft","sidebar":"fadeInUp"}},"prism":false,"i18n":{"placeholder":"æœç´¢...","empty":"æ²¡æœ‰æ‰¾åˆ°ä»»ä½•æœç´¢ç»“æœï¼š${query}","hits_time":"æ‰¾åˆ° ${hits} ä¸ªæœç´¢ç»“æœï¼ˆç”¨æ—¶ ${time} æ¯«ç§’ï¼‰","hits":"æ‰¾åˆ° ${hits} ä¸ªæœç´¢ç»“æœ"},"algolia":{"appID":"GPJGYFJZH3","apiKey":"594eec10fca5caccffae82e82d066310","indexName":"hexo","hits":{"per_page":10}}}</script><script src="/js/config.js"></script><meta name="description" content="è½¬å˜æ€ç»´ğŸ¤”. ä»æ€è€ƒHow(æ€ä¹ˆç¼–å†™æŒ‡ä»¤)åˆ°æ€è€ƒWhat(æˆ‘ä»¬è¦è§£å†³çš„é—®é¢˜æ˜¯ä»€ä¹ˆ). æœ€åˆæˆ‘ä»¥ä¸ºå‡½æ•°å¼ç¼–ç¨‹å°±æ˜¯æ€è€ƒå¦‚ä½•ç”¨å‡½æ•°(æ•°å­¦)çš„æ–¹å¼æè¿°é—®é¢˜. ä½†é€æ¸å‘ç°å‡½æ•°å¼ç¼–ç¨‹çš„é‡ç‚¹æ˜¯å¦‚ä½•æ“ä½œå‡½æ•°å»æè¿°å‡½æ•°. æ€»ä¹‹, ä»–å€¼å¾—ä¸€å­¦!ğŸ˜"><meta property="og:type" content="article"><meta property="og:title" content="å‡½æ•°å¼ç¼–ç¨‹Haskellåˆæ¢"><meta property="og:url" content="https://blog.liukairui.me/article/%E5%87%BD%E6%95%B0%E5%BC%8F%E7%BC%96%E7%A8%8BHaskell%E5%88%9D%E6%8E%A2/"><meta property="og:site_name" content="LiuKairui&#39;s Blog"><meta property="og:description" content="è½¬å˜æ€ç»´ğŸ¤”. ä»æ€è€ƒHow(æ€ä¹ˆç¼–å†™æŒ‡ä»¤)åˆ°æ€è€ƒWhat(æˆ‘ä»¬è¦è§£å†³çš„é—®é¢˜æ˜¯ä»€ä¹ˆ). æœ€åˆæˆ‘ä»¥ä¸ºå‡½æ•°å¼ç¼–ç¨‹å°±æ˜¯æ€è€ƒå¦‚ä½•ç”¨å‡½æ•°(æ•°å­¦)çš„æ–¹å¼æè¿°é—®é¢˜. ä½†é€æ¸å‘ç°å‡½æ•°å¼ç¼–ç¨‹çš„é‡ç‚¹æ˜¯å¦‚ä½•æ“ä½œå‡½æ•°å»æè¿°å‡½æ•°. æ€»ä¹‹, ä»–å€¼å¾—ä¸€å­¦!ğŸ˜"><meta property="og:locale" content="zh_CN"><meta property="article:published_time" content="2022-03-02T16:00:01.000Z"><meta property="article:modified_time" content="2022-04-08T08:17:13.143Z"><meta property="article:author" content="Liu Kairui"><meta property="article:tag" content="çæŠ˜è…¾"><meta property="article:tag" content="å‡½æ•°å¼ç¼–ç¨‹"><meta property="article:tag" content="Haskell"><meta name="twitter:card" content="summary"><link rel="canonical" href="https://blog.liukairui.me/article/%E5%87%BD%E6%95%B0%E5%BC%8F%E7%BC%96%E7%A8%8BHaskell%E5%88%9D%E6%8E%A2/"><script class="next-config" data-name="page" type="application/json">{"sidebar":"","isHome":false,"isPost":true,"lang":"zh-CN","comments":true,"permalink":"https://blog.liukairui.me/article/%E5%87%BD%E6%95%B0%E5%BC%8F%E7%BC%96%E7%A8%8BHaskell%E5%88%9D%E6%8E%A2/","path":"article/å‡½æ•°å¼ç¼–ç¨‹Haskellåˆæ¢/","title":"å‡½æ•°å¼ç¼–ç¨‹Haskellåˆæ¢"}</script><script class="next-config" data-name="calendar" type="application/json">""</script><title>å‡½æ•°å¼ç¼–ç¨‹Haskellåˆæ¢ | LiuKairui's Blog</title><script>var titleTime,OriginTitile=document.title;document.addEventListener("visibilitychange",function(){document.hidden?(document.title="æˆ‘ä»¬æ´»ç€æ˜¯ä¸ºäº†ä»€ä¹ˆ? | "+OriginTitile,clearTimeout(titleTime)):(document.title="æ•´ç‚¹è–¯æ¡ | "+OriginTitile,titleTime=setTimeout(function(){document.title=OriginTitile},2e3))})</script><noscript><link rel="stylesheet" href="/css/noscript.css"></noscript><link rel="alternate" href="/atom.xml" title="LiuKairui's Blog" type="application/atom+xml"><style>.darkmode--activated{--body-bg-color:#282828;--content-bg-color:#333;--card-bg-color:#555;--text-color:#ccc;--blockquote-color:#bbb;--link-color:#ccc;--link-hover-color:#eee;--brand-color:#ddd;--brand-hover-color:#ddd;--table-row-odd-bg-color:#282828;--table-row-hover-bg-color:#363636;--menu-item-bg-color:#555;--btn-default-bg:#222;--btn-default-color:#ccc;--btn-default-border-color:#555;--btn-default-hover-bg:#666;--btn-default-hover-color:#ccc;--btn-default-hover-border-color:#666;--highlight-background:#282b2e;--highlight-foreground:#a9b7c6;--highlight-gutter-background:#34393d;--highlight-gutter-foreground:#9ca9b6}.darkmode--activated img{opacity:.75}.darkmode--activated img:hover{opacity:.9}.darkmode--activated code{color:#69dbdc;background:0 0}button.darkmode-toggle{z-index:9999}.darkmode-ignore,img{display:flex!important}.beian img{display:inline-block!important}</style></head><body itemscope itemtype="http://schema.org/WebPage" class="use-motion"><div class="headband"></div><main class="main"><header class="header" itemscope itemtype="http://schema.org/WPHeader"><div class="header-inner"><div class="site-brand-container"><div class="site-nav-toggle"><div class="toggle" aria-label="åˆ‡æ¢å¯¼èˆªæ " role="button"><span class="toggle-line"></span> <span class="toggle-line"></span> <span class="toggle-line"></span></div></div><div class="site-meta"><a href="/" class="brand" rel="start"><i class="logo-line"></i><p class="site-title">LiuKairui's Blog</p><i class="logo-line"></i></a><p class="site-subtitle" itemprop="description">æ•´ç‚¹è–¯æ¡</p></div><div class="site-nav-right"><div class="toggle popup-trigger"><i class="fa fa-search fa-fw fa-lg"></i></div></div></div><nav class="site-nav"><ul class="main-menu menu"><li class="menu-item menu-item-home"><a href="/" rel="section"><i class="fa fa-home fa-fw"></i>é¦–é¡µ</a></li><li class="menu-item menu-item-categories"><a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>åˆ†ç±»</a></li><li class="menu-item menu-item-tags"><a href="/tags/" rel="section"><i class="fas fa-hashtag fa-fw"></i>æ ‡ç­¾</a></li><li class="menu-item menu-item-æ”¶è—å¤¹"><a href="/favorites/" rel="section"><i class="fab fa-gratipay fa-fw"></i>æ”¶è—å¤¹</a></li><li class="menu-item menu-item-ç•™è¨€æ¿"><a href="/messageBoard/" rel="section"><i class="fab fa-facebook-messenger fa-fw"></i>ç•™è¨€æ¿</a></li><li class="menu-item menu-item-é¡¹ç›®"><a href="/projects/" rel="section"><i class="fa fa-satellite fa-fw"></i>é¡¹ç›®</a></li><li class="menu-item menu-item-about"><a href="/about/" rel="section"><i class="fa fa-user fa-fw"></i>å…³äº</a></li><li class="menu-item menu-item-search"><a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>æœç´¢</a></li></ul></nav><div class="search-pop-overlay"><div class="popup search-popup"><div class="search-header"><span class="search-icon"><i class="fa fa-search"></i></span><div class="search-input-container"></div><span class="popup-btn-close" role="button"><i class="fa fa-times-circle"></i></span></div><div class="search-result-container"><div class="algolia-stats"><hr></div><div class="algolia-hits"></div><div class="algolia-pagination"></div></div></div></div><script async src="/js/wobblewindow.js"></script><script async>window.addEventListener("load",function(){768<window.innerWidth&&($("body>main>header").wobbleWindow({radius:50,movementTop:!1,movementLeft:!1,movementRight:!1,debug:!1}),$("body>footer").wobbleWindow({radius:50,movementBottom:!1,movementLeft:!1,movementRight:!1,debug:!1}))})</script></div><div class="toggle sidebar-toggle" role="button"><span class="toggle-line"></span> <span class="toggle-line"></span> <span class="toggle-line"></span></div><aside class="sidebar"><div class="sidebar-inner sidebar-nav-active sidebar-toc-active"><ul class="sidebar-nav"><li class="sidebar-nav-toc">æ–‡ç« ç›®å½•</li><li class="sidebar-nav-overview">ç«™ç‚¹æ¦‚è§ˆ</li></ul><div class="sidebar-panel-container"><div class="post-toc-wrap sidebar-panel"><div class="post-toc animated"><ol class="nav"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%AE%80%E4%BB%8B"><span class="nav-text">ç®€ä»‹</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%BC%98%E8%B5%B7"><span class="nav-text">ç¼˜èµ·</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%BB%80%E4%B9%88%E6%98%AFhaskell%E5%87%BD%E6%95%B0%E5%BC%8F%E7%BC%96%E7%A8%8B"><span class="nav-text">ä»€ä¹ˆæ˜¯Haskell&#x2F;å‡½æ•°å¼ç¼–ç¨‹</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE"><span class="nav-text">ç¯å¢ƒé…ç½®</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95"><span class="nav-text">åŸºç¡€è¯­æ³•</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E8%BF%90%E7%AE%97%E7%AC%A6"><span class="nav-text">è¿ç®—ç¬¦</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%87%BD%E6%95%B0%E8%B0%83%E7%94%A8"><span class="nav-text">å‡½æ•°è°ƒç”¨</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%87%BD%E6%95%B0%E7%BC%96%E5%86%99"><span class="nav-text">å‡½æ•°ç¼–å†™</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#list%E7%B1%BB%E5%9E%8B%E5%9F%BA%E7%A1%80"><span class="nav-text">Listç±»å‹åŸºç¡€</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#list%E7%9A%84range"><span class="nav-text">Listçš„Range</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#list%E7%9A%84comprehension"><span class="nav-text">Listçš„Comprehension</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#tuple%E7%B1%BB%E5%9E%8B%E5%9F%BA%E7%A1%80"><span class="nav-text">Tupleç±»å‹åŸºç¡€</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%B1%BB%E5%9E%8B%E4%B8%8E%E7%B1%BB%E5%9E%8B%E7%B1%BB"><span class="nav-text">ç±»å‹ä¸ç±»å‹ç±»</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%B1%BB%E5%9E%8Btypes"><span class="nav-text">ç±»å‹(Types)</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%B1%BB%E5%9E%8B%E5%8F%98%E9%87%8Ftype-variables%E4%B8%8E%E7%B1%BB%E5%9E%8B%E7%B1%BBtype-variables"><span class="nav-text">ç±»å‹å˜é‡(Type variables)ä¸ç±»å‹ç±»(Type variables)</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%87%BD%E6%95%B0"><span class="nav-text">å‡½æ•°</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%A8%A1%E5%BC%8F%E5%8C%B9%E9%85%8Dpattern-matching"><span class="nav-text">æ¨¡å¼åŒ¹é…(Pattern matching)</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#guards%E5%AE%88%E5%8D%AB"><span class="nav-text">Guards(å®ˆå«)</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#where%E7%BB%91%E5%AE%9A"><span class="nav-text">Whereç»‘å®š</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#let%E7%BB%91%E5%AE%9A"><span class="nav-text">Letç»‘å®š</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#case%E8%A1%A8%E8%BE%BE%E5%BC%8F"><span class="nav-text">Caseè¡¨è¾¾å¼</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%B0%86%E5%87%BD%E6%95%B0%E5%AE%9A%E4%B9%89%E4%B8%BA%E4%B8%AD%E7%BC%80%E5%87%BD%E6%95%B0"><span class="nav-text">å°†å‡½æ•°å®šä¹‰ä¸ºä¸­ç¼€å‡½æ•°</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%AE%9A%E4%B9%89%E5%87%BD%E6%95%B0%E7%9A%84%E7%BB%93%E5%90%88%E6%80%A7%E4%B8%8E%E4%BC%98%E5%85%88%E7%BA%A7"><span class="nav-text">å®šä¹‰å‡½æ•°çš„ç»“åˆæ€§ä¸ä¼˜å…ˆçº§</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%80%92%E5%BD%92"><span class="nav-text">é€’å½’</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%87%BD%E6%95%B0pro"><span class="nav-text">å‡½æ•°Pro</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%87%BD%E6%95%B0%E6%9F%AF%E9%87%8C%E5%8C%96%E4%B8%8E%E4%B8%8D%E5%85%A8%E8%B0%83%E7%94%A8"><span class="nav-text">å‡½æ•°æŸ¯é‡ŒåŒ–ä¸ä¸å…¨è°ƒç”¨</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E9%AB%98%E9%98%B6%E5%87%BD%E6%95%B0"><span class="nav-text">é«˜é˜¶å‡½æ•°</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#lambda%E5%87%BD%E6%95%B0"><span class="nav-text">Lambdaå‡½æ•°</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#mapfilterfoldscan"><span class="nav-text">map&amp;filter&amp;fold&amp;scan</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%B8%8E.%E8%B0%83%E7%94%A8"><span class="nav-text">$ä¸.è°ƒç”¨</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%A8%A1%E5%9D%97"><span class="nav-text">æ¨¡å—</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#data.list%E6%A8%A1%E5%9D%97"><span class="nav-text">Data.Listæ¨¡å—</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#data.char%E6%A8%A1%E5%9D%97"><span class="nav-text">Data.Charæ¨¡å—</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#data.map%E6%A8%A1%E5%9D%97"><span class="nav-text">Data.Mapæ¨¡å—</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#data.set-%E6%A8%A1%E5%9D%97"><span class="nav-text">Data.Set æ¨¡å—</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%A3%B0%E6%98%8E%E6%A8%A1%E5%9D%97"><span class="nav-text">å£°æ˜æ¨¡å—</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%A3%B0%E6%98%8E%E7%B1%BB%E5%9E%8B%E4%B8%8E%E7%B1%BB%E5%9E%8B%E7%B1%BB"><span class="nav-text">å£°æ˜ç±»å‹ä¸ç±»å‹ç±»</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%BB%A3%E6%95%B0%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B"><span class="nav-text">ä»£æ•°æ•°æ®ç±»å‹</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#record-syntax"><span class="nav-text">Record Syntax</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%B1%BB%E5%9E%8B%E5%8F%82%E6%95%B0"><span class="nav-text">ç±»å‹å‚æ•°</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E9%80%92%E5%BD%92%E5%AE%9A%E4%B9%89%E7%B1%BB%E5%9E%8B"><span class="nav-text">é€’å½’å®šä¹‰ç±»å‹</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%B1%BB%E5%9E%8B%E5%88%AB%E5%90%8D"><span class="nav-text">ç±»å‹åˆ«å</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%B4%BE%E7%94%9F"><span class="nav-text">æ´¾ç”Ÿ</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%AE%9A%E4%B9%89typeclasses"><span class="nav-text">å®šä¹‰TypeClasses</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#functor-typeclass"><span class="nav-text">Functor typeclass</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#kind"><span class="nav-text">Kind</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%BE%93%E5%85%A5%E4%B8%8E%E8%BE%93%E5%87%BA"><span class="nav-text">è¾“å…¥ä¸è¾“å‡º</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%9F%BA%E7%A1%80io%E5%87%BD%E6%95%B0"><span class="nav-text">åŸºç¡€IOå‡½æ•°</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%96%87%E4%BB%B6%E4%B8%8E%E5%AD%97%E7%AC%A6%E6%B5%81"><span class="nav-text">æ–‡ä»¶ä¸å­—ç¬¦æµ</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%91%BD%E4%BB%A4%E8%A1%8C%E5%8F%82%E6%95%B0"><span class="nav-text">å‘½ä»¤è¡Œå‚æ•°</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%87%BD%E6%95%B0%E5%BC%8F%E5%9C%B0%E8%A7%A3%E5%86%B3%E9%97%AE%E9%A2%98"><span class="nav-text">å‡½æ•°å¼åœ°è§£å†³é—®é¢˜</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%B1%82%E8%A7%A3%E9%80%86%E6%B3%A2%E5%85%B0%E8%A1%A8%E8%BE%BE%E5%BC%8F"><span class="nav-text">æ±‚è§£é€†æ³¢å…°è¡¨è¾¾å¼</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%9C%80%E7%9F%AD%E8%B7%AF%E6%90%9C%E7%B4%A2"><span class="nav-text">æœ€çŸ­è·¯æœç´¢</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BB%8Efunctor%E5%88%B0monoids"><span class="nav-text">ä»Functoråˆ°Monoids</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#functor%E6%98%AF%E4%BB%80%E4%B9%88"><span class="nav-text">Functoræ˜¯ä»€ä¹ˆ</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#applicative-functors"><span class="nav-text">Applicative Functors</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#newtype"><span class="nav-text">newtype</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#monoids"><span class="nav-text">Monoids</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#monad%E5%BA%94%E7%94%A8"><span class="nav-text">Monadåº”ç”¨</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#monad%E4%B8%8A%E7%9A%84%E6%96%B9%E6%B3%95"><span class="nav-text">Monadä¸Šçš„æ–¹æ³•</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%BB%B4%E6%8A%A4%E4%B8%A4%E4%B8%AA%E6%95%B0"><span class="nav-text">ç»´æŠ¤ä¸¤ä¸ªæ•°</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#do%E8%A1%A8%E7%A4%BA%E6%B3%95"><span class="nav-text">doè¡¨ç¤ºæ³•</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#list%E7%9A%84monad%E5%AE%9A%E4%B9%89"><span class="nav-text">Listçš„Monadå®šä¹‰</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E9%9A%8F%E6%9C%BA%E6%95%B0"><span class="nav-text">éšæœºæ•°</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#bytestring"><span class="nav-text">ByteString</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#write-monad"><span class="nav-text">Write Monad</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#reader-monad"><span class="nav-text">Reader Monad</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#state-monad"><span class="nav-text">State Monad</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#error-monad"><span class="nav-text">Error Monad</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%85%B6%E4%BB%96monad%E6%96%B9%E6%B3%95"><span class="nav-text">å…¶ä»–Monadæ–¹æ³•</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%94%A8zippers%E4%BF%9D%E5%AD%98%E7%8A%B6%E6%80%81"><span class="nav-text">ç”¨Zippersä¿å­˜çŠ¶æ€</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%BB%B4%E6%8A%A4%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91"><span class="nav-text">ç»´æŠ¤äºŒå‰æœç´¢æ ‘</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%BB%B4%E6%8A%A4list"><span class="nav-text">ç»´æŠ¤List</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%BB%B4%E6%8A%A4%E4%B8%80%E4%B8%AA%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F"><span class="nav-text">ç»´æŠ¤ä¸€ä¸ªæ–‡ä»¶ç³»ç»Ÿ</span></a></li></ol></li></ol></div></div><div class="site-overview-wrap sidebar-panel"><div class="site-author site-overview-item animated" itemprop="author" itemscope itemtype="http://schema.org/Person"><img class="site-author-image" itemprop="image" alt="Liu Kairui" src="/images/avatar.jpg"><p class="site-author-name" itemprop="name">Liu Kairui</p><div class="site-description" itemprop="description">LiuKairui's Personal Website</div></div><div class="site-state-wrap site-overview-item animated"><nav class="site-state"><div class="site-state-item site-state-posts"><a href="/archives/"><span class="site-state-item-count">49</span> <span class="site-state-item-name">æ—¥å¿—</span></a></div><div class="site-state-item site-state-categories"><a href="/categories/"><span class="site-state-item-count">27</span> <span class="site-state-item-name">åˆ†ç±»</span></a></div><div class="site-state-item site-state-tags"><a href="/tags/"><span class="site-state-item-count">61</span> <span class="site-state-item-name">æ ‡ç­¾</span></a></div></nav></div><div class="links-of-author site-overview-item animated"><span class="links-of-author-item"><span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL0thaXJ1aUxpdQ==" title="GitHub â†’ https:&#x2F;&#x2F;github.com&#x2F;KairuiLiu"><i class="fab fa-github fa-fw"></i>GitHub</span> </span><span class="links-of-author-item"><span class="exturl" data-url="bWFpbHRvOm1lQGxpdWthaXJ1aS5tZQ==" title="E-Mail â†’ mailto:me@liukairui.me"><i class="fa fa-envelope fa-fw"></i>E-Mail</span> </span><span class="links-of-author-item"><span class="exturl" data-url="aHR0cHM6Ly9xbS5xcS5jb20vY2dpLWJpbi9xbS9xcj9rPW9hZjNUb09sTjE3aHI1c0hWOThiVDhxeHNOWUdhdzVMJm5vdmVyaWZ5PTA=" title="QQ â†’ https:&#x2F;&#x2F;qm.qq.com&#x2F;cgi-bin&#x2F;qm&#x2F;qr?k&#x3D;oaf3ToOlN17hr5sHV98bT8qxsNYGaw5L&amp;noverify&#x3D;0"><i class="fab fa-qq fa-fw"></i>QQ</span> </span><span class="links-of-author-item"><a href="/atom.xml" title="RSS â†’ &#x2F;atom.xml"><i class="fa fa-rss fa-fw"></i>RSS</a> </span><span class="links-of-author-item"><span class="exturl" data-url="aHR0cHM6Ly9saXVrYWlydWkuYmxvZy5jc2RuLm5ldA==" title="CSDN â†’ https:&#x2F;&#x2F;liukairui.blog.csdn.net"><i class="fab fa-cuttlefish fa-fw"></i>CSDN</span> </span><span class="links-of-author-item"><span class="exturl" data-url="aHR0cDovL2xpdWthaXJ1aS5jYw==" title="å›½å†…ç«™ç‚¹ â†’ http:&#x2F;&#x2F;liukairui.cc"><i class="fa fa-globe fa-fw"></i>å›½å†…ç«™ç‚¹</span></span></div><div class="cc-license site-overview-item animated" itemprop="license"><span class="exturl cc-opacity" data-url="aHR0cHM6Ly9jcmVhdGl2ZWNvbW1vbnMub3JnL2xpY2Vuc2VzL2J5LW5jLXNhLzQuMC9kZWVkLnpo"><img src="https://cdnjs.cloudflare.com/ajax/libs/creativecommons-vocabulary/2020.11.3/assets/license_badges/small/by_nc_sa.svg" alt="Creative Commons"></span></div></div></div></div></aside><div class="sidebar-dimmer"></div></header><div class="back-to-top" role="button" aria-label="è¿”å›é¡¶éƒ¨"><i class="fa fa-arrow-up"></i> <span>0%</span></div><div class="reading-progress-bar"></div><noscript><div class="noscript-warning">Theme NexT works best with JavaScript enabled</div></noscript><div class="main-inner post posts-expand"><div class="post-block"><article itemscope itemtype="http://schema.org/Article" class="post-content" lang="zh-CN"><link itemprop="mainEntityOfPage" href="https://blog.liukairui.me/article/%E5%87%BD%E6%95%B0%E5%BC%8F%E7%BC%96%E7%A8%8BHaskell%E5%88%9D%E6%8E%A2/"><span hidden itemprop="author" itemscope itemtype="http://schema.org/Person"><meta itemprop="image" content="/images/avatar.jpg"><meta itemprop="name" content="Liu Kairui"></span><span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization"><meta itemprop="name" content="LiuKairui's Blog"><meta itemprop="description" content="LiuKairui's Personal Website"></span><span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork"><meta itemprop="name" content="å‡½æ•°å¼ç¼–ç¨‹Haskellåˆæ¢ | LiuKairui's Blog"><meta itemprop="description" content="è½¬å˜æ€ç»´ğŸ¤”. ä»æ€è€ƒHow(æ€ä¹ˆç¼–å†™æŒ‡ä»¤)åˆ°æ€è€ƒWhat(æˆ‘ä»¬è¦è§£å†³çš„é—®é¢˜æ˜¯ä»€ä¹ˆ). æœ€åˆæˆ‘ä»¥ä¸ºå‡½æ•°å¼ç¼–ç¨‹å°±æ˜¯æ€è€ƒå¦‚ä½•ç”¨å‡½æ•°(æ•°å­¦)çš„æ–¹å¼æè¿°é—®é¢˜. ä½†é€æ¸å‘ç°å‡½æ•°å¼ç¼–ç¨‹çš„é‡ç‚¹æ˜¯å¦‚ä½•æ“ä½œå‡½æ•°å»æè¿°å‡½æ•°. æ€»ä¹‹, ä»–å€¼å¾—ä¸€å­¦!ğŸ˜"></span><header class="post-header"><h1 class="post-title" itemprop="name headline">å‡½æ•°å¼ç¼–ç¨‹Haskellåˆæ¢</h1><div class="post-meta-container"><div class="post-meta"><span class="post-meta-item"><span class="post-meta-item-icon"><i class="far fa-calendar"></i> </span><span class="post-meta-item-text">å‘è¡¨äº</span> <time title="åˆ›å»ºæ—¶é—´ï¼š2022-03-03 00:00:01" itemprop="dateCreated datePublished" datetime="2022-03-03T00:00:01+08:00">2022-03-03</time> </span><span class="post-meta-item"><span class="post-meta-item-icon"><i class="far fa-folder"></i> </span><span class="post-meta-item-text">åˆ†ç±»äº</span> <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/%E7%9E%8E%E6%8A%98%E8%85%BE/" itemprop="url" rel="index"><span itemprop="name">çæŠ˜è…¾</span></a> </span>ï¼Œ <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/%E7%9E%8E%E6%8A%98%E8%85%BE/%E5%87%BD%E6%95%B0%E5%BC%8F%E7%BC%96%E7%A8%8B/" itemprop="url" rel="index"><span itemprop="name">å‡½æ•°å¼ç¼–ç¨‹</span></a> </span></span><span id="/article/%E5%87%BD%E6%95%B0%E5%BC%8F%E7%BC%96%E7%A8%8BHaskell%E5%88%9D%E6%8E%A2/" class="post-meta-item leancloud_visitors" data-flag-title="å‡½æ•°å¼ç¼–ç¨‹Haskellåˆæ¢" title="é˜…è¯»æ¬¡æ•°"><span class="post-meta-item-icon"><i class="far fa-eye"></i> </span><span class="post-meta-item-text">é˜…è¯»æ¬¡æ•°ï¼š</span> <span class="leancloud-visitors-count"></span> </span><span class="post-meta-item" title="é˜…è¯»æ¬¡æ•°" id="busuanzi_container_page_pv"><span class="post-meta-item-icon"><i class="far fa-eye"></i> </span><span class="post-meta-item-text">é˜…è¯»æ¬¡æ•°ï¼š</span> <span id="busuanzi_value_page_pv"></span> </span><span class="post-meta-item"><span class="post-meta-item-icon"><i class="far fa-comment"></i> </span><span class="post-meta-item-text">Valineï¼š</span> <a title="valine" href="/article/%E5%87%BD%E6%95%B0%E5%BC%8F%E7%BC%96%E7%A8%8BHaskell%E5%88%9D%E6%8E%A2/#valine-comments" itemprop="discussionUrl"><span class="post-comments-count valine-comment-count" data-xid="/article/%E5%87%BD%E6%95%B0%E5%BC%8F%E7%BC%96%E7%A8%8BHaskell%E5%88%9D%E6%8E%A2/" itemprop="commentCount"></span> </a></span><span class="post-meta-item theme_switch_wapper hidden" id="theme_switch_wapper"><span class="post-meta-item-icon"><i class="fa-brands fa-markdown"></i></span> <span class="post-meta-item-text">ä¸»é¢˜ï¼š </span><select name="theme_switch" id="theme_switch"><option>sneh</option><option>mo</option><option>with</option><option>next</option></select> </span><span class="post-meta-item" title="æœ¬æ–‡å­—æ•°"><span class="post-meta-item-icon"><i class="far fa-file-word"></i> </span><span class="post-meta-item-text">æœ¬æ–‡å­—æ•°ï¼š</span> <span>75k</span></span></div><div class="post-description">è½¬å˜æ€ç»´ğŸ¤”. ä»æ€è€ƒHow(æ€ä¹ˆç¼–å†™æŒ‡ä»¤)åˆ°æ€è€ƒWhat(æˆ‘ä»¬è¦è§£å†³çš„é—®é¢˜æ˜¯ä»€ä¹ˆ). æœ€åˆæˆ‘ä»¥ä¸ºå‡½æ•°å¼ç¼–ç¨‹å°±æ˜¯æ€è€ƒå¦‚ä½•ç”¨å‡½æ•°(æ•°å­¦)çš„æ–¹å¼æè¿°é—®é¢˜. ä½†é€æ¸å‘ç°å‡½æ•°å¼ç¼–ç¨‹çš„é‡ç‚¹æ˜¯å¦‚ä½•æ“ä½œå‡½æ•°å»æè¿°å‡½æ•°. æ€»ä¹‹, ä»–å€¼å¾—ä¸€å­¦!ğŸ˜</div></div></header><div class="post-body" itemprop="articleBody"><h3 id="ç®€ä»‹">ç®€ä»‹</h3><h4 id="ç¼˜èµ·">ç¼˜èµ·</h4><p>ğŸ¤”æƒ³æƒ³æœ¬ç§‘CSæ•™è‚²å¤§å¤šéƒ½æ•™çš„æ˜¯ä»€ä¹ˆ?</p><ul><li>ç®—æ³•: åœ¨ç»™ä½ ä¸€ä¸ªé—®é¢˜, è¦ä½ å°½<strong>å¿«</strong>ç®—å‡ºè§£.</li><li>æ•°æ®åº“: ç»™ä½ ä¸€äº›æ•°æ®, è¦ä½ <strong>å¿«</strong>é€Ÿå‚¨å­˜æŸ¥æ‰¾.</li><li>åˆ†å¸ƒå¼ç®—æ³•/GPUç¼–ç¨‹: ä¸€ä¸ªCPUä¸å¤Ÿç”¨, ç»™ä½ æ›´å¿«çš„ç¡¬ä»¶(é›†ç¾¤æˆ–è€…GPU), è¦ä½ æ›´<strong>å¿«</strong>ç®—å‡ºè§£</li><li>äººå·¥æ™ºèƒ½è¯¾: å†™å‡ºæŒ‡æ•°å¢é•¿çš„æœç´¢ç®—æ³•, ç„¶åå†ç”¨å‰ªæ, å­¦ä¹ ç­‰æ–¹æ³•<strong>åŠ é€Ÿ</strong>.</li><li>ä½“ç³»ç»“æ„è¯¾: æ˜¯åœ¨ç”¨ç”µè·¯é—¨é€ å‡ºæ›´<strong>å¿«</strong>çš„CPU.</li></ul><p>ä¸ºä»€ä¹ˆæˆ‘ä»¬ä¸€ä¸ªåŠ²å»ä¼˜åŒ–æœºå™¨, ç¨‹åºå‘˜éš¾é“ä¸é‡è¦å—? éšç€ä»£ç è§„æ¨¡çš„å¢å¤§, é‡æ„, è°ƒè¯•, æµ‹è¯•, APIè®¾è®¡å˜å¾—è¶Šæ¥è¶Šå¤æ‚. äºæ˜¯äººä»¬æå‡ºäº†å‡½æ•°å¼ç¼–ç¨‹. å‡½æ•°å¼ç¼–ç¨‹ä¸å…³å¿ƒä»£ç çš„é€»è¾‘æ‰§è¡Œé€Ÿåº¦(å¤æ‚åº¦). ç¨‹åºå‘˜åªè´Ÿè´£å°†é—®é¢˜æè¿°ç»™è®¡ç®—æœº, è€Œé€Ÿåº¦ä¼˜åŒ–åˆ™ä¸€å£æ°”äº¤ç»™è®¡ç®—æœºå¤„ç†.</p><p>âš ï¸<strong>æ³¨æ„</strong>: Haskellå¹¶æ²¡æœ‰åœ¨å·¥ä¸šç•Œæµè¡Œ. è¿™æ„å‘³ç€ä½ å¾ˆéš¾å°†Haskellåº”ç”¨äºå¤§å‹é¡¹ç›®(è™½ç„¶Haskellå…·æœ‰è¿™æ ·çš„èƒ½åŠ›)</p><h4 id="ä»€ä¹ˆæ˜¯haskellå‡½æ•°å¼ç¼–ç¨‹">ä»€ä¹ˆæ˜¯Haskell/å‡½æ•°å¼ç¼–ç¨‹</h4><p>ğŸ”¡Haskellæ˜¯ä¸€é—¨çº¯ç²¹å‡½æ•°å¼ç¼–ç¨‹è¯­è¨€</p><p><strong>ğŸå‡½æ•°å¼ä¸å‘½ä»¤å¼ç¼–ç¨‹å¯¹æ¯”</strong></p><ul><li><p>ğŸƒâ€â™‚ï¸æ‰§è¡Œæ“ä½œ:</p><ul><li>å‘½ä»¤å¼ç¼–ç¨‹: ç»™è®¡ç®—æœºä¸€ç³»åˆ—æŒ‡ä»¤, è®¡ç®—æœºæ ¹æ®æŒ‡ä»¤æ‰§è¡Œå˜é‡çŠ¶æ€å˜åŒ–. æœ€åå¾—åˆ°ç»“æœ</li><li>å‡½æ•°å¼ç¼–ç¨‹: å‘Šè¯‰è®¡ç®—æœºæˆ‘ä»¬éœ€è¦è§£å†³ä»€ä¹ˆæ ·çš„é—®é¢˜</li></ul><p>ä¾‹å¦‚: è·å–å­—ç¬¦ä¸²<span class="math inline">\(s\)</span>ä¸­çš„å¤§å†™å­—æ¯</p><ul><li>å‘½ä»¤å¼ç¼–ç¨‹: éå†<span class="math inline">\(s\)</span> - å¦‚æœå­—ç¬¦<span class="math inline">\(c\)</span>æ»¡è¶³<span class="math inline">\(&#39;A&#39; \leq c \leq &#39;Z&#39;\)</span> - å°†<span class="math inline">\(c\)</span>æ”¾å…¥æ•°ç»„<span class="math inline">\(res\)</span> - è¿”å›<span class="math inline">\(res\)</span></li><li>å‡½æ•°å¼ç¼–ç¨‹: æˆ‘è¦è·å¾—ä¸€ä¸ªå­—ç¬¦ä¸² - è¿™ä¸ªå­—ç¬¦ä¸²ä¸­çš„å­—ç¬¦æ¥è‡ª<span class="math inline">\(s\)</span> - åªæœ‰å¤§å†™å­—æ¯æ»¡è¶³è¦æ±‚ - å¤§å†™å­—æ¯æŒ‡çš„æ˜¯<span class="math inline">\({&#39;A&#39;, &#39;B&#39;,...,&#39;Z&#39;}\)</span></li></ul><p>ä¸éš¾å‘ç°, æˆ‘ä»¬å¯ä»¥å¾ˆéš¾å°†å‘½ä»¤å¼ç¼–ç¨‹ä¸­çš„è¯­å¥è½¬åŒ–ä¸ºæ•°å­¦å‡½æ•°(æ¯”å¦‚éå†çš„<code>for</code>å°±æ— æ³•è½¬æ¢ä¸ºå‡½æ•°), ä½†æ˜¯å¯ä»¥å¾ˆè½»æ˜“çš„å°†å‡½æ•°å¼ç¼–ç¨‹è¯­å¥çš„å†…å®¹è½¬åŒ–ä¸ºæ•°å­¦è¡¨è¾¾å¼ <span class="math display">\[ f(s) = \{x|x \in s , x \in Caps\} \ \ \ where\ Caps = \{&#39;A&#39;, &#39;B&#39;,...,&#39;Z&#39;\} \]</span> ä»–çš„Haskellè¡¨è¾¾å¼ä¹Ÿå¾ˆæ•°å­¦åŒ–(æš‚æ—¶çœ‹ä¸æ‡‚ä¹Ÿæ²¡æœ‰å¤§ç¢)</p><pre class="line-numbers language-haskell" data-language="haskell"><code class="language-haskell">f s &#x3D; [x|x&lt;-s, x &#96;elem&#96; [&#39;A&#39;..&#39;Z&#39;]]<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>å›å¤´æƒ³æƒ³, æˆ‘ä»¬ç»å¸¸æŠŠå‘½ä»¤å¼ç¼–ç¨‹è¯­å¥ä¸­çš„<code>function</code>ç§°ä½œ"å‡½æ•°". ä½†æ˜¯è¿™äº›"å‡½æ•°"å†…éƒ¨å´æ€»æ˜¯æœ‰æ•°å­¦å‡½æ•°æ— æ³•å®ç°çš„å†…å®¹(ä¾‹å¦‚å¾ªç¯, å˜é‡é‡å¤èµ‹å€¼). æ‰€å¹¸å‡½æ•°å¼ç¼–ç¨‹è§£å†³äº†è¿™ä¸ªé—®é¢˜</p></li><li><p>ğŸ™…å˜é‡ä¸å¸¸é‡</p><ul><li>å‘½ä»¤å¼ç¼–ç¨‹: å¸¸é‡ä¸€æ—¦å£°æ˜å°±æ— æ³•å˜åŒ–, è€Œå˜é‡å¯ä»¥éšæ—¶é‡æ–°èµ‹å€¼</li><li>å‡½æ•°å¼ç¼–ç¨‹: å˜é‡ä¸€æ—¦è¢«æŒ‡å®š, å°±ä¸å¯ä»¥æ›´æ”¹äº†. å‡½æ•°èƒ½åšçš„å”¯ä¸€äº‹æƒ…å°±æ˜¯åˆ©ç”¨å¼•æ•°è®¡ç®—ç»“æœ(æ¯•ç«Ÿæ•°å­¦å‡½æ•°ä¸­å¯æ²¡æœ‰é‡å¤èµ‹å€¼çš„æ“ä½œ, ä½†æ•°å­¦ä¸­å¯åˆ°å¤„éƒ½æ˜¯å¤åˆå‡½æ•°)</li></ul></li><li><p>ğŸ’Šå‰¯ä½œç”¨(side effect, å³æ”¹å˜éå‡½æ•°å†…éƒ¨çš„çŠ¶æ€)</p><ul><li>å‘½ä»¤å¼ç¼–ç¨‹: å‡½æ•°å¯èƒ½å­˜åœ¨å‰¯ä½œç”¨(ä¿®æ”¹å¤–éƒ¨å˜é‡å€¼)</li><li>å‡½æ•°å¼ç¼–ç¨‹: æ— å‰¯ä½œç”¨, ä¸”å‡½æ•°å¼ç¼–ç¨‹ä¸­çš„å‡½æ•°æ˜¯çº¯å‡½æ•°(å³: ä»¥åŒæ ·çš„å‚æ•°è°ƒç”¨åŒä¸€ä¸ªå‡½æ•°ä¸¤æ¬¡, å¾—åˆ°çš„ç»“æœä¸€å®šæ˜¯ç›¸åŒ)</li></ul></li><li><p>â±æƒ°æ€§æ±‚å€¼</p><ul><li><p>å‘½ä»¤å¼ç¼–ç¨‹: é™¤éä½¿ç”¨ç‰¹æ®Šæ•°æ®ç»“æ„, é»˜è®¤éæƒ°æ€§æ±‚å€¼, ä¾‹å¦‚åœ¨JSä¸­å†™ä¸‹</p><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript"><span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">3</span><span class="token punctuation">]</span><span class="token punctuation">.</span><span class="token function">map</span><span class="token punctuation">(</span><span class="token parameter">d</span><span class="token operator">=></span>d<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">map</span><span class="token punctuation">(</span><span class="token parameter">d</span><span class="token operator">=></span>d<span class="token operator">/</span><span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>è§£é‡Šå™¨ä¼šå¯¹æ•°ç»„éå†ä¸¤æ¬¡</p></li><li><p>å‡½æ•°å¼ç¼–ç¨‹: é»˜è®¤æƒ°æ€§æ±‚å€¼, ä¾‹å¦‚åœ¨Haskellä¸­å†™ä¸‹</p><pre class="line-numbers language-haskell" data-language="haskell"><code class="language-haskell">map (&#x2F;2) (map (+1) [1,2,3])<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>æ•°ç»„åªä¼šéå†ä¸€æ¬¡, å³æ¯ä¸€ä¸ªå…ƒç´ éƒ½è°ƒç”¨å‡½æ•°ä¸¤æ¬¡, æœ€åå¾—åˆ°ç»“æœ. å¥½åƒæœ‰ç‚¹é—®é¢˜: å¦‚æœæˆ‘æƒ³å®šä¹‰ä¸€ä¸ª<code>cnt</code>, å¹¶è®©<code>cnt</code>åœ¨æ¯æ¬¡æ‰§è¡ŒåŠ æ³•/ä¹˜æ³•çš„æ—¶å€™<code>+1</code>, æœ€ååŠ <code>cnt</code>åˆ°ç»“æœä¸Šå‘¢? å³</p><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript"><span class="token keyword">let</span> t <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">3</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
<span class="token keyword">let</span> cnt <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">let</span> i<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span> i<span class="token operator">&lt;</span>t<span class="token punctuation">.</span>length<span class="token punctuation">;</span>i<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>
    t<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token operator">+=</span><span class="token number">1</span><span class="token punctuation">;</span>cnt<span class="token operator">++</span><span class="token punctuation">;</span>
    t<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token operator">/=</span><span class="token number">2</span><span class="token punctuation">;</span>cnt<span class="token operator">++</span><span class="token punctuation">;</span>
    t<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token operator">+=</span>cnt<span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>Haskellçš„æƒ°æ€§æ±‚å€¼ä¼¼ä¹ä¼šè®©è¿™æ ·çš„å‡½æ•°æ— æ³•å®ç°? ä½†æ˜¯è¿˜è®°å¾—å‰¯ä½œç”¨å—, Haskellä¸­çš„å‡½æ•°éƒ½æ˜¯çº¯å‡½æ•°, çº¯å‡½æ•°çš„æ‰§è¡Œä¸èƒ½å¯¹å¤–éƒ¨äº§ç”Ÿå‰¯ä½œç”¨. ä¹Ÿæ­£æ˜¯å› ä¸ºå‡½æ•°éƒ½æ˜¯çº¯å‡½æ•°, æ‰€ä»¥æƒ°æ€§æ±‚å€¼æ—¶å€™å°†å…ƒç´ ç»å¸¸è¿ç»­å˜åŒ–å¹¶ä¸ä¼šé€ æˆç»“æœå­˜åœ¨å·®å¼‚.</p><p>æƒ°æ€§æ±‚å€¼çš„å¦ä¸€ä¸ªå¥½å¤„æ˜¯æˆ‘ä»¬å¯ä»¥å¤„ç†ä¸€ä¸ªæ— é™æ•°ç»„ä¾‹å¦‚: è·å–å‰10ä¸ªå¥‡æ•°</p><pre class="line-numbers language-haskell" data-language="haskell"><code class="language-haskell">[1..]           -- è·å–ä¸€ä¸ª[1,2,3...]çš„æ— é™æ•°ç»„
filter (odd) [1..]    -- è¿‡æ»¤å‡ºæ‰€æœ‰å¥‡æ•° [1,3,5..]
take 10 filter (odd) [1..]   -- å–å‰10é¡¹<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre></li></ul></li></ul><p><strong>ğŸš«Haskellæ˜¯é™æ€å¼ºç±»å‹è¯­è¨€</strong></p><ul><li>é™æ€ç±»å‹æ„å‘³ç€æˆ‘ä»¬éœ€è¦åœ¨è¿è¡Œå‰æ˜ç¡®æŒ‡å‡ºå˜é‡çš„ç±»å‹, åŒæ—¶Haskellæ”¯æŒç±»å‹æ¨å¯¼, è¿™æ„å‘³ç€æˆ‘ä»¬ä¸å¿…å‘Šè¯‰Haskellæ¯ä¸€ä¸ªå˜é‡çš„ç±»å‹(ä¾‹å¦‚Haskellä¼šè‡ªåŠ¨æ¨æ–­<code>a = 1+1</code>çš„<code>a</code>æ˜¯æ•°å€¼, åŒæ—¶ç”±äºHaskellä¸å¯é‡å¤èµ‹å€¼, açš„ç±»å‹ä¸ä¼šå†æœ‰å˜åŒ–)</li><li>å¼ºç±»å‹æ„å‘³ç€Haskellä¸ä¼šè‡ªåŠ¨è¿›è¡Œç±»å‹è½¬æ¢(é™¤äº†éƒ¨åˆ†è¯­æ³•ç³–)</li></ul><h4 id="ç¯å¢ƒé…ç½®">ç¯å¢ƒé…ç½®</h4><p>ğŸ› æœ€æ–¹ä¾¿çš„æ–¹æ³•å°±æ˜¯ä½¿ç”¨<code>Haskell Platform</code>, æ­¤ç¨‹åºåŒ…åŒ…å«</p><ul><li><span class="exturl" data-url="aHR0cHM6Ly93d3cuaGFza2VsbC5vcmcvZ2hjLw==">GHC<i class="fa fa-external-link-alt"></i></span>: Haskellç¼–è¯‘å™¨</li><li><span class="exturl" data-url="aHR0cHM6Ly9jYWJhbC5yZWFkdGhlZG9jcy5pby8=">cabal-install<i class="fa fa-external-link-alt"></i></span>: åŒ…ç®¡ç†å™¨</li><li><span class="exturl" data-url="aHR0cHM6Ly9kb2NzLmhhc2tlbGxzdGFjay5vcmcv">stack<i class="fa fa-external-link-alt"></i></span>: è·¨å¹³å°å¼€å‘å·¥å…·</li><li><span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL2hhc2tlbGwvaGFza2VsbC1sYW5ndWFnZS1zZXJ2ZXI=">haskell-language-server<i class="fa fa-external-link-alt"></i></span>: è¯­è¨€æ”¯æŒ</li></ul><p>å¯¹äº<code>archlinux</code>, ç”±äºGHCé‡‡ç”¨åŠ¨æ€é“¾æ¥, éœ€è¦å¢åŠ å‡ ä¸ªè½¯ä»¶</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">pacman -S ghc cabal-install stack haskell-language-server happy alex haskell-haddock-library<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>å¯¹äºVSCodeç”¨æˆ·</p><ul><li><span class="exturl" data-url="aHR0cHM6Ly9tYXJrZXRwbGFjZS52aXN1YWxzdHVkaW8uY29tL2l0ZW1zP2l0ZW1OYW1lPW1vZ2Vrby5oYXNrZWxsLWV4dGVuc2lvbi1wYWNr">Haskell Extension Pack<i class="fa fa-external-link-alt"></i></span></li><li><span class="exturl" data-url="aHR0cHM6Ly9tYXJrZXRwbGFjZS52aXN1YWxzdHVkaW8uY29tL2l0ZW1zP2l0ZW1OYW1lPWRyYW1mb3JldmVyLnZzY29kZS1naGMtc2ltcGxl">Simple GHC (Haskell) Integration<i class="fa fa-external-link-alt"></i></span></li><li><span class="exturl" data-url="aHR0cHM6Ly9tYXJrZXRwbGFjZS52aXN1YWxzdHVkaW8uY29tL2l0ZW1zP2l0ZW1OYW1lPXBob2l0eW5lLnBob2l0eW5lLXZzY29kZQ==">Haskell GHCi Debug Adapter Phoityne<i class="fa fa-external-link-alt"></i></span></li></ul><p>GHCåœ¨ç¼–è¯‘Haskellæ–‡ä»¶(<code>.hs</code>æ–‡ä»¶)çš„åŒæ—¶æä¾›äº†äº¤äº’æ¨¡å¼(ç±»ä¼¼Node, Python, è™½ç„¶ä»–æ˜¯ç¼–è¯‘å‹è¯­è¨€(è¿™é‡Œåº”è¯¥æ„Ÿè°¢çº¯å‡½æ•°çš„ç‰¹æ€§)), åªéœ€è¦ç»ˆç«¯è¾“å…¥<code>ghci</code>å³å¯è¿›å…¥äº¤äº’æ¨¡å¼. åœ¨äº¤äº’æ¨¡å¼ä¸­</p><pre class="line-numbers language-haskell" data-language="haskell"><code class="language-haskell">:l xx.hs    -- å¯ä»¥åŠ è½½xx.hsæ–‡ä»¶, å…¶ä¸­.hså¯ä»¥çœç•¥
:r          -- åˆ·æ–°å·²ç»åŠ è½½çš„æ–‡ä»¶<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><h3 id="åŸºç¡€è¯­æ³•">åŸºç¡€è¯­æ³•</h3><h4 id="è¿ç®—ç¬¦">è¿ç®—ç¬¦</h4><ul><li><p>æ•°å­¦è¿ç®—: <code>2 + 15</code>, <code>49 * 100</code>, <code>1892 - 1472</code>, <code>5 / 2</code>, <code>50 * (100 - 4999)</code></p><p>æ³¨æ„: <code>5 * -3</code>ä¼šæŠ¥é”™, å› ä¸º<strong>åœ¨Haskellä¸­å‡½æ•°æ˜¯ä¸€ç­‰å…¬æ°‘</strong>, è€Œ<code>*</code>æœ¬èº«å°±æ˜¯ä¸€ä¸ªäºŒå…ƒå‡½æ•°. Haskellä¼šå°†è¡¨è¾¾å¼è§£æä¸º<code>( 5 * - ) 3</code>, æ‰€ä»¥åº”è¯¥æ”¹ä¸º<code>5 * (-3)</code></p></li><li><p>Booleanè¿ç®—: <code>True</code>, <code>False</code>(å¿…é¡»å¤§å†™), <code>&amp;&amp;</code>, <code>||</code>, <code>not</code>, <code>==</code>, <code>/=</code>(å³<code>!=</code>)</p></li></ul><p>æ•°å­¦è¿ç®—ä¸Booleanè¿ç®—éƒ½ä¸æ”¯æŒé»˜è®¤ç±»å‹è½¬æ¢(æ•´æ•°æ”¯æŒé»˜è®¤è½¬æ¢ä¸ºå°æ•°)</p><h4 id="å‡½æ•°è°ƒç”¨">å‡½æ•°è°ƒç”¨</h4><ul><li><p>å‡½æ•°è°ƒç”¨: è°ƒç”¨æ–¹æ³•ä¸º<code>å‡½æ•°å å‚æ•°1 å‚æ•°2...</code>, çœ‹èµ·æ¥å¾ˆæ€ª, æ²¡æœ‰<code>()</code>, ä¹Ÿæ²¡æœ‰<code>,</code>åˆ†éš”. ä¾‹å¦‚</p><pre class="line-numbers language-haskell" data-language="haskell"><code class="language-haskell">succ 8                 -- è·å–8çš„åç»§, å³9
min 9 10               -- 8,9æœ€å°å€¼
max 9 10               -- 8,9æœ€å¤§å€¼
succ 9 + max 5 4 + 1   -- å‡½æ•°è°ƒç”¨å…·æœ‰æœ€é«˜ä¼˜å…ˆçº§, å³(succ 9) + (max 5 4) + 1<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre></li><li><p>ä¸­ç¼€å‡½æ•°: å¯¹äºäºŒå…ƒå‡½æ•°, æˆ‘ä»¬å¯ä»¥å°†<code>f x y</code>å†™æˆ<code>x `f` y</code>, æ³¨æ„, è¿™é‡Œçš„<code>`</code>, æ˜¯å¿…é¡»çš„. ä¾‹å¦‚</p><pre class="line-numbers language-haskell" data-language="haskell"><code class="language-haskell">2 &#96;min&#96; 4    -- å³ min 2 4
1 &#96;elem&#96; [2,3,1] -- å³elem 1 [2,3,1], å…¶ä¸­elem x xsè¿”å›xæ˜¯å¦åœ¨xsä¸­ <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre></li><li><p>å‡½æ•°è°ƒç”¨æ˜¯è‡ªå·¦å‘å³çš„</p></li></ul><h4 id="å‡½æ•°ç¼–å†™">å‡½æ•°ç¼–å†™</h4><ul><li><p>å‡½æ•°å®šä¹‰ä¸æ•°å­¦ä¸­çš„å‡½æ•°è¡¨è¾¾å¼å¾ˆç±»ä¼¼, ä¾‹å¦‚</p><ul><li><p>éœ€è¦å®šä¹‰è¡¨è¾¾å¼<span class="math inline">\(doubleMe(x) = x+x\)</span>, åªéœ€è¦</p><p><pre class="line-numbers language-haskell" data-language="haskell"><code class="language-haskell">doubleMe x &#x3D; x+x<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></p></li><li><p>éœ€è¦å®šä¹‰è¡¨è¾¾å¼<span class="math inline">\(doubleUs(x,y) = x+x+y+y\)</span>, åªéœ€è¦</p><p><pre class="line-numbers language-haskell" data-language="haskell"><code class="language-haskell">doubleUs x y &#x3D; x+x+y+y<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></p><p>å½“ç„¶, ä¹Ÿå¯ä»¥è°ƒç”¨å‡½æ•°</p><p><pre class="line-numbers language-haskell" data-language="haskell"><code class="language-haskell">doubleUs x y &#x3D; doubleMe x + doubleMe y<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></p></li></ul></li><li><p>å˜é‡å°±æ˜¯å¸¸å‡½æ•°(å› ä¸ºå˜é‡ä¸å¯ä¿®æ”¹å€¼, æ‰€ä»¥, å¯ä»¥åƒæ„å»ºå¸¸å‡½æ•°ä¸€æ ·æ„å»ºå˜é‡)</p><pre class="line-numbers language-haskell" data-language="haskell"><code class="language-haskell">testValue &#x3D; 12<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></li><li><p>æ— éœ€å…³å¿ƒ<strong>å‡½æ•°ä¹‹é—´</strong>çš„ä½ç½®, ä¾‹å¦‚</p><pre class="line-numbers language-haskell" data-language="haskell"><code class="language-haskell">doubleUs x y &#x3D; doubleMe x + doubleMe y
doubleMe x &#x3D; x + x
demoRes &#x3D; demoUs 1 2<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>å¹¶ä¸ä¼šæŠ¥é”™</p></li><li><p>æ¡ä»¶è¯­å¥If: <code>if-then-else</code>ç»“æ„, ä¾‹å¦‚</p><pre class="line-numbers language-haskell" data-language="haskell"><code class="language-haskell">doubleSmallNumber x &#x3D; if x &gt; 100
                      then x
                      else  x*2<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>æ”¯æŒå‹è¡Œä¹¦å†™</p></li><li><p>ä½¿ç”¨<code>_</code>è¡¨ç¤ºæˆ‘ä»¬ä¸å…³ç³»è¿™ä¸ªå˜é‡å–å€¼, ä¾‹å¦‚å®šä¹‰å‡½æ•° <span class="math display">\[ f(x,y,z) = x\\ g(x,y,z) = y\\ g(x,y,z) = z \]</span> Haskellè¡¨ç¤ºå°±æ˜¯</p><pre class="line-numbers language-haskell" data-language="haskell"><code class="language-haskell">f x _ _ &#x3D; x
g _ y _ &#x3D; y
h _ _ z &#x3D; z<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>è¿™å’ŒJSä¸­<code>_</code>è¡¨ç¤ºä¸å…³å¿ƒå˜é‡ä¸ä¸€æ ·, è¿™ä¸ªç”šè‡³å¯ä»¥é‡å</p></li><li><p>åœ¨Haskellä¸­ä½¿ç”¨<code>'</code>è¡¨ç¤ºç±»ä¼¼, ä½†æ˜¯ä¸åŒçš„å‡½æ•°, æ¯”å¦‚æˆ‘ä»¬æƒ³ä½¿ç”¨ä¸¤ç§æ–¹å¼å®ç°<span class="math inline">\(Fibonacci\)</span></p><pre class="line-numbers language-haskell" data-language="haskell"><code class="language-haskell">fib n &#x3D; if n&lt;&#x3D;2 then n else fib (n-1) + fib (n-2)<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>å¿½ç„¶æˆ‘ä»¬åˆæƒ³å®ç°ä¸€ä¸ª<span class="math inline">\(Fibonacci\)</span></p><pre class="line-numbers language-haskell" data-language="haskell"><code class="language-haskell">fib&#39; n &#x3D; if n&lt;&#x3D;3 then n else fib (n-1) + fib (n-2)<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>è¿™åªæ˜¯ä¸€ç§å‘½åä¹ æƒ¯, ä¸å¼ºåˆ¶, ä¹Ÿæ²¡æœ‰å…¶ä»–æ•ˆæœ</p></li></ul><h4 id="listç±»å‹åŸºç¡€">Listç±»å‹åŸºç¡€</h4><p>ğŸ“œè¿™é‡Œçš„Listå’ŒJS/Pythonçš„æ•°ç»„ç±»ä¼¼, æˆ‘å–œæ¬¢æŠŠä»–ä½œä¸º<strong>å¯é‡å¤æ— åºé›†åˆ</strong>ä½¿ç”¨.</p><ul><li><p>å£°æ˜ä¸€ä¸ªListå¾ˆç®€å•</p><p><pre class="line-numbers language-haskell" data-language="haskell"><code class="language-haskell">t &#x3D; [1,2,3]<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></p><p>âš ï¸Listä¸­çš„å…ƒç´ ç±»å‹å¿…é¡»ç›¸åŒ</p></li><li><p>å­—ç¬¦ä¸²å®é™…ä¸Šæ˜¯å­—ç¬¦Listçš„è¯­æ³•ç³–</p><p><pre class="line-numbers language-haskell" data-language="haskell"><code class="language-haskell">&quot;231&quot; &#x3D;&#x3D; [&#39;2&#39;,&#39;3&#39;,&#39;1&#39;]  -- True<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></p></li><li><p>å¯ä»¥ä½¿ç”¨<code>++</code>è¿ç®—åˆå¹¶List, ä¾‹å¦‚</p><p><pre class="line-numbers language-haskell" data-language="haskell"><code class="language-haskell">t &#x3D; [1,2,3] ++ [4,5,6]   -- [1,2,3,4,5,6]<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></p><p>âš ï¸å…¶å®ç°åŸç†æ˜¯éå†<code>++</code>å‰çš„æ•°ç»„å¹¶åˆå¹¶åˆ°åè€…, æ‰€ä»¥è¿™æ˜¯ä¸€ä¸ªä½æ•ˆè¿ç®—å­</p></li><li><p>å¯ä»¥ä½¿ç”¨<code>:</code>è¿ç®—ç¬¦å°†å…ƒç´ åŠ å…¥Listå¤´éƒ¨, ä¾‹å¦‚</p><p><pre class="line-numbers language-haskell" data-language="haskell"><code class="language-haskell">t &#x3D; 1:[2,3,4]    -- [1,2,3,4]<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></p><p>æ”¯æŒé“¾å¼è°ƒç”¨, ä¾‹å¦‚</p><p><pre class="line-numbers language-haskell" data-language="haskell"><code class="language-haskell">t &#x3D; 1:2:3:[4,5,6]   -- [1,2,3,4,5,6]<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></p></li><li><p>å¯ä»¥ä½¿ç”¨<code>!!</code>å–Listçš„æŸä¸€ä½</p><p><pre class="line-numbers language-haskell" data-language="haskell"><code class="language-haskell">t &#x3D; [1,2,3,4,5,6] !! 2   -- 3<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></p><p>âš ï¸è¶Šç•Œè®¿é—®ä¼šæŠ¥é”™</p></li><li><p>å–å€¼æ–¹æ³•</p><ul><li><p><code>head List</code>è¿”å›<strong>é¦–ä¸ª</strong>å…ƒç´ : <code>head [1,2,3]</code>ä¸º<code>1</code></p></li><li><p><code>tail List</code>è¿”å›<strong>éé¦–ä¸ª</strong>å…ƒç´ ä»¬: <code>tail [1,2,3]</code>ä¸º<code>[2,3]</code></p></li><li><p><code>last List</code>è¿”å›<strong>æœ€åä¸€ä¸ª</strong>å…ƒç´ : <code>last [1,2,3]</code>ä¸º<code>3</code></p></li><li><p><code>init List</code>è¿”å›<strong>éæœ€åä¸€ä¸ª</strong>å…ƒç´ : <code>init [1,2,3]</code>ä¸º<code>[1,2]</code></p><p>âš ï¸å¯¹ç©ºæ•°ç»„æ‰§è¡Œå‡ä¼šæŠ¥é”™</p></li></ul></li><li><p>å…¶ä»–æ–¹æ³•</p><ul><li><p><code>length List</code>è¿”å›æ•°ç»„é•¿åº¦: <code>length [1,2,3]</code>ä¸º<code>3</code></p></li><li><p><code>null List</code>è¿”å›æ˜¯å¦ä¸ºç©º: <code>null [1,2,3]</code> ä¸º <code>False</code></p></li><li><p><code>reverse List</code>åè½¬æ•°ç»„: <code>reverse [1,2,3]</code>ä¸º<code>[3,2,1]</code>, å¹¶ä¸ä¼šåè½¬åŸæ•°ç»„(å› ä¸ºçº¯å‡½æ•°)</p></li><li><p><code>take n List</code>è¿”å›å‰<code>n</code>çš„å…ƒç´ , è¶Šç•Œéƒ¨åˆ†ä¸è¿”å›, <code>n==0</code>è¿”å›<code>[]</code></p><pre class="line-numbers language-haskell" data-language="haskell"><code class="language-haskell">take 2  [1,2,3,4]  -- [1,2]
take 10 [1,2,3,4]  -- [1,2,3,4] 
take 0  [1,2,3,4]  -- [] 
take -1 [1,2,3,4]  -- Error!<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre></li><li><p><code>drop</code>ä¸<code>take</code>ç±»ä¼¼, ä½œç”¨ä¸ºåˆ é™¤å‰<code>n</code>ä¸ªå…ƒç´ </p></li><li><p><code>maximum List</code>è¿”å›æœ€å¤§å€¼: <code>maximum [1,9,2,3,4]</code>ä¸º<code>9</code></p></li><li><p><code>maximum List</code>è¿”å›æœ€å¤§å€¼: <code>minimum [8,4,2,1,5,6]</code>ä¸º<code>1</code></p></li><li><p><code>sum List</code>è¿”å›å’Œ: <code>sum [8,4,2,1,5,6]</code>ä¸º<code>26</code></p></li><li><p><code>product List</code>è¿”å›ç§¯: <code>product [8,4,2,1,5,6]</code>ä¸º<code>1920</code></p></li></ul></li><li><p><code>elem ele List</code>åˆ¤æ–­<code>ele</code>æ˜¯å¦åœ¨<code>List</code>ä¸­: <code>4 `elem` [3,4,5,6]</code>ä¸º<code>True</code></p></li></ul><h4 id="listçš„range">Listçš„Range</h4><p>ğŸ“œç±»ä¼¼äºPythonçš„Range, ä½†æ˜¯æ›´åŠ æ™ºèƒ½</p><pre class="line-numbers language-haskell" data-language="haskell"><code class="language-haskell">t &#x3D; [1..5]   -- [1,2,3,4,5]
t &#x3D; [&#39;a&#39;..&#39;f&#39;]  -- [&#39;a&#39;,&#39;b&#39;,&#39;c&#39;,&#39;d&#39;,&#39;e&#39;,&#39;f&#39;]
-- é»˜è®¤Stepä¸º1, è‡ªå®šä¹‰æ—¶éœ€è¦åˆ—å‰ä¸¤é¡¹
t &#x3D; [1,1.2..2]  --  [1.0,1.2,1.4,1.5999999999999999,1.7999999999999998,1.9999999999999998]
-- ä½†æ˜¯ç²¾åº¦å ªå¿§, å»ºè®®ä½¿ç”¨å…¶ä»–æ–¹æ³•(åé¢ä¼šæåˆ°)
t &#x3D; [1..]   -- [1,2,3..]å®šä¹‰æ— é™é•¿List
t &#x3D; [1,3..]   -- [1,3,5,7..]<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><code>repeat n</code>è¿”å›æ— é™ä¸ª<code>n</code>ç»„æˆçš„List(ç­‰ä»·äº<code>[n,n..]</code>)</p><pre class="line-numbers language-haskell" data-language="haskell"><code class="language-haskell">t &#x3D; repeat 5   -- [5,5,5,5...]<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>ä¸€èˆ¬æ­é…<code>take</code>ä½¿ç”¨</p><h4 id="listçš„comprehension">Listçš„Comprehension</h4><p>ğŸ”°éå¸¸ç±»ä¼¼äºé›†åˆçš„å®šä¹‰(è¿™ä¹Ÿæ˜¯æˆ‘æŠŠListå½“æ— åºå¯é‡é›†åˆçš„åŸå› )</p><p>å¯¹äºä¸€ä¸ªé›†åˆ <span class="math display">\[ S = \{ 2x | x \in \mathbb N , \sqrt{x} \in \{1,..,100\} \} \]</span> é¦–å…ˆä»–æ˜¯ä¸€ä¸ªList, æ‰€ä»¥åº”è¯¥åŒ…ç€<code>[]</code>, ä¹‹åæœ‰ä¸€ä¸ªç«–çº¿åˆ†éš”ç¬¦, å·¦è¾¹æ˜¯è¾“å‡ºå‡½æ•°(é›†åˆä¸­çš„ä»£è¡¨å…ƒç´ ), å³è¾¹æ˜¯çº¦æŸ, ä¾‹å¦‚<code>[x|æ¡ä»¶]</code>, æ¡ä»¶ä¸­<span class="math inline">\(\in\)</span>ä½¿ç”¨<code>&lt;-</code>è¡¨ç¤º, é‚£ä¹ˆåˆšåˆšé›†åˆå°±å¯ä»¥è¡¨ç¤ºä¸º<code>t = [ 2*x | x &lt;- [1..100], (sqrt x) `elem` [1..100]]</code></p><p>è¿˜å¯ä»¥ç»“åˆä¹‹å‰çš„å‡½æ•°ä¸<code>if</code>è¯­å¥, ä¾‹å¦‚:</p><p>å®šä¹‰<code>List</code>å®ƒèƒ½å¤Ÿä½¿<code>List</code>ä¸­æ‰€æœ‰å¤§äº 10 çš„å¥‡æ•°å˜ä¸º <code>"BANG"</code>ï¼Œå°äº 10 çš„å¥‡æ•°å˜ä¸º <code>"BOOM"</code>ï¼Œå…¶ä»–åˆ™ç»Ÿç»Ÿæ‰”æ‰</p><pre class="line-numbers language-haskell" data-language="haskell"><code class="language-haskell">boomBangs xs &#x3D; [ if x &lt; 10 then &quot;BOOM!&quot; else &quot;BANG!&quot; | x &lt;- xs, odd x]<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>åŒæ—¶æ”¯æŒåŒå¤šListä¸­å–å…ƒç´ </p><pre class="line-numbers language-haskell" data-language="haskell"><code class="language-haskell">[ x*y | x &lt;- [2,5,10], y &lt;- [8,10,11]]  --[16,20,22,40,50,55,80,100,110]<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>ğŸ¤”<strong>ä½¿ç”¨comprehensionçš„æ—¶å€™æ³¨æ„æ€è€ƒæ–¹å¼</strong>: æˆ‘éœ€è¦çš„Listæ˜¯ä»€ä¹ˆæ ·å­çš„, è€Œä¸æ˜¯Listæ˜¯æ€ä¹ˆç®—å‡ºæ¥çš„</p><h4 id="tupleç±»å‹åŸºç¡€">Tupleç±»å‹åŸºç¡€</h4><p>ğŸ“œè¿™é‡Œçš„Tupleå’ŒPythonçš„å…ƒç»„ç±»ä¼¼. ä¸Listä¸åŒçš„å°±æ˜¯: Tupleæ˜¯å®šé•¿çš„, å…¶ä¸­å¯ä»¥ä¸ºä»»æ„ä¸åŒæ•°æ®ç±»å‹(ä¾‹å¦‚<code>('a',1)</code>)</p><p>âš ï¸Tupleä¹Ÿæ˜¯æœ‰ç±»å‹çš„, è¿™æ„å‘³ç€è‹¥Listä¸­æœ‰Tuple, é‚£ä¹ˆæ‰€æœ‰çš„Tupleç±»å‹åº”è¯¥ç›¸åŒ(æ¯ä¸ªTupleçš„é•¿åº¦ç›¸åŒ, æ¯ä¸€ä¸ªä½ç½®çš„ç±»å‹ç›¸åŒ), å³</p><pre class="line-numbers language-haskell" data-language="haskell"><code class="language-haskell">[(1,2,3), (4,5,6)]   -- ğŸ‘
[(1,2,3), (4,5,True)]  -- ğŸ’©
[(1,2,3), (4,5)]   -- ğŸ’©
[(1,2), (4,5.0)]          -- ğŸ‘ åŒæ—¶ä½ å°†è·å¾—[(1,2.0), (4,5.0)]<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p><strong>æ–¹æ³•:</strong></p><ul><li><p><code>fst Tuple</code>è·å–<strong>äºŒå…ƒ</strong>Tupleçš„ç¬¬ä¸€ä¸ªå…ƒç´ , ä¸å¯ç”¨äºå…¶ä»–é•¿åº¦Tuple!</p></li><li><p><code>snd Tuple</code>è·å–<strong>äºŒå…ƒ</strong>Tupleçš„ç¬¬äºŒä¸ªå…ƒç´ , ä¸å¯ç”¨äºå…¶ä»–é•¿åº¦Tuple!</p></li><li><p><code>zip List List</code>è·å–ä¸€ä¸ªäº¤å‰é…å¯¹çš„Tuple List</p><pre class="line-numbers language-haskell" data-language="haskell"><code class="language-haskell">zip [1,2,3,4,5] [5,5,5,5,5]
-- [(1,5),(2,5),(3,5),(4,5),(5,5)]
zip [1 .. 5] [&quot;one&quot;, &quot;two&quot;, &quot;three&quot;, &quot;four&quot;, &quot;five&quot;]
-- [(1,&quot;one&quot;),(2,&quot;two&quot;),(3,&quot;three&quot;),(4,&quot;four&quot;),(5,&quot;five&quot;)]<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>è¿™ä¸ª<code>zip</code>å‡½æ•°ç¡®å®å¾ˆå½¢è±¡å•ŠğŸ˜‚, åŒæ—¶è‹¥ä¸¤ä¸ªListé•¿åº¦ä¸ä¸€æ ·çš„, åˆ™èˆå¼ƒé•¿å‡ºçš„éƒ¨åˆ†(æ‹‰æ‹‰é“¾çš„æ—¶å€™è¦æ˜¯ä¸¤è¾¹ä¸ä¸€æ ·é•¿ä¹Ÿåªèƒ½æ‹‰åˆ°è¾ƒçŸ­çš„ä½ç½®), è¿™ç§ç‰¹æ€§ä¸æƒ°æ€§æ±‚å€¼ç»„åˆå<code>zip</code>å°±å¯ä»¥å¤„ç†æ— é™æ•°ç»„äº†</p><pre class="line-numbers language-haskell" data-language="haskell"><code class="language-haskell">zip &quot;Karry&quot; [1..]
-- [(&#39;K&#39;,1),(&#39;a&#39;,2),(&#39;r&#39;,3),(&#39;r&#39;,4),(&#39;y&#39;,5)]<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre></li><li><p><code>zipWi1th f List List</code>: ä¸<code>zip</code>ç±»ä¼¼, å°†æ¯æ¬¡å–å¾—çš„ä¸¤ä¸ªå…ƒç´ è°ƒç”¨<code>f</code>å¹¶è¿”å›</p><pre class="line-numbers language-haskell" data-language="haskell"><code class="language-haskell">add x y &#x3D; x + y
zipWith add [1 .. 10] [1 .. 10]
-- [2,4,6,8,10,12,14,16,18,20]<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre></li></ul><p><strong>ğŸ˜†æœ‰è¶£çš„ä¾‹å­</strong>: è¿˜æ˜¯è¦æ³¨æ„æ€è€ƒæ–¹å¼</p><ul><li><p>æ‰€æœ‰ä¸‰è¾¹é•¿åº¦çš†ä¸ºæ•´æ•°ä¸”å°äºç­‰äº 10ï¼Œå‘¨é•¿ä¸º 24 çš„ä¸‰è§’å½¢</p><pre class="line-numbers language-haskell" data-language="haskell"><code class="language-haskell">triangles &#x3D; [ (a,b,c) | c &lt;- [1..10], b &lt;- [1..10], a &lt;- [1..10], a+b&gt;c, a+c&gt;b, b+c&gt;a]<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></li><li><p>ä¸‰è¾¹éƒ½å°äºç­‰äº 10 çš„ç›´è§’ä¸‰è§’å½¢(ä¸‰è¾¹æŒ‰é¡ºåºè¾“å‡º)</p><pre class="line-numbers language-haskell" data-language="haskell"><code class="language-haskell">triangles&#39; &#x3D; [ (a,b,c) | c &lt;- [1..10], b &lt;- [1..c], a &lt;- [1..b], a^2 + b^2 &#x3D;&#x3D; c^2]<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></li><li><p>å‘¨é•¿ä¸º24, ä¸‰è¾¹éƒ½å°äºç­‰äº 10 çš„ç›´è§’ä¸‰è§’å½¢</p><pre class="line-numbers language-haskell" data-language="haskell"><code class="language-haskell">triangles&#39;&#39; &#x3D; [ (a,b,c) | c &lt;- [1..10], b &lt;- [1..c], a &lt;- [1..b], a^2 + b^2 &#x3D;&#x3D; c^2, a+b+c &#x3D;&#x3D; 24]<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></li></ul><h3 id="ç±»å‹ä¸ç±»å‹ç±»">ç±»å‹ä¸ç±»å‹ç±»</h3><h4 id="ç±»å‹types">ç±»å‹(Types)</h4><p>Haskellæ˜¯é™æ€ç±»å‹è¯­è¨€ä¸”æ”¯æŒç±»å‹æ¨å¯¼. ä½†Haskellä¸æ”¯æŒéšå¼ç±»å‹è½¬æ¢(é™¤äº†Int-&gt;Float)</p><p>å¯ä»¥åœ¨<code>ghci</code>ä¸­ä½¿ç”¨<code>:t è¡¨è¾¾å¼</code>çš„æ–¹å¼è·å–ç±»å‹</p><pre class="line-numbers language-haskell" data-language="haskell"><code class="language-haskell">:t &#39;a&#39;     -- &#39;a&#39;::Char
:t True    -- True::Bool
:t &quot;HELLO!&quot;   -- &quot;HELLO&quot;::String
:t max    -- max :: Ord a &#x3D;&gt; a -&gt; a -&gt; a
:t [1,2,3]   -- [1,2,3] :: Num a &#x3D;&gt; [a]
:t 12.3    -- 12.3 :: Fractional p &#x3D;&gt; p
:t (True, 1)  -- (True, 1) :: Num b &#x3D;&gt; (Bool, b)
:t (&#x3D;&#x3D;)    -- (&#x3D;&#x3D;) :: Eq a &#x3D;&gt; a -&gt; a -&gt; Bool<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>ğŸ™„å¸¸è§çš„ç±»å‹æœ‰</p><ul><li><code>Int</code>: è¡¨ç¤º<span class="math inline">\(-2^{31} \sim 2^{31}-1\)</span>çš„æ•´æ•°</li><li><code>Integer</code>: è¡¨ç¤ºæ•´æ•°, æ— ç•Œ</li><li><code>Float</code>: å•ç²¾åº¦æµ®ç‚¹æ•°</li><li><code>Double</code>: åŒç²¾åº¦æµ®ç‚¹å‹</li><li><code>Bool</code>: å¸ƒå°”å‹, å–å€¼ä¸º<code>True</code>ä¸<code>False</code></li><li><code>Char</code>: å­—ç¬¦å‹, <code>String = [Char]</code>è¡¨ç¤ºå­—ç¬¦ä¸²</li></ul><p>ğŸ™„ç±»å‹è¡¨ç¤ºæ—¶çš„æœ¯è¯­</p><ul><li><p>ä½¿ç”¨å¤§å†™å­—æ¯å¼€å¤´è¡¨ç¤ºç±»å‹</p></li><li><p><code>::</code>è¡¨ç¤º"ç±»å‹ä¸º", ä¾‹å¦‚: "HELLO"çš„ç±»å‹ä¸ºString</p></li><li><p><code>[a]</code>è¡¨ç¤º<code>a</code>ç±»å‹çš„æ•°ç»„</p></li><li><p>å¯¹äºå‡½æ•°, å°†å‚æ•°ä¸è¿”å›å€¼ç±»å‹ä¾æ¬¡ä½¿ç”¨<code>-&gt;</code>è¿æ¥å³å¯, ä¾‹å¦‚</p><ul><li><p><code>a-&gt;b</code>è¡¨ç¤ºè¿™æ˜¯ä¸€ä¸ªå‡½æ•°, æ¥å—ä¸€ä¸ª<code>a</code>ç±»å‹çš„å‚æ•°, è¿”å›ä¸€ä¸ª<code>b</code>ç±»å‹å˜é‡</p></li><li><p><code>a-&gt;b-&gt;c-&gt;d</code>è¡¨ç¤ºè¿™æ˜¯ä¸€ä¸ªå‡½æ•°, æŒ‰é¡ºåºæ¥å—<code>a</code>,<code>b</code>, <code>c</code>ç±»å‹å˜é‡, è¿”å›<code>d</code>ç±»å‹å˜é‡</p></li></ul><p>å°†å‚æ•°ä¸è¿”å›å€¼ç±»å‹ç®€å•ç²—æš´çš„è¿æ¥åœ¨ä¸€èµ·çœ‹èµ·æ¥æœ‰ç‚¹"æ¬ è€ƒè™‘", å®é™…ä¸Š, è¿™æ ·çš„æ¨¡å¼åœ¨å‡½æ•°å¼ç¼–ç¨‹ä¸­ååˆ†ç¬¦åˆç›´è§‰</p><p>å½“å‡½æ•°å¯ä»¥æ¥å—å¤šç§ç±»å‹çš„å‚æ•°å¹¶è¿”å›ä¸åŒç±»å‹çš„ç±»å‹æ—¶, æˆ‘ä»¬ä¸€èˆ¬é‡‡ç”¨<code>a</code>, <code>b</code>, <code>c</code>...è¡¨ç¤ºæŸä¸€ç§ç±»å‹, è¿™ä¸å‘½ä»¤å¼è¯­è¨€ä¸­çš„<strong>å¤šæ€</strong>ç±»ä¼¼, ä¾‹å¦‚<code>reverse</code>å‡½æ•°: <code>[a] -&gt; [a]</code></p></li><li><p>è¿ç®—ç¬¦ä¹Ÿæ˜¯ä¸€ä¸ªå‡½æ•°, ä¾‹å¦‚<code>==</code>ç±»å‹å°±æ˜¯ä¸€ä¸ª<code>a-&gt;a-&gt;Bool</code>, ä¸è¿‡åœ¨è¿›è¡Œç±»å‹åˆ¤æ–­åº”è¯¥ä½¿ç”¨æ‹¬å·å°†è¿ç®—ç¬¦æ‹¬èµ·æ¥, å¦‚<code>:t (==)</code></p></li><li><p>Tupleçš„ç±»å‹æ˜¯æ¯ä¸€é¡¹çš„ç±»å‹ç»„æˆçš„Tuple</p></li><li><p>è‡³ä»Šæ²¡æœ‰è§£å†³çš„<code>=&gt;</code>è¡¨ç¤ºä»€ä¹ˆ, è¿™éœ€è¦ç±»å‹ç±»çš„çŸ¥è¯†</p></li></ul><h4 id="ç±»å‹å˜é‡type-variablesä¸ç±»å‹ç±»type-variables">ç±»å‹å˜é‡(Type variables)ä¸ç±»å‹ç±»(Type variables)</h4><p>ğŸå‰é¢æåˆ°, æˆ‘ä»¬å¯ä»¥é€šè¿‡ä½¿ç”¨<code>a</code>, <code>b</code>ç­‰å˜é‡è¡¨ç¤ºä»»æ„ç±»å‹, ä¾‹å¦‚<code>sum</code>å‡½æ•°è¡¨ç¤º<code>[a]-&gt;a</code>, æ­¤æ—¶çš„<code>a</code>å°±æ˜¯<strong>ç±»å‹å˜é‡</strong>, ä¾‹å¦‚</p><ul><li><code>fst</code>å‡½æ•°: <code>[a] -&gt; a</code></li><li><code>length</code>å‡½æ•°: <code>[a] -&gt; Int</code></li><li><code>div</code>å‡½æ•°: <code>a -&gt; a -&gt; a</code></li></ul><p>æ­¤æ—¶, <code>div</code>å‡½æ•°ä¼¼ä¹æœ‰ç‚¹é—®é¢˜, æˆ‘ä»¬åªç”¨<code>a</code>ä»£è¡¨äº†æŸä¸€ç§ç±»å‹, ä½†æ˜¯<code>Char</code>ç±»å‹èƒ½é™¤å—? æˆ‘ä»¬åº”è¯¥å°†ç±»å‹å˜é‡é™å®šåˆ°ä¸€å®šç±»å‹èŒƒå›´, ä¾‹å¦‚<code>div</code>å‡½æ•°çš„<code>a</code>åº”è¯¥æ˜¯ä¸€ä¸ªå¯è®¡ç®—ç±»å‹, ç”¨<code>:t</code>æ£€æŸ¥<code>div</code>å‡½æ•°</p><pre class="line-numbers language-haskell" data-language="haskell"><code class="language-haskell">ghci&gt; :t div
div :: (Integral a) &#x3D;&gt; a -&gt; a -&gt; a<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>è¿™é‡Œçš„<code>(Integral a)</code>ç”¨æ¥æè¿°<code>a</code>è¿™ä¸ªç±»å‹æ˜¯ä¸€ä¸ª<code>Integral</code>ç±»å‹ç±»(æ‹¬å·è¡¨ç¤ºçœç•¥). æ³¨æ„æè¿°: <strong>ç±»å‹å˜é‡<code>a</code>æ˜¯ä¸€ä¸ª<code>Intergral</code>ç±»å‹ç±»çš„ç±»å‹å˜é‡</strong>, åœ¨æè¿°ç»“æŸæ—¶å€™ä½¿ç”¨<code>=&gt;</code>é“¾æ¥ç±»å‹å£°æ˜</p><p>ğŸª†æœ‰ç‚¹å¥—å¨ƒçš„æ„æ€äº†. å°†è¿™äº›æœ¯è¯­ä¸å‘½ä»¤å¼ç¼–ç¨‹å¯¹åº”ä¸€ä¸‹.</p><ul><li><p>å‡½æ•°çš„å‚æ•°ä¸è¿”å›å€¼å¯èƒ½æ˜¯å¤šç§ç±»å‹çš„(<strong>å¯¹åº”å¤šæ€</strong>)</p></li><li><p>äºæ˜¯æˆ‘ä»¬å°†æ¯ç§ç±»å‹ç”¨ä¸åŒçš„ç±»å‹å˜é‡è¡¨ç¤º(<strong>å¯¹åº”æ¨¡æ¿, ç”¨ç±»å‹å˜é‡ä»£è¡¨æŸä¸€ä¸ªç±»</strong>)</p></li><li><p>ä¸ºäº†çº¦æŸç±»å‹å˜é‡, æˆ‘ä»¬æå‡ºäº†ç±»å‹ç±». é‚£ä»€ä¹ˆæ ·çš„ç±»å±äºæŸä¸ªç±»å‹ç±»å‘¢?</p><p><strong>å®Œæˆäº†ç±»å‹ç±»ä¸­å®šä¹‰çš„æˆå‘˜ä¸æ–¹æ³•çš„ç±»</strong>éƒ½å¯ä»¥å±äºç±»å‹ç±»(<strong>å¯¹åº”æ¥å£</strong>).</p></li></ul><p>ğŸŒ°çœ‹å‡ ä¸ªå¸¸è§çš„ä¾‹å­</p><ul><li><p><code>Eq</code>ç±»å‹ç±»è¡¨ç¤ºå¯ä»¥è¡¨ç¤ºç›¸ç­‰çš„ç±»å‹ç±». <code>Eq</code>ç±»å‹ç±»è¦æ±‚å®ç°<code>==</code>å‡½æ•°ä»¥ç”¨äºåˆ¤æ–­.</p><p>ä¾‹å¦‚<code>:t (==)</code>ç±»å‹ä¸º<code>(==) :: Eq a =&gt; a -&gt; a -&gt; Bool</code></p></li><li><p><code>Ord</code>ç±»å‹ç±»è¡¨ç¤ºå¯ä»¥æ¯”è¾ƒç±»å‹ç±», <code>Ord</code>ç±»å‹ç±»è¦æ±‚å®ç°<code>&lt;</code>, <code>&gt;</code>, <code>&lt;=</code>, <code>&gt;=</code>å‡½æ•°.</p><p><code>:t min</code>ç±»å‹ä¸º<code>min :: Ord a =&gt; a -&gt; a -&gt; a</code></p></li><li><p><code>Show</code>ç±»å‹ç±»è¡¨ç¤ºå¯ä»¥è½¬æ¢ä¸ºå­—ç¬¦ä¸²çš„ç±»å‹ç±», <code>Show</code>ç±»è¦æ±‚å®ç°<code>show</code>å‡½æ•°ç”¨äºè½¬æ¢ä¸ºå­—ç¬¦ä¸²</p><p>ä¾‹å¦‚: <code>:t show</code>ç±»å‹ä¸º<code>show :: Show a =&gt; a -&gt; String</code></p><p>ä¾‹å¦‚: <code>show 123</code>è¡¨ç¤º<code>"123"</code>, <code>show [1,2,3]</code>è¡¨ç¤º<code>"[1,2,3]"</code></p></li><li><p><code>Read</code>ç±»å‹ä¸<code>Show</code>ç±»å‹ç›¸å. <code>read</code>å‡½æ•°å¯ä»¥å°†å­—ç¬¦ä¸²è½¬æ¢ä¸º<code>Read</code>ç±»å‹ç±»çš„æˆå‘˜</p><p>ä¾‹å¦‚: <code>:t read</code>ç±»å‹ä¸º<code>read :: Read a =&gt; String -&gt; a</code></p><p>ä½†æ˜¯: å°†<code>String</code>è½¬æ¢ä¸º<code>Read</code>ç±»å‹ç±»ä¸­å“ªä¸ªç±»å‹å‘¢, æ¯”å¦‚"True"åº”è¯¥è½¬æ¢ä¸ºå­—ç¬¦ä¸²è¿˜æ˜¯å¸ƒå°”å‘¢</p><ul><li>å¯ä»¥ä½¿ç”¨Haskellè‡ªå¸¦çš„ç±»å‹æ¨å¯¼: <code>read "123" + 1</code>å¾—åˆ°<code>124</code></li><li>å¯ä»¥ä½¿ç”¨Haskellç±»å‹å£°æ˜æ‰‹åŠ¨æŒ‡å®š: <code>read "123" :: Float</code>å¾—åˆ°<code>123.0</code></li></ul></li><li><p><code>Enum</code>ç±»å‹ç±»çš„æˆå‘˜éƒ½æ˜¯å¯æšä¸¾çš„. å…¶æˆå‘˜å®ç°äº†<code>succ</code>(åç»§å­)ä¸<code>pred</code>(å‰ç»§å­)æ–¹æ³•. <code>Bool</code>, <code>Char</code>, <code>Ordering</code>, <code>Int</code>, <code>Integer</code>, <code>Float</code>, <code>Double</code>ç±»å‹éƒ½æœ¯è¯­è¯¥ç±»å‹ç±»</p><p>ä¾‹å¦‚: <code>:t succ</code>ç±»å‹ä¸º<code>succ :: Enum a =&gt; a -&gt; a</code></p></li><li><p><code>Bounded</code>ç±»å‹ç±»çš„æˆå‘˜éƒ½æœ‰ä¸Šé™ä¸ä¸‹é™</p><ul><li><code>:t minBound</code>ç±»å‹ä¸º<code>minBound :: Bounded a =&gt; a</code>, ä¾‹å¦‚: <code>minBound :: Int</code>ä¸º<code>-9223372036854775808</code></li><li><code>:t maxBound</code>ç±»å‹ä¸º<code>maxBound :: Bounded a =&gt; a</code></li></ul></li><li><p><code>Num</code>ä¸ºæ•°å­—ç±»å‹ç±»</p></li><li><p><code>Integral</code>: è¡¨ç¤ºæ•´æ•°, åŒ…å«<code>Int</code> å’Œ <code>Integer</code></p><p>å½“æˆ‘ä»¬æƒ³æ˜¾å¼å°†<code>Integral</code>è½¬åŒ–ä¸º<code>Num</code>æ—¶, å¯ä»¥ä½¿ç”¨<code>fromIntegral</code>å‡½æ•°</p><p>âš ï¸<code>Integer</code>ä¸<code>Integral</code>åŒºåˆ«</p></li><li><p><code>Floating</code>: è¡¨ç¤ºæµ®ç‚¹æ•°, åŒ…å«<code>Float</code> å’Œ <code>Double</code></p></li></ul><p>âš ï¸å¦‚æœä¸€ä¸ªç±»å‹å±äºå¤šä¸ªç±»å‹ç±»å¯ä»¥è¿™æ ·å†™</p><h3 id="å‡½æ•°">å‡½æ•°</h3><p>Haskellæœ‰ä¸€å¥—ç‹¬ç‰¹çš„å‡½æ•°è¯­æ³•</p><h4 id="æ¨¡å¼åŒ¹é…pattern-matching">æ¨¡å¼åŒ¹é…(Pattern matching)</h4><p>æ¨¡å¼åŒ¹é…é€šè¿‡æ£€æŸ¥æ•°æ®çš„ç‰¹å®šç»“æ„æ¥æ£€æŸ¥å…¶æ˜¯å¦åŒ¹é…ï¼Œå¹¶æŒ‰æ¨¡å¼ä»ä¸­å–å¾—æ•°æ®. è¿™åœ¨å‡½æ•°å®šä¹‰ä¸­å¾ˆå¸¸ç”¨</p><p>ğŸ‘‚å¬èµ·æ¥å’Œå­—ç¬¦ä¸²æ­£åˆ™åŒ¹é…å¾ˆåƒ. åœ¨å®šä¹‰å‡½æ•°æ—¶å¯ä»¥è¿™æ ·å†™</p><pre class="line-numbers language-haskell" data-language="haskell"><code class="language-haskell">lucky :: (Integral a) &#x3D;&gt; a -&gt; String  
lucky 7 &#x3D; &quot;LUCKY NUMBER SEVEN!&quot;  
lucky x &#x3D; &quot;Sorry, you&#39;re out of luck, pal!&quot;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>åœ¨è°ƒç”¨ <code>lucky</code> æ—¶, æ¨¡å¼ä¼šä»<strong>ä¸Šè‡³ä¸‹è¿›è¡Œæ£€æŸ¥, ä¸€æ—¦æœ‰åŒ¹é…, é‚£å¯¹åº”çš„å‡½æ•°ä½“å°±è¢«åº”ç”¨äº†</strong>. è¿™ä¸ªæ¨¡å¼ä¸­çš„å”¯ä¸€åŒ¹é…æ˜¯å‚æ•°ä¸º<code>7</code>ï¼Œå¦‚æœä¸æ˜¯<code>7</code>ï¼Œå°±è½¬åˆ°ä¸‹ä¸€ä¸ªæ¨¡å¼ï¼Œå®ƒåŒ¹é…ä¸€åˆ‡æ•°å€¼å¹¶å°†å…¶ç»‘å®šä¸º <code>x</code> . è‹¥æ˜¯è‡ªä¸Šè€Œä¸‹æ£€æŸ¥æ‰€æœ‰æ¨¡å¼éƒ½æ²¡æœ‰å‘½ä¸­, Haskellä¼šæŠ¥é”™. æ‰€ä»¥åœ¨ä½¿ç”¨æ¨¡å¼åŒ¹é…çš„æ—¶å€™åŠ¡å¿…è¦è€ƒè™‘<strong>è¾¹ç•Œæ¡ä»¶ä¸ç‰¹æ®Šå€¼</strong>(è¿™ä¸ä½ åœ¨æ•°å­¦è¡¨è¾¾å¼ä¸­è€ƒè™‘è¾¹ç•Œå€¼ä¸€æ ·é‡è¦)</p><p>ä¸€ä¸ªå®ç°é˜¶ä¹˜çš„ä¾‹å­</p><pre class="line-numbers language-haskell" data-language="haskell"><code class="language-haskell">factorial :: (Integral a) &#x3D;&gt; a -&gt; a  
factorial 0 &#x3D; 1  
factorial n &#x3D; n * factorial (n - 1)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>ğŸ¤”çœ‹èµ·æ¥æ¨¡å¼åŒ¹é…åªæ˜¯ç”¨äºç±»ä¼¼æ•°å­¦ä¸­é€’å½’å®šä¹‰çš„ä¸€ä¸ªè¯­æ³•ç³–?(ç®€åŒ–äº†<code>switch-case</code>)</p><p>ğŸ‘»å¹¶ä¸æ˜¯, æ¨¡å¼åŒ¹é…è¿˜æœ‰é«˜çº§ç”¨æ³•(æˆ‘æ›´å–œæ¬¢æŠŠä»–ç†è§£ä¸ºJSæ­£åˆ™ä¸­<code>if(regExp.test())&#123;args = regExp.exec()&#125;</code>çš„è¯­æ³•ç³–æˆ–è€…æ˜¯<code>Object</code>ç»“æ„èµ‹å€¼çš„è¯­æ³•ç³–)</p><ul><li><p>å®ç°ä¸€ä¸ªäºŒç»´å‘é‡ç›¸åŠ </p><p><pre class="line-numbers language-haskell" data-language="haskell"><code class="language-haskell">addVectors :: (Num a) &#x3D;&gt; (a, a) -&gt; (a, a) -&gt; (a, a)  
addVectors a b &#x3D; (fst a + fst b, snd a + snd b)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre></p><p>ç”¨æ¨¡å¼åŒ¹é…å†™å</p><p><pre class="line-numbers language-haskell" data-language="haskell"><code class="language-haskell">addVectors :: (Num a) &#x3D;&gt; (a, a) -&gt; (a, a) -&gt; (a, a)  
addVectors (x1, y1) (x2, y2) &#x3D; (x1 + x2, y1 + y2)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre></p><p>åœ¨å®šä¹‰å‡½æ•°çš„æ—¶å€™æˆ‘å°±å°†å‚æ•°ä¸ä¼ å…¥å€¼è¿›è¡Œäº†åŒ¹é…</p></li><li><p>å®ç°ä¸€ä¸ª<code>List</code>çš„<code>reverse</code>(æ³¨æ„å®ç°æ€è·¯ä¸æ¨¡å¼åŒ¹é…çš„åº”ç”¨)</p><p><pre class="line-numbers language-haskell" data-language="haskell"><code class="language-haskell">reverse&#39; :: [a] -&gt; [a]
reverse&#39; (x : xs) &#x3D; reverse&#39; xs ++ [x]
reverse&#39; [] &#x3D; []<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre></p><ul><li><p><code>x : xs</code>: è¡¨ç¤ºåŒ¹é…ä¸€ä¸ªList, å°†è¿™ä¸ªListçš„ç¬¬ä¸€ä¸ªå…ƒç´ è®¾ç½®ä¸º<code>x</code>, å‰©ä¸‹çš„è®¾ç½®ä¸º<code>xs</code></p><p>ä¾‹å¦‚: ä½¿ç”¨å…¶åŒ¹é…çš„æ—¶å€™<code>[1,2,3]</code>å°±ä¼šåŒ¹é…ä¸º<code>1:[2,3]</code>, äºæ˜¯<code>x = 1, xs = [2,3]</code></p><p>âš ï¸ä½¿ç”¨è¿™æ ·çš„æ–¹å¼åŒ¹é…æ•°ç»„æ—¶éœ€è¦åŠ ä¸Šæ‹¬å·è¡¨ç¤ºä»–ä»¬æ˜¯ä¸€ä½“çš„</p></li><li><p><code>reverse</code>å‡½æ•°æ˜¯ä»€ä¹ˆå‘¢? å°±æ˜¯æŠŠæ•°ç»„çš„ç¬¬ä¸€ä¸ªå…ƒç´ æ”¾åˆ°æœ€å, åœ¨å‰é¢åŠ ä¸Šåè½¬åçš„å‰©ä¸‹çš„å…ƒç´ </p></li><li><p>ä»€ä¹ˆæ—¶å€™ä¼šåŒ¹é…å¤±è´¥å‘¢? å½“å‚æ•°æ˜¯ç©ºæ•°ç»„çš„æ—¶å€™å°±å–ä¸å‡ºæ¥å¤´, äºæ˜¯è®¾ç½®ä¸€ä¸ªè¾¹ç•Œå€¼</p></li></ul></li><li><p>å®ç°ä¸€ä¸ª<code>List</code>çš„<code>head</code>å‡½æ•°</p><p><pre class="line-numbers language-haskell" data-language="haskell"><code class="language-haskell">head&#39; :: [a] -&gt; a
head&#39; (x:_) &#x3D; x
head&#39; [] &#x3D; error &quot;empty list&quot;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre></p><p>æˆ‘ä»¬å¹¶ä¸å…³å¿ƒæ¨¡å¼åŒ¹é…æ—¶é¦–å…ƒç´ åé¢çš„å…ƒç´ , é‚£ä¹ˆå¯ä»¥ç”¨<code>_</code>ä»£æ›¿</p></li><li><p>å®ç°ä¸€ä¸ªå¿«é€Ÿæ’åº</p><p><pre class="line-numbers language-haskell" data-language="haskell"><code class="language-haskell">qsort :: (Ord a) &#x3D;&gt; [a] -&gt; [a]
qsort (target:xs) &#x3D; [x|x&lt;-xs, x&lt;&#x3D;target] ++ [target] ++ [x|x&lt;-xs, x&gt;target]
qsort [] &#x3D; []<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre></p><p>è¿™æ˜¯ä¸€ä¸ªç»å…¸çš„ä¾‹å­, å¿«é€Ÿæ’åºæ˜¯ä»€ä¹ˆ, å°±æ˜¯éšä¾¿è¿™ä¸€ä¸ªå…ƒç´ , æŠŠæ¯”ä»–å°çš„æ’åºåæ”¾åœ¨å·¦è¾¹, æ¯”ä»–å¤§çš„æ’åºåæ”¾åœ¨å³è¾¹</p></li><li><p>è¿˜å¯ä»¥åœ¨åŒ¹é…æ—¶ä½¿ç”¨<code>@</code>è¯­æ³•ä¿ç•™å¯¹æ•´ä½“çš„å¼•ç”¨</p><p><pre class="line-numbers language-haskell" data-language="haskell"><code class="language-haskell">capital :: String -&gt; String  
capital &quot;&quot; &#x3D; &quot;Empty string, whoops!&quot;  
capital all@(x:xs) &#x3D; &quot;The first letter of &quot; ++ all ++ &quot; is &quot; ++ [x]<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre></p></li></ul><h4 id="guardså®ˆå«">Guards(å®ˆå«)</h4><p>ğŸ’‚ğŸ½<code>guard</code>ç”¨æ¥æ£€æŸ¥ä¸€ä¸ªå€¼çš„æŸé¡¹å±æ€§æ˜¯å¦ä¸ºçœŸ. å¬èµ·æ¥å’Œè·¯ç”±å®ˆå«ä¸€æ ·, å¦‚æœæ¡ä»¶åˆ¤æ–­é€šè¿‡å°±æ”¾è¡Œ. ä¾‹å¦‚è®¡ç®—BMIå‡½æ•°:</p><pre class="line-numbers language-haskell" data-language="haskell"><code class="language-haskell">bmiTell :: (RealFloat a) &#x3D;&gt; a -&gt; String  
bmiTell bmi         -- æ³¨æ„è¿™é‡Œæ²¡æœ‰ç­‰å·
    | bmi &lt;&#x3D; 18.5 &#x3D; &quot;underweight&quot;      -- ç­‰å·åœ¨è¿™é‡Œ
    | bmi &lt;&#x3D; 25.0 &#x3D; &quot;Pffft&quot;                -- ä¸if-elseä¸€æ ·åªä¼šåŒ¹é…ç¬¬ä¸€ä¸ªé€šè¿‡çš„
    | bmi &lt;&#x3D; 30.0 &#x3D; &quot;fat&quot;  
    | otherwise   &#x3D; &quot;whale&quot;      -- æœ€åå¯ä»¥ä½¿ç”¨otherwiseå…œåº•<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>ğŸ‘€çœ‹èµ·æ¥æ˜¯ä¸ªè¯­æ³•ç³–: <code>|</code>å’Œ<code>if-else-if</code>ä¸€æ ·, <code>otherwise</code>å’Œå…œåº•<code>else</code>ä¸€æ ·, ä½†æ˜¯ç”¨åœ¨æ­¤å¤„ç›¸å½“ç®€æ´.</p><p>âš ï¸å¦‚æœä½¿ç”¨<code>Guard</code>ä¸”æ²¡æœ‰ä½¿ç”¨<code>otherwise</code>ä¸”å…¨éƒ¨åŒ¹é…å¤±è´¥, Haskellä¼šåŒ¹é…ä¸‹ä¸€ä¸ªå‡½æ•°, ä¾‹å¦‚:</p><pre class="line-numbers language-haskell" data-language="haskell"><code class="language-haskell">f :: (Ord a, Num a) &#x3D;&gt; a -&gt; [a]
f x
  | x &lt; 0 &#x3D; error &quot;make sure x &gt;&#x3D; 0&quot;
  | x &#x3D;&#x3D; 0 &#x3D; [0]
f x &#x3D; x : f (x - 1)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>å¦‚æœ<code>x&gt;0</code>, <code>f x</code>ä¼šå…ˆè¿›å…¥ç¬¬ä¸€ä¸ªå‡½æ•°, ä¸¤ä¸ª<code>guard</code>éƒ½åŒ¹é…å¤±è´¥äº†, äºæ˜¯è¿›å…¥ä¸‹ä¸€ä¸ªæ¨¡å¼åŒ¹é…</p><h4 id="whereç»‘å®š">Whereç»‘å®š</h4><p>æ”¹è¿›ä¸€ä¸‹BMI, è¦æ±‚ç”¨æˆ·è¾“å…¥èº«é«˜ä¸ä½“é‡ğŸ‘‡</p><pre class="line-numbers language-haskell" data-language="haskell"><code class="language-haskell">bmiTell :: (RealFloat a) &#x3D;&gt; a -&gt; a -&gt; String  
bmiTell weight height  
    | weight &#x2F; height ^ 2 &lt;&#x3D; 18.5 &#x3D; &quot;underweight&quot;  
    | weight &#x2F; height ^ 2 &lt;&#x3D; 25.0 &#x3D; &quot;Pffft&quot;  
    | weight &#x2F; height ^ 2 &lt;&#x3D; 30.0 &#x3D; &quot;fat&quot;  
    | otherwise                   &#x3D; &quot;whale&quot;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>ä¸å‘½ä»¤å¼è¯­è¨€ä¸€æ ·, æˆ‘ä»¬æƒ³æŠŠ<code>weight / height ^ 2</code>å®šä¹‰æˆå˜é‡, å¯ä»¥ä½¿ç”¨<code>where</code>å…³é”®å­—</p><pre class="line-numbers language-haskell" data-language="haskell"><code class="language-haskell">bmiTell :: (RealFloat a) &#x3D;&gt; a -&gt; a -&gt; String  
bmiTell weight height  
    | bmi &lt;&#x3D; 18.5 &#x3D; &quot;underweight&quot;  
    | bmi &lt;&#x3D; 25.0 &#x3D; &quot;Pffft&quot;  
    | bmi &lt;&#x3D; 30.0 &#x3D; &quot;fat&quot;  
    | otherwise   &#x3D; &quot;whale&quot;
    where bmi &#x3D; weight &#x2F; height ^ 2<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>å°±åƒå†™æ•°å­¦å…¬å¼ä¸€æ · <span class="math display">\[ \begin{equation} f(h,w) = \left\{ \\ \begin{aligned} &amp;\text{underweight} &amp; BMI\leq 18.5 \\ &amp;\text{Pffft} &amp; 18.5&lt; BMI\leq 25 \\ &amp;\text{fat} &amp; 25&lt; BMI\leq 30 \\ &amp;\text{whale} &amp; 30&lt; BMI \end{aligned} \right. \ \ \ where\ BMI = w/h^2 \end{equation} \]</span> <code>where</code>åé¢å¯ä»¥è·Ÿå¤šä¸ªåå­—å’Œå‡½æ•°å®šä¹‰</p><pre class="line-numbers language-haskell" data-language="haskell"><code class="language-haskell">bmiTell :: (RealFloat a) &#x3D;&gt; a -&gt; a -&gt; String  
bmiTell weight height  
    | bmi &lt;&#x3D; skinny &#x3D; &quot;You&#39;re underweight, you emo, you!&quot;  
    | bmi &lt;&#x3D; normal &#x3D; &quot;You&#39;re supposedly normal. Pffft, I bet you&#39;re ugly!&quot;  
    | bmi &lt;&#x3D; fat    &#x3D; &quot;You&#39;re fat! Lose some weight, fatty!&quot;  
    | otherwise     &#x3D; &quot;You&#39;re a whale, congratulations!&quot;  
    where bmi &#x3D; weight &#x2F; height ^ 2  
          skinny &#x3D; 18.5  
          normal &#x3D; 25.0  
          fat &#x3D; 30.0<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>âš ï¸æ³¨æ„</p><ul><li><p><code>where</code> ç»‘å®šä¸­å®šä¹‰çš„åå­—åªå¯¹æœ¬å‡½æ•°å¯è§, å…¶ä¸­çš„åå­—éƒ½æ˜¯ä¸€åˆ—å‚ç›´æ’å¼€</p></li><li><p><code>where</code> ç»‘å®šä¹Ÿå¯ä»¥ä½¿ç”¨æ¨¡å¼åŒ¹é…, å‰é¢é‚£æ®µä»£ç å¯ä»¥æ”¹æˆï¼š</p><p><pre class="line-numbers language-haskell" data-language="haskell"><code class="language-haskell">where bmi &#x3D; weight &#x2F; height ^ 2  
      (skinny, normal, fat) &#x3D; (18.5, 25.0, 30.0)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre></p></li><li><p><code>where</code>å¯ä»¥åµŒå¥—ä½¿ç”¨</p></li></ul><h4 id="letç»‘å®š">Letç»‘å®š</h4><p>ä¸<code>where</code>ç±»ä¼¼, ä½œç”¨åŸŸä¸åŒ. <code>where</code>ç»‘å®šåœ¨å‡½æ•°åº•éƒ¨, åœ¨<strong>æ‰€æœ‰<code>guard</code>å†…</strong>å¯è§, ä½†<code>let</code>åªå¯¹<code>let-in</code>ç»‘å®šçš„<code>in</code><strong>è¡¨è¾¾å¼</strong>å¯è§, ä¾‹å¦‚</p><pre class="line-numbers language-haskell" data-language="haskell"><code class="language-haskell">cylinder :: (RealFloat a) &#x3D;&gt; a -&gt; a -&gt; a  
cylinder r h &#x3D; 
    let sideArea &#x3D; 2 * pi * r * h  
        topArea &#x3D; pi * r ^2  
    in  sideArea + 2 * topArea<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="caseè¡¨è¾¾å¼">Caseè¡¨è¾¾å¼</h4><p>ä¸å‘½ä»¤å¼ç¼–ç¨‹çš„<code>case</code>ç±»ä¼¼, åŒæ ·æ”¯æŒæ¨¡å¼åŒ¹é…</p><pre class="line-numbers language-haskell" data-language="haskell"><code class="language-haskell">case expression of pattern -&gt; result  
                   pattern -&gt; result  
                   pattern -&gt; result  
                   ...<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>ä¾‹å¦‚</p><pre class="line-numbers language-haskell" data-language="haskell"><code class="language-haskell">describeList :: [a] -&gt; String  
describeList xs &#x3D; &quot;The list is &quot; ++ case xs of [] -&gt; &quot;empty.&quot;  
                                               [x] -&gt; &quot;a singleton list.&quot;   
                                               xs -&gt; &quot;a longer list.&quot;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><h4 id="å°†å‡½æ•°å®šä¹‰ä¸ºä¸­ç¼€å‡½æ•°">å°†å‡½æ•°å®šä¹‰ä¸ºä¸­ç¼€å‡½æ•°</h4><p>ä¸ä½¿ç”¨åå¼•å·ä¹Ÿå¯ä»¥å®šä¹‰ä¸­ç¼€å‡½æ•°. ä½†æ˜¯, å‡½æ•°ååªèƒ½ä½¿ç”¨<code>:|!@#$%^&amp;*-+./&lt;&gt;?\~</code>, ä¹‹åå¯ä»¥ä½¿ç”¨ä¸‹é¢ä»»æ„æ–¹å¼å®šä¹‰</p><pre class="line-numbers language-haskell" data-language="haskell"><code class="language-haskell">a |+| b   &#x3D; method1
(|+|) a b &#x3D; method1 a b 
(|+|)     &#x3D; method1<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><h4 id="å®šä¹‰å‡½æ•°çš„ç»“åˆæ€§ä¸ä¼˜å…ˆçº§">å®šä¹‰å‡½æ•°çš„ç»“åˆæ€§ä¸ä¼˜å…ˆçº§</h4><p>ä¾‹å¦‚</p><pre class="line-numbers language-haskell" data-language="haskell"><code class="language-haskell">infixr 9 op<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><ul><li><code>infi*</code>å®šä¹‰ç»“åˆæ€§<br><code>infixr</code>æ˜¯å³ç»“åˆ, <code>infixl</code>æ˜¯å·¦ç»“åˆ, <code>infix</code>æ— å·¦å³ä¼˜å…ˆæ€§.</li><li>æ•°å­—å®šä¹‰ä¼˜å…ˆçº§<br>ä¼˜å…ˆçº§ä¸€å…±æœ‰åä¸ª, <code>0-9</code>, æ•°å­—è¶Šå¤§è¶Šé«˜, å¦‚æœå®šä¹‰æ—¶çœç•¥äº†æ•°å­—, åˆ™é»˜è®¤ä¸º9. é¢„å®šä¹‰çš„æœ‰</li></ul><table><thead><tr class="header"><th>å€¼</th><th>å·¦ç»“åˆ</th><th>æ— ç»“åˆ</th><th>å³ç»“åˆ</th></tr></thead><tbody><tr class="odd"><td>9</td><td>!!</td><td></td><td>.</td></tr><tr class="even"><td>8</td><td></td><td></td><td>^, ^^, **</td></tr><tr class="odd"><td>7</td><td>*,/,<code>div</code></td><td></td><td></td></tr><tr class="even"><td>6</td><td>+, -</td><td></td><td></td></tr><tr class="odd"><td>5</td><td></td><td></td><td>:, ++</td></tr><tr class="even"><td>4</td><td></td><td>==,/=,&lt;,&lt;=,&gt;,&gt;=,<code>elem</code>,<code>notElem</code></td><td></td></tr><tr class="odd"><td>3</td><td></td><td></td><td>&amp;&amp;</td></tr><tr class="even"><td>2</td><td></td><td></td><td></td></tr><tr class="odd"><td>1</td><td>&gt;&gt;, &gt;&gt;=</td><td></td><td></td></tr><tr class="even"><td>0</td><td></td><td></td><td><span class="math inline">\(,\)</span>!,<code>seq</code></td></tr></tbody></table><h3 id="é€’å½’">é€’å½’</h3><p>ğŸª†ä½¿ç”¨æ¨¡å¼åŒ¹é…ä¸é€’å½’å¯ä»¥ä¼˜é›…çš„å®ç°é€’å½’. åœ¨å®ç°é€’å½’æ—¶æœ€éœ€è¦å…³æ³¨çš„å°±æ˜¯<strong>è¾¹ç•Œæ¡ä»¶</strong>. <strong>è€Œé€’å½’çš„çš„å®ç°æ€è·¯å°±æ˜¯æè¿°é—®é¢˜æ˜¯å¦‚ä½•å®šä¹‰çš„</strong></p><ul><li><p>å®ç°<code>List</code>çš„<code>max</code>å‡½æ•°</p><p>å‘½ä»¤å¼æ€è·¯: è®¾ä¸€ä¸ªå˜é‡æ¥å­˜å‚¨å½“å‰çš„æœ€å¤§å€¼ï¼Œç„¶åç”¨å¾ªç¯éå†è¯¥ <code>List</code>ï¼Œè‹¥å­˜åœ¨æ¯”è¿™ä¸ªå€¼æ›´å¤§çš„å…ƒç´ ï¼Œåˆ™ä¿®æ”¹å˜é‡ä¸ºè¿™ä¸€å…ƒç´ çš„å€¼</p><p>å‡½æ•°å¼æ€è·¯: <code>List</code>çš„æœ€å¤§å€¼å°±æ˜¯<code>head</code>å’Œ<code>tail</code>æœ€å¤§å€¼çš„æœ€å¤§å€¼. ç©º<code>List</code>çš„æœ€å¤§å€¼ä¸ºError</p><pre class="line-numbers language-haskell" data-language="haskell"><code class="language-haskell">maximum&#39; :: (Ord a) &#x3D;&gt; [a] -&gt; a  
maximum&#39; [] &#x3D; error &quot;maximum of empty list&quot;  
maximum&#39; [x] &#x3D; x  
maximum&#39; (x:xs)   
    | x &gt; maxTail &#x3D; x  
    | otherwise &#x3D; maxTail  
    where maxTail &#x3D; maximum&#39; xs<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li><li><p>å®ç°<code>replicate n x</code>å‡½æ•°(å°†<code>x</code>é‡å¤<code>n</code>æ¬¡)</p><pre class="line-numbers language-haskell" data-language="haskell"><code class="language-haskell">replicate&#39; :: (Num i, Ord i) &#x3D;&gt; i -&gt; a -&gt; [a]  
replicate&#39; n x  
    | n &lt;&#x3D; 0    &#x3D; []  
    | otherwise &#x3D; x:replicate&#39; (n-1) x<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>âš ï¸è¿™é‡Œä½¿ç”¨<code>Guard</code>è€Œä¸æ˜¯æ¨¡å¼åŒ¹é…æ˜¯å› ä¸ºæ¨¡å¼åŒ¹é…æ— æ³•åŒ¹é…<code>&lt;0</code></p></li><li><p>å®ç°<code>take</code>å‡½æ•°</p><pre class="line-numbers language-haskell" data-language="haskell"><code class="language-haskell">take&#39; :: (Num i, Ord i) &#x3D;&gt; i -&gt; [a] -&gt; [a]  
take&#39; 0 _ &#x3D; []
take&#39; _ [] &#x3D; []
take&#39; n (x:xs) &#x3D; x : take&#39; (n-1) xs<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>æ›´åŠ å‘¨å…¨çš„çš„ä»£ç (åŒæ ·å› ä¸ºæˆ‘ä»¬è¦åŒ¹é…<code>n&lt;0</code>çš„æƒ…å†µ, æ‰€ä»¥ä¸èƒ½ç”¨æ¨¡å¼åŒ¹é…äº†)</p><pre class="line-numbers language-haskell" data-language="haskell"><code class="language-haskell">take&#39; :: (Num i, Ord i) &#x3D;&gt; i -&gt; [a] -&gt; [a]  
take&#39; n _  
    | n &lt;&#x3D; 0   &#x3D; []  
take&#39; _ []     &#x3D; []  
take&#39; n (x:xs) &#x3D; x : take&#39; (n-1) xs<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre></li><li><p>å®ç°<code>repeat</code>å‡½æ•°</p><pre class="line-numbers language-haskell" data-language="haskell"><code class="language-haskell">repeat&#39; :: a -&gt; [a]  
repeat&#39; x &#x3D; x:repeat&#39; x<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre></li><li><p>å®ç°<code>zip</code>å‡½æ•°</p><pre class="line-numbers language-haskell" data-language="haskell"><code class="language-haskell">zip&#39; :: [a] -&gt; [b] -&gt; [(a, b)]
zip&#39; [] _ &#x3D; []
zip&#39; _ [] &#x3D; []
zip&#39; (x1:xs1) (x2:xs2) &#x3D; (x1,x2):zip&#39; xs1 xs2<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre></li><li><p>å®ç°<code>elem</code>å‡½æ•°</p><pre class="line-numbers language-haskell" data-language="haskell"><code class="language-haskell">elem&#39; :: (Eq a) &#x3D;&gt; a -&gt; [a] -&gt; Bool
elem&#39; e [] &#x3D; False
elem&#39; e (x : xs) &#x3D; (e &#x3D;&#x3D; x) || elem&#39; e xs<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>ä½†æ˜¯æœ‰ç‚¹ä¸å‡½æ•°å¼, æ”¹ä¸€æ”¹</p><pre class="line-numbers language-haskell" data-language="haskell"><code class="language-haskell">elem&#39; :: (Eq a) &#x3D;&gt; a -&gt; [a] -&gt; Bool
elem&#39; e (x : xs)
  | e &#x3D;&#x3D; x &#x3D; True
  | otherwise &#x3D; elem&#39; e xs
elem&#39; e _ &#x3D; False<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre></li><li><p>æ¸©ä¹ ä¸€ä¸‹å¿«é€Ÿæ’åº(å¹¶ä½¿ç”¨<code>where</code>è®©å…¶çœ‹èµ·æ¥æ›´åƒå‡½æ•°å¼)</p><pre class="line-numbers language-haskell" data-language="haskell"><code class="language-haskell">qsort :: (Ord a) &#x3D;&gt; [a] -&gt; [a]
qsort (target:xs) &#x3D; lowers ++ [target] ++ uppers 
  where lowers &#x3D; qsort [x|x&lt;-xs, x&lt;&#x3D;target]
        uppers &#x3D; qsort [x|x&lt;-xs, x&gt;target]
qsort _ &#x3D; []<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre></li></ul><p>âš ï¸æ€è·¯: å®šä¹‰è¾¹ç•Œæ¡ä»¶, å†å®šä¹‰ä¸ªå‡½æ•°, è®©å®ƒä»ä¸€å †å…ƒç´ ä¸­å–ä¸€ä¸ªå¹¶åšç‚¹äº‹æƒ…å, æŠŠä½™ä¸‹çš„å…ƒç´ é‡æ–°äº¤ç»™è¿™ä¸ªå‡½æ•°</p><ul><li><p>å®ç°åŸƒç­›</p><pre class="line-numbers language-haskell" data-language="haskell"><code class="language-haskell">primes &#x3D; filterPrime [2..]
  where filterPrime (p:xs) &#x3D;
          p : filterPrime [x | x &lt;- xs, x &#96;mod&#96; p &#x2F;&#x3D; 0]<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>è¿™ç§ç”Ÿæˆå™¨ç”Ÿæˆ+éªŒè¯å™¨éªŒè¯çš„æ¨¡å¼å€¼å¾—å­¦ä¹ <br></p></li><li><p>å®ç°æ–æ³¢é‚£å¥‘</p><pre class="line-numbers language-haskell" data-language="haskell"><code class="language-haskell">fib :: Int -&gt; [Int]
fib n &#x3D; take n $ fibList [1, 1]
  where
    fibList [a, b] &#x3D; a : fibList [b, a + b]<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>æ³¨æ„å­¦ä¹ å¦‚ä½•å­˜å‚¨é€’å½’ä¸­éœ€è¦çš„è°ƒç”¨å€¼</p></li></ul><h3 id="å‡½æ•°pro">å‡½æ•°Pro</h3><p>ğŸ˜•å‡½æ•°å¼ç¼–ç¨‹ä¸æ•°å­¦è¡¨è¾¾å¼çœ‹èµ·æ¥å¤ªåƒäº†.</p><p>ğŸ‘¼äºæ˜¯æˆ‘å¤©çœŸçš„ä»¥ä¸ºå‡½æ•°å¼ç¼–ç¨‹å°±æ˜¯ç”¨æ•°å­¦çš„æ–¹å¼æè¿°é—®é¢˜, ç„¶åå°†å…¶è¡¨ç¤ºä¸ºå‡½æ•°å¼ç¼–ç¨‹è¯­å¥.</p><p>ğŸ¤”å®é™…ä¸Šå‡½æ•°å¼ç¼–ç¨‹æ›´åŠ æ³¨é‡<strong>å°†å‡½æ•°ä½œä¸º"ä¸€ç­‰å…¬æ°‘", ä»è€Œæ“ä½œå‡½æ•°æˆ–æ˜¯å‡½æ•°çš„ä¸€éƒ¨åˆ†è§£å†³é—®é¢˜</strong></p><h4 id="å‡½æ•°æŸ¯é‡ŒåŒ–ä¸ä¸å…¨è°ƒç”¨">å‡½æ•°æŸ¯é‡ŒåŒ–ä¸ä¸å…¨è°ƒç”¨</h4><p>åœ¨JSä¸­ç»å¸¸èƒ½å¬åˆ°è¿™ä¸ªå‡½æ•°æŸ¯é‡ŒåŒ–è¿™ä¸ªè¯è¯­, åœ¨JSä¸­, æŸ¯é‡ŒåŒ–å°±æ˜¯æŠŠå¤šå‚å‡½æ•°å˜æˆå•å‚å‡½æ•°, å¹¶è¿”å›ä¸€ä¸ªå•å‚æ•°å‡½æ•°ç”¨äºåƒä¸‹ä¸‹ä¸€ä¸ªå‚æ•°.</p><p>ğŸ¬ä½†æ˜¯, Haskellä¸­æ‰€æœ‰å‡½æ•°éƒ½åªæœ‰ä¸€ä¸ªå‚æ•°, æ‰€æœ‰å‡½æ•°éƒ½æ˜¯æŸ¯é‡ŒåŒ–å‡½æ•°. è€Œå¤šå‚å‡½æ•°åªæ˜¯ä¸€ä¸ªè¯­æ³•ç³–!</p><p>ğŸ˜±æ‹¿<code>max</code>å‡½æ•°ä¸¾ä¾‹. <code>max</code>å‡½æ•°å®é™…ä¸Šåªæ¥å—ä¸€ä¸ªå‚æ•°<code>x</code>, ç„¶åè¿”å›ä¸€ä¸ªå’Œ<code>x</code>æ¯”è¾ƒå¤§å°çš„å‡½æ•°,ä¾‹å¦‚</p><pre class="line-numbers language-haskell" data-language="haskell"><code class="language-haskell">comp x y &#x3D; x y  -- æ¥å—x,y è¿”å›x yçš„ç»“æœ
maxWith5 &#x3D; max 5     -- è¿”å›ä¸€ä¸ªmax 5å‡½æ•°
res &#x3D; zipWith comp (repeat maxWith5) [1 .. 10]
-- [5,5,5,5,5,6,7,8,9,10]<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>ä¹Ÿå°±æ˜¯è¯´<code>maxWith5</code>å°±æ˜¯ä¸€ä¸ªå‡½æ•°, å‡½æ•°æ¥å—ä¸€ä¸ªå‚æ•°, è¿”å›å’Œ<code>5</code>æ¯”è¾ƒå¤§çš„é‚£ä¸ª, ä¹Ÿå°±æ˜¯æˆ‘ä»¬ä¹‹å‰å†™çš„<code>max 5 6</code>å¯ä»¥å†™æˆ<code>(max 5) 6</code></p><p>å†çœ‹çœ‹<code>maxWith5</code>, è¯•è¯•å†™å‡ºä»–çš„ç±»å‹:<code>Ord a =&gt; a -&gt; a</code>. æ˜¾è€Œæ˜“è§, æ¥å—ä¸€ä¸ª<code>Ord</code>ç±»å‹ç±»çš„<code>a</code>ç±»å˜é‡, è¿”å›ä¸€ä¸ª<code>a</code>ç±»å˜é‡. è€Œä¹‹å‰é‚£ä¸ª<code>max</code>å‡½æ•°å‘¢? æ”¶åˆ°ä¸€ä¸ª<code>a</code>ç±»å˜é‡, è¿”å›ä¸€ä¸ª<code>Ord a =&gt; a -&gt; a</code>ç±»å‡½æ•°. è¯•è¯•å†™å‡º<code>max</code>å‡½æ•°ç±»å‹: <code>Ord a =&gt; a -&gt; (a-&gt;a)</code>è¿™ä¸ªæ‹¬å·æ²¡å•¥ç”¨(å› ä¸ºHaskellæ˜¯è‡ªå·¦å‘å³è§£æçš„)äºæ˜¯ç®€åŒ–æˆ<code>Ord a =&gt; a -&gt; a -&gt; a</code>è¿™ä¹Ÿå°±è§£é‡Šäº†<strong>ä¸ºä»€ä¹ˆæŠŠå‚æ•°ç±»å‹ä¸ç»“æœç”¨<code>-&gt;</code>è¿åœ¨ä¸€èµ·æ˜¯ç¬¦åˆç›´è§‰çš„</strong></p><p>âš›åƒ<code>max 5</code>è¿™æ ·çš„å‡½æ•°è°ƒç”¨å°±æ˜¯<strong>ä¸å…¨è°ƒç”¨</strong>, è€Œä¸­ç¼€å‡½æ•°ä¹Ÿå­˜åœ¨ä¸å…¨è°ƒç”¨, ä¾‹å¦‚<code>elem [1..]</code>, <code>==4</code>, <code>*5</code></p><h4 id="é«˜é˜¶å‡½æ•°">é«˜é˜¶å‡½æ•°</h4><p>ğŸŒŒé«˜é˜¶å‡½æ•°: æ¥æ”¶å‡½æ•°ä½œä¸ºå‚æ•°æˆ–è¿”å›å‡½æ•°çš„å‡½æ•°å°±æ˜¯é«˜é˜¶å‡½æ•°, ä¾‹å¦‚</p><pre class="line-numbers language-haskell" data-language="haskell"><code class="language-haskell">applyTwice :: (a -&gt; a) -&gt; a -&gt; a  
applyTwice f x &#x3D; f (f x)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>è¿™ä¸ªç±»å‹ä¼¼ä¹æœ‰ç‚¹ç‰¹åˆ«, å¤šäº†ä¸€ä¸ªæ‹¬å·, è¡¨ç¤ºç¬¬ä¸€ä¸ªå‚æ•°æ˜¯ä¸€ä¸ªå‡½æ•°è€Œä¸æ˜¯ç±»å‹<code>a</code>(å› ä¸ºHaskellæ˜¯å³ç»“åˆçš„)</p><p>ç»“åˆå‡½æ•°æŸ¯é‡ŒåŒ–ä¸ä¸å…¨è°ƒç”¨, æˆ‘ä»¬å¯ä»¥å†™å‡ºè¿™æ ·çš„è¡¨è¾¾å¼</p><pre class="line-numbers language-haskell" data-language="haskell"><code class="language-haskell">applyTwice (+3) 10         -- 16 (è°ƒç”¨å‡½æ•°å­  ğŸ˜²
applyTwice (++ &quot; HAHA&quot;) &quot;HEY&quot;  --&quot;HEY HAHA HAHA&quot;  
applyTwice (&quot;HAHA &quot; ++) &quot;HEY&quot;    -- &quot;HAHA HAHA HEY&quot;  
ghci&gt; applyTwice (multThree 2 2) 9  -- 144  
ghci&gt; applyTwice (3:) [1]           -- [3,3,1]<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>ç»“åˆå‡½æ•°å­å¯ä»¥å®ç°å¤šç§ç‚«é…·çš„æ“ä½œ. è¿™å°±æ˜¯æŠŠå‡½æ•°å½“æˆå¯¹è±¡ç”¨</p><p>å®ç°ä¸€ä¸ª<code>zipWith</code>, ä½“éªŒä¸€ä¸‹æ— å‚æ•°çš„ä¸å…¨è°ƒç”¨</p><pre class="line-numbers language-haskell" data-language="haskell"><code class="language-haskell">zipWith&#39; :: (a -&gt; b -&gt; c) -&gt; [a] -&gt; [b] -&gt; [c]
zipWith&#39; f (x : xs) (y : ys) &#x3D; f x y : zipWith&#39; f xs ys

zipWith&#39; (+) [4,2,5,6] [2,6,2,3]         --[6,8,7,9]  
zipWith&#39; max [6,3,2,1] [7,3,1,5]         -- [7,3,2,5]  
zipWith&#39; (++) [&quot;foo &quot;, &quot;bar &quot;, &quot;baz &quot;] [&quot;fighters&quot;, &quot;hoppers&quot;, &quot;aldrin&quot;]    
-- [&quot;foo fighters&quot;,&quot;bar hoppers&quot;,&quot;baz aldrin&quot;]  
zipWith&#39; (*) (replicate 5 2) [1..]       -- [2,4,6,8,10]  
zipWith&#39; (zipWith&#39; (*)) [[1,2,3],[3,5,6],[2,3,4]] [[3,2,2],[3,4,5],[5,4,3]]  
-- [[3,4,6],[9,20,30],[10,12,12]]<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>å¯ä»¥å€ŸåŠ©é«˜é˜¶å‡½æ•°å®ç°å‘½ä»¤å¼ä¸­çš„<code>for</code>ã€<code>while</code>ã€èµ‹å€¼ã€çŠ¶æ€æ£€æµ‹</p><p><code>flip</code>æ˜¯ä¸€ä¸ªå¸¸ç”¨é«˜é˜¶å‡½æ•°, å®ç°åŠŸèƒ½å¾ˆç®€å•</p><pre class="line-numbers language-haskell" data-language="haskell"><code class="language-haskell">flip :: (a -&gt; b -&gt; c) -&gt; b -&gt; a -&gt; c  
flip f y x &#x3D; f x y<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>ä¹Ÿå°±æ˜¯ä¼ å…¥ä¸€ä¸ªäºŒå…ƒå‡½æ•°, ä¼ å›ä¸€ä¸ªæ¥å—å‚æ•°ç›¸åçš„äºŒå…ƒå‡½æ•°(<strong>æ³¨æ„: ä¼ å›çš„æ˜¯å‡½æ•°è€Œä¸æ˜¯å‡½æ•°çš„è¿è¡Œç»“æœ!</strong>)</p><p>âš ï¸<code>flip</code>ç»å¸¸ç”¨æ¥å¯¹åº“å‡½æ•°è¿›è¡Œæ”¹è¿›, ä¾‹å¦‚æˆ‘éœ€è¦å‡½æ•°</p><pre class="line-numbers language-haskell" data-language="haskell"><code class="language-haskell">pushFont :: [a]-&gt;a-&gt;[a]
pushFont xs x &#x3D; x:xs<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>è¦æ˜¯å‡½æ•°å‚æ•°èƒ½åè¿‡æ¥å°±å¥½äº†, äºæ˜¯æˆ‘å°±å¯ä»¥å†™</p><pre class="line-numbers language-haskell" data-language="haskell"><code class="language-haskell">pushFont :: [a]-&gt;a-&gt;[a]
pushFont &#x3D; flip (:)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>ä¸éœ€è¦æ·»åŠ å‚æ•°, å°±ç®—å›ºæ‰§çš„æ·»åŠ ä¸Šäº†å‚æ•°, å‡½æ•°åªæ˜¯å˜æˆè¿™æ ·</p><pre class="line-numbers language-haskell" data-language="haskell"><code class="language-haskell">pushFont :: [a]-&gt;a-&gt;[a]
pushFont x xs &#x3D; flip (:) x xs<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>éƒ½æ˜¯åœ¨æœ€åè°ƒç”¨å‡½æ•°, é‚£ä¹ˆåŠ ä¸åŠ å‚æ•°æ²¡å…³ç³». è®°ä½: <strong>æˆ‘ä»¬å®šä¹‰çš„æ˜¯å‡½æ•°, è€Œä¸æ˜¯è¿ç®—ç»“æœ</strong></p><h4 id="lambdaå‡½æ•°">Lambdaå‡½æ•°</h4><p>ä¸JSç±»å‹, å¯ä»¥ç”ŸæˆåŒ¿åå‡½æ•°, é€šå¸¸åœ¨è¿™ä¸ªå‡½æ•°åªæ˜¯ç”¨ä¸€æ¬¡çš„æ—¶å€™ä½¿ç”¨, è¯­æ³•ä¸º<code>\å‚æ•°1 å‚æ•°2 -&gt; è¡¨è¾¾å¼</code>, ä¾‹å¦‚</p><pre class="line-numbers language-haskell" data-language="haskell"><code class="language-haskell">flip&#39; :: (a -&gt; b -&gt; c) -&gt; b -&gt; a -&gt; c  
flip&#39; f x y &#x3D; \x y -&gt; f y x<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>å°½ç®¡è¿™ä¸ <code>flip' f x y = f y x</code> ç­‰ä»·ï¼Œå®ƒå¯ä»¥æ›´æ˜ç™½åœ°è¡¨ç¤ºå‡ºå®ƒä¼šäº§ç”Ÿä¸€ä¸ªæ–°çš„å‡½æ•°</p><h4 id="mapfilterfoldscan">map&amp;filter&amp;fold&amp;scan</h4><p>è¿™å‡ ä¸ªå‡½æ•°ä¸JSçš„<code>Array.map</code>, <code>Array.filter</code>, <code>Array.reduce</code>å¾ˆåƒ, æ‰€ä»¥ååˆ†é‡è¦</p><p>ä»–ä»¬æœ¬èº«æ˜¯Listçš„æ–¹æ³•, ä½†æ˜¯åœ¨åº“å‡½æ•°åŠ è½½çš„æ—¶å€™è¢«è‡ªåŠ¨å¼•ç”¨äº†, ä¹Ÿå°±æ˜¯ç±»ä¼¼äº</p><pre class="line-numbers language-haskell" data-language="haskell"><code class="language-haskell">map &#x3D; Array.map<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><ul><li><p><code>map</code></p><pre class="line-numbers language-haskell" data-language="haskell"><code class="language-haskell">map :: (a -&gt; b) -&gt; [a] -&gt; [b]  
map _ [] &#x3D; []  
map f (x:xs) &#x3D; f x : map f xs<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>ä¼ å…¥æ˜ å°„å‡½æ•°ä¸<code>List</code>, è¿”å›å¯¹æ¯ä¸ªå…ƒç´ æ˜ å°„åçš„ç»“æœ</p><pre class="line-numbers language-haskell" data-language="haskell"><code class="language-haskell">map (+3) [1,5,3,1,6]                    -- [4,8,6,4,9]  
map (++ &quot;!&quot;) [&quot;BIFF&quot;, &quot;BANG&quot;, &quot;POW&quot;]    -- [&quot;BIFF!&quot;,&quot;BANG!&quot;,&quot;POW!&quot;]  
map (replicate 3) [3..6]               -- [[3,3,3],[4,4,4],[5,5,5],[6,6,6]]  
map (map (^2)) [[1,2],[3,4,5,6],[7,8]]  -- [[1,4],[9,16,25,36],[49,64]]  
map fst [(1,2),(3,5),(6,3),(2,6),(2,5)] -- [1,3,6,2,2]<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>ä½¿ç”¨å‡½æ•°å­ä½œä¸ºå‡½æ•°è°ƒç”¨å°±è®©<code>map</code>ç‚«é…·å¤šäº†</p><p>ä»¥ä¸Šçš„æ‰€æœ‰ä»£ç éƒ½å¯ä»¥ç”¨ List Comprehension æ¥æ›¿ä»£ã€‚<code>map (+3) [1,5,3,1,6]</code> ä¸ <code>[x+3 | x &lt;- [1,5,3,1,6]</code> å®Œå…¨ç­‰ä»·.</p></li><li><p><code>filter</code></p><pre class="line-numbers language-haskell" data-language="haskell"><code class="language-haskell">filter :: (a -&gt; Bool) -&gt; [a] -&gt; [a]  
filter _ [] &#x3D; []  
filter p (x:xs)   
    | p x       &#x3D; x : filter p xs  
    | otherwise &#x3D; filter p xs<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>ä¼ å…¥åˆ¤æ–­å‡½æ•°, ä¼ å‡ºç¬¦åˆè¦æ±‚çš„å…ƒç´ </p><pre class="line-numbers language-haskell" data-language="haskell"><code class="language-haskell">filter (&gt;3) [1,5,3,2,1,6,4,3,2,1]         -- [5,6,4]  
filter (&#x3D;&#x3D;3) [1,2,3,4,5]                  -- [3]  
filter even [1..10]                       -- [2,4,6,8,10]  
let notNull x &#x3D; not (null x) in filter notNull [[1,2,3],[],[3,4,5],[2,2],[],[],[]]  
-- [[1,2,3],[3,4,5],[2,2]]  
filter (&#96;elem&#96; [&#39;a&#39;..&#39;z&#39;]) &quot;u LaUgH aT mE BeCaUsE I aM diFfeRent&quot;  
-- &quot;uagameasadifeent&quot;  
filter (&#96;elem&#96; [&#39;A&#39;..&#39;Z&#39;]) &quot;i lauGh At You BecAuse u r aLL the Same&quot;  
-- &quot;GAYBALLS&quot;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>ä»¥ä¸Šéƒ½å¯ä»¥ç”¨ <code>List Comprehension</code> çš„é™åˆ¶æ¡ä»¶æ¥å®ç°ã€‚å¹¶æ²¡æœ‰æ•™æ¡è§„å®šä½ å¿…é¡»åœ¨ä»€ä¹ˆæƒ…å†µä¸‹ç”¨ <code>map</code> å’Œ <code>filter</code> è¿˜æ˜¯ <code>List Comprehension</code>. å¦‚æœæœ‰å¤šä¸ªé™åˆ¶æ¡ä»¶ï¼Œåªèƒ½è¿ç€å¥—å¥½å‡ ä¸ª <code>filter</code> æˆ–ç”¨ <code>&amp;&amp;</code> ç­‰é€»è¾‘å‡½æ•°çš„ç»„åˆä¹‹, è¿™æ—¶å°±ä¸å¦‚ <code>List comprehension</code></p></li><li><p><code>fold</code>ç³»åˆ—å‡½æ•°æœ‰<code>foldl</code>, <code>foldlr</code>,<code>foldl1</code>, <code>foldlr1</code></p><pre class="line-numbers language-haskell" data-language="haskell"><code class="language-haskell">foldl&#39; :: (b -&gt; a -&gt; b) -&gt; b -&gt; [a] -&gt; b
foldl&#39; _ pre [] &#x3D; pre
foldl&#39; f pre (tar : tails) &#x3D; fold&#39; f (f pre tar) tails<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>ä¸<code>reduce</code>ç±»ä¼¼, å‚æ•°æœ‰: æŒ‡å®šè¿”å›ç´¯åŠ å€¼å‡½æ•°, ç´¯åŠ åˆå§‹å€¼, æ•°ç»„. ä¾‹å¦‚:</p><p>å®ç°æ•°ç»„æ±‚å’Œ</p><pre class="line-numbers language-haskell" data-language="haskell"><code class="language-haskell">sum&#39; :: (Num a) &#x3D;&gt; [a] -&gt; a  
sum&#39; &#x3D; foldl (+) 0<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>åˆçœç•¥å‚æ•°äº†, å› ä¸º<strong>æˆ‘ä»¬å®šä¹‰çš„æ˜¯å‡½æ•°, è€Œä¸æ˜¯è¿ç®—ç»“æœ</strong></p><p>å®ç°<code>reverse</code>(çœ‹æˆ‘æ˜¯å¤šè ¢ğŸ™ƒ)</p><pre class="line-numbers language-haskell" data-language="haskell"><code class="language-haskell">reverse&#39; :: [a] -&gt; [a]
reverse&#39; xs &#x3D; foldl (\acc x -&gt; x:acc) [] xs<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>é¦–å…ˆ<code>xs</code>æ˜¯å¯ä»¥çœç•¥çš„(<strong>æˆ‘ä»¬å®šä¹‰çš„æ˜¯å‡½æ•°, è€Œä¸æ˜¯è¿ç®—ç»“æœ</strong>)</p><p>å…¶æ¬¡<code>\acc x -&gt; x:acc</code>å®é™…ä¸Šå°±æ˜¯<code>flip (:)</code>äºæ˜¯æ”¹æˆ</p><pre class="line-numbers language-haskell" data-language="haskell"><code class="language-haskell">reverse&#39; :: [a] -&gt; [a]
reverse&#39; &#x3D; foldl (flip (:)) []<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p><code>foldr</code>ä¸<code>foldl</code>çš„åŒºåˆ«å°±æ˜¯å‰è€…æ˜¯è‡ªå³å‘å·¦éå†, ä¾‹å¦‚</p><pre class="line-numbers language-haskell" data-language="haskell"><code class="language-haskell">reverse&#39; :: [a] -&gt; [a]
reverse&#39; &#x3D; foldr (:) []

map&#39; :: (a -&gt; b) -&gt; [a] -&gt; [b]  
map&#39; f &#x3D; foldr (\x acc -&gt; f x : acc) []<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><code>foldl1</code> ä¸ <code>foldr1</code> çš„è¡Œä¸ºä¸ <code>foldl</code> å’Œ <code>foldr</code> ç›¸ä¼¼ï¼Œåªæ˜¯ä½ æ— éœ€æ˜ç¡®æä¾›åˆå§‹å€¼ã€‚ä»–ä»¬å‡å®š List çš„é¦–ä¸ª(æˆ–æœ«å°¾)å…ƒç´ ä½œä¸ºèµ·å§‹å€¼</p><p>å®ç°ä¸€äº›åº“å‡½æ•°</p><pre class="line-numbers language-haskell" data-language="haskell"><code class="language-haskell">maximum&#39; :: (Ord a) &#x3D;&gt; [a] -&gt; a  
maximum&#39; &#x3D; foldr1 (\x acc -&gt; if x &gt; acc then x else acc)  
product&#39; :: (Num a) &#x3D;&gt; [a] -&gt; a  
product&#39; &#x3D; foldr1 (*)  

filter&#39; :: (a -&gt; Bool) -&gt; [a] -&gt; [a]  
filter&#39; p &#x3D; foldr (\x acc -&gt; if p x then x : acc else acc) []  

head&#39; :: [a] -&gt; a  
head&#39; &#x3D; foldr1 (\x _ -&gt; x)  

last&#39; :: [a] -&gt; a  
last&#39; &#x3D; foldl1 (\_ x -&gt; x)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li><li><p><code>scan</code>ç³»åˆ—åŒ…æ‹¬<code>scanl</code>,<code>scanr</code>, <code>scanl1</code>å’Œ<code>scanr1</code>. å¯ä»¥ç®€å•ç†è§£ä¸º<code>scanl</code>,<code>scanr</code>è¿”å›çš„æ˜¯<code>foldl</code>, <code>foldr</code>çš„æ¯ä¸€æ­¥ä¸­é—´å€¼. <code>scanl1</code>å’Œ<code>scanr1</code>ä¸<code>foldl1</code>, <code>foldr1</code>ç±»ä¼¼</p><pre class="line-numbers language-haskell" data-language="haskell"><code class="language-haskell">scanl&#39; :: (a -&gt; b -&gt; b) -&gt; b -&gt; [a] -&gt; [b]
scanl&#39; f xs0 &#x3D; foldl (\aac x -&gt; aac ++ [f x (last aac)]) [xs0]<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>å¯ä»¥çœ‹åˆ°<code>scan*</code>ä¼¼ä¹æ˜¯è°ƒè¯•<code>fold*</code>çš„å¥½å·¥å…·</p></li></ul><p>ä¸ä¹‹å‰çš„è¯­æ³•ç»„åˆ, å¯ä»¥å‘ç°</p><ul><li><p><code>Lambda</code>è¡¨è¾¾å¼å¯ä»¥æ­é…è¿™äº›å‡½æ•°å®ç°ç‚«é…·æ•ˆæœ</p></li><li><p>å¯ä»¥ä½¿ç”¨<code>takeWhile</code>æ–¹ä¾¿çš„å¤„ç†ç”¨ä¸Šè¿°å‡½æ•°å¤„ç†æ— é™é•¿æ•°ç»„çš„ç»“æœ</p><pre class="line-numbers language-haskell" data-language="haskell"><code class="language-haskell">takeWhile&#39; :: (a -&gt; Bool) -&gt; [a] -&gt; [a]
takeWhile&#39; _ [] &#x3D; []
takeWhile&#39; f (x : xs)
  | f x &#x3D; x : takeWhile&#39; f xs
  | otherwise &#x3D; []<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre></li></ul><h4 id="ä¸.è°ƒç”¨"><code>$</code>ä¸<code>.</code>è°ƒç”¨</h4><ul><li><p><code>$</code>ä¹Ÿæ˜¯ä¸€ä¸ªå‡½æ•°</p><pre class="line-numbers language-haskell" data-language="haskell"><code class="language-haskell">($) :: (a -&gt; b) -&gt; a -&gt; b  
f $ x &#x3D; f x<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>ğŸ¤¨çœ‹èµ·æ¥å°±æ˜¯å°†è¿ä¸ªå‡½æ•°å’Œå‚æ•°è¿èµ·æ¥. å·®ä¸å¤š, ä½†æ˜¯åˆ«å¿˜äº†åœ¨Haskellä¸­å‡½æ•°è°ƒç”¨å…·æœ‰æœ€é«˜ä¼˜å…ˆçº§(ä¸”æ˜¯å·¦ç»“åˆ, å³: åŒçº§è¡¨è¾¾å¼è‡ªå³å‘å·¦è®¡ç®—, ä¾‹å¦‚ f a b = (f a) b, å¯ä»¥ç²—æš´ç†è§£æˆå°†å·¦è¾¹çš„ç»“åˆåœ¨ä¸€èµ·), ä½†æ˜¯è¿™é‡Œçš„<code>$</code>å…·æœ‰æœ€ä½ä¼˜å…ˆçº§(ä¸”æ˜¯å³ç»“åˆ, å³: åŒçº§è¡¨è¾¾å¼è‡ªå·¦å‘å³è®¡ç®—, ä¾‹å¦‚ f $ a b = f (a b), å¯ä»¥ç²—æš´ç†è§£æˆå°†å³è¾¹çš„ç»“åˆåœ¨ä¸€èµ·)</p><p>ä¾‹å¦‚</p><pre class="line-numbers language-haskell" data-language="haskell"><code class="language-haskell">t &#x3D; max 5 max 6 7<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>åœ¨Haskellä¸­ä¼šæŠ¥é”™, åŸå› æ˜¯Haskellå°†ä»£ç ç†è§£æˆäº†(å·¦ç»“åˆäº†)</p><pre class="line-numbers language-haskell" data-language="haskell"><code class="language-haskell">t &#x3D; ((max 5) max) 6 7<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>æˆ‘ä»¬åªèƒ½æ·»åŠ æ‹¬å·</p><pre class="line-numbers language-haskell" data-language="haskell"><code class="language-haskell">t &#x3D; max 5 (max 6 7)<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>å¦ä¸€ä¸ªæ–¹å¼å°±æ˜¯ä½¿ç”¨<code>$</code></p><pre class="line-numbers language-haskell" data-language="haskell"><code class="language-haskell">t &#x3D; max 5 $ max 6 7
--  |---| å…ˆè§£æè¿™ä¸€æ®µè¿”å›ä¸€ä¸ªå‡½æ•°
--        ^ é‡åˆ°äº†$äºæ˜¯æ— æ³•è§£æ, è§£æå³è¾¹
--          |------|è§£æè¿™ä¸€æ®µçš„å¾—åˆ°7
--  (max 5) 7  å˜æˆäº†è¿™æ ·
-- æœ€åå¾—åˆ°7<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>çœ‹<code>$</code>èµ·æ¥å°±åƒæ˜¯ä¸ºå·¦å³ä¸¤è¾¹åˆ†åˆ«åŠ äº†ç­‰ä¼˜å…ˆçº§çš„éš”ç¦»ç¬¦(æ‹¬å·)<strong>ä»è€Œä¿æŠ¤ä¸¤è¾¹åˆ†åˆ«è®¡ç®—</strong>, ä¾‹å¦‚</p><pre class="line-numbers language-haskell" data-language="haskell"><code class="language-haskell">map ($ 3) [(4+),(10*),(^2),sqrt]  
-- [7.0,30.0,9.0,1.7320508075688772]<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>âš ï¸ä½†æ˜¯æ³¨æ„<code>$</code>å³ç»“åˆçš„, æ˜¯å•å€¼å‡½æ•°(å·¦è¾¹æ˜¯<strong>å‡½æ•°</strong>å³è¾¹æ˜¯<strong>å•å‚æ•°</strong>). å¯èƒ½ä½ ä¼šæƒ³Haskellä¸­çš„å‡½æ•°æœ¬èº«å°±æ˜¯æŸ¯é‡ŒåŒ–çš„å‡½æ•°ğŸ™„? ä¼¼ä¹æ²¡æœ‰ä»€ä¹ˆå½±å“?ğŸ¤¨ äºæ˜¯æƒ³å½“ç„¶çš„è¿›è¡Œå¦‚ä¸‹æ”¹è¿›</p><pre class="line-numbers language-haskell" data-language="haskell"><code class="language-haskell">t :: [(Int, Int)]
t &#x3D; zip (map (+ 5) [1 .. 10]) (map (* 5) [10 .. 20])
-- æ”¹ä¸º --&gt;
t &#x3D; zip $ map (+ 5) [1 .. 10] $ map (* 5) [10 .. 20]<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>ğŸ¤¨çœ‹èµ·æ¥æ˜¯å¯è¡Œçš„</p><pre class="line-numbers language-haskell" data-language="haskell"><code class="language-haskell">-- Step 1
zip $ [6..15] $ [10..100]
-- Step 2
(zip [6..15]) [10..100]
-- Step 3
newFunction [10..100]<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>ğŸ’€æ‰§è¡Œå°±å‡ºé—®é¢˜, åˆ«å¿˜äº†<code>$</code>æ˜¯ä½ä¼˜å…ˆçº§å³ç»“åˆçš„, Haskellæ˜¯è¿™ä¹ˆç†è§£ä»£ç çš„</p><pre class="line-numbers language-haskell" data-language="haskell"><code class="language-haskell">-- Step 1 $ æ˜¯ä½ä¼˜å…ˆçº§çš„, å…¶ä»–å…ˆè®¡ç®—
zip $ [6..15] $ [10..100]
-- Step 2 $ æ˜¯å³ç»“åˆçš„...
zip ([6..15] $ [10..100])<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>å·¦è¾¹ç®—å‡ºæ¥æ˜¯ä¸ªList, ä¸æ˜¯<code>$</code>æ¥æ”¶çš„å‡½æ•°, å¦‚ä½•éªŒè¯å‘¢? è¿™æ ·æ”¹</p><pre class="line-numbers language-haskell" data-language="haskell"><code class="language-haskell">t :: [b] -&gt; [(Integer, b)]
t &#x3D; zip $ map (+ 5) [1 .. 10]

tt :: [(Integer, Integer)]
tt &#x3D; t $ map (* 5) [10 .. 20]<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>å®é™…ä¸ŠVSCodeçš„HLintæ’ä»¶å› ä¸ºç»™æˆ‘ä»¬æç¤º</p><pre class="line-numbers language-haskell" data-language="haskell"><code class="language-haskell">However, $ has low, right-associative binding precedence, so it sometimes allows parentheses to be omitted; for example:

f $ g $ h x  &#x3D;  f (g (h x))
It is also useful in higher-order situations, such as map ($ 0) xs, or Data.List.zipWith ($) fs xs<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>çœ‹åˆ°äº†å§, ä¸èƒ½å°†<code>$</code>äº†ç†è§£ä¸ºè·¯éšœğŸš§, ç®€å•çš„å°†ä»£ç å·¦å³åŠ ä¸Šæ‹¬å·, è€Œæ˜¯ä¸€ä¸ªç½‘ğŸ•¸ï¸, å°†<code>$</code>åé¢çš„éƒ½åŒ…èµ·æ¥</p><pre class="line-numbers language-haskell" data-language="haskell"><code class="language-haskell">f $ g x $ h x --ç†è§£ä¸º--&gt; f (g x) (h x)  ğŸ’©
f $ g x $ h x --ç†è§£ä¸º--&gt; f (g x (h x))  ğŸ‘<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p><del>æ¯•ç«Ÿ<code>$</code>ğŸ’µä»æ¥ä¸æ˜¯éšœç¢ğŸš§, è€Œæ˜¯é™·é˜±æŠŠä½ åŒ…èµ·æ¥ğŸ•¸ï¸</del></p><p>ğŸ˜²<code>$</code> <strong>è¿˜å¯ä»¥å°†æ•°æ®ä½œä¸ºå‡½æ•°ä½¿ç”¨</strong> ä¾‹å¦‚æ˜ å°„ä¸€ä¸ªå‡½æ•°è°ƒç”¨ç¬¦åˆ°ä¸€ç»„å‡½æ•°ç»„æˆçš„ Listï¼š</p><pre class="line-numbers language-haskell" data-language="haskell"><code class="language-haskell">map ($ 3) [(4+),(10*),(^2),sqrt]<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></li><li><p><code>.</code>è°ƒç”¨(Function composition, å‡½æ•°ç»„åˆ)</p><pre class="line-numbers language-haskell" data-language="haskell"><code class="language-haskell">(.) :: (b -&gt; c) -&gt; (a -&gt; b) -&gt; a -&gt; c    
-- æ³¨æ„, è¿™é‡Œè¦æ±‚å‡½æ•°çš„è¿”å›å€¼ä¸ä¸‹ä¸€ä¸ªå‡½æ•°çš„å‚æ•°ç±»å‹æ˜¯ç›¸åŒçš„
f . g &#x3D; \x -&gt; f (g x)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>ä¸æ•°å­¦ä¸­çš„å¤åˆå‡½æ•°ç±»ä¼¼, æˆ‘ä»¬å¯ä»¥è¿™æ ·è¡¨ç¤ºç»„åˆå‡½æ•° <span class="math display">\[ f(g(x)) = (f \circ g)(x) \]</span> åœ¨Haskellä¸­æˆ‘ä»¬ä¹Ÿå¯ä»¥å°†<code>f (g x)</code>(æˆ–è€…<code>f $ g x</code>)è¡¨ç¤ºä¸º<code>f . g x</code></p><pre class="line-numbers language-haskell" data-language="haskell"><code class="language-haskell">f &#x3D; (+ 1)
g &#x3D; (* 10)

t1 :: Integer -&gt; Integer
t1 x &#x3D; f (g x)   -- æœ€ç®€å•çš„å½¢å¼

t2 :: Integer -&gt; Integer
t2 x &#x3D; f $ g x   -- æŠŠæ‹¬å·å¹²æ‰

-- t2&#39; :: Integer -&gt; Integer
-- t2&#39; &#x3D; f $ g   -- Error

t3 :: Integer -&gt; Integer
t3 &#x3D; f . g<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li>æˆ‘ä»¬å¹³æ—¶å†™çš„æ˜¯<code>t1</code>çš„å½¢å¼, ä¸ºäº†æ–¹ä¾¿çš„å†™<span class="math inline">\(f ( g (x) )\)</span>, æˆ‘ä»¬å¼•å…¥<code>$</code>. å¹¶å®ç°äº†<code>t2</code>å½¢å¼</li><li>æˆ‘ä»¬æƒ³æ¢æˆ<span class="math inline">\((f \circ g)(x)\)</span>å½¢å¼, è¿™æ—¶å°±éœ€è¦<code>.</code>è¿ç®—</li></ul><p>çœ‹èµ·æ¥<code>.</code>, <code>$</code>æ˜¯ç­‰ä»·çš„äº’æ¢å½¢å¼(<code>$</code>, <code>.</code>éƒ½æ˜¯å³ç»“åˆçš„), ä½†æ˜¯ä»–ä»¬çš„ç±»å‹æœ‰å¾ˆå¤§çš„åŒºåˆ«</p><pre class="line-numbers language-haskell" data-language="haskell"><code class="language-haskell">($) :: (a -&gt; b) -&gt; a -&gt; b  
(.) :: (b -&gt; c) -&gt; (a -&gt; b) -&gt; a -&gt; c  <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><ul><li><code>$</code>æ¥æ”¶<strong>å‡½æ•°ä¸å˜é‡</strong>, è¿”å›ä¸€ä¸ª<strong>å˜é‡</strong></li><li><code>.</code>æ¥æ”¶<strong>ä¸¤ä¸ªå‡½æ•°</strong>, è¿”å›ä¸€ä¸ª<strong>å‡½æ•°</strong></li></ul><p>æ²¡äººè¯´å˜é‡ä¸èƒ½æ˜¯ä¸€ä¸ªå‡½æ•°, å‡½æ•°ä¸èƒ½æ˜¯å˜é‡, ç›´è§‰çœ‹èµ·æ¥<code>$</code>ç”¨äºè¡¨è¾¾å¼<code>.</code>ç”¨äºå‡½æ•°, ä¾‹å¦‚</p><pre class="line-numbers language-haskell" data-language="haskell"><code class="language-haskell">map (\xs -&gt; negate (sum (tail xs))) [[1..5],[3..6],[1..7]]  
-- ä¼˜åŒ–ä¸º --&gt;
map (negate . sum . tail) [[1..5],[3..6],[1..7]]  
[-14,-15,-27]<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>å¯¹äºå¤šå‚å‡½æ•°, æˆ‘ä»¬å¯ä»¥å€Ÿç”¨<code>()</code>æˆ–<code>$</code></p><pre class="line-numbers language-haskell" data-language="haskell"><code class="language-haskell">sum (replicate 5 (max 6.7 8.9))
(sum . replicate 5 . max 6.7) 8.9
sum . replicate 5 . max 6.7 $ 8.9<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>ğŸ˜²<code>.</code><strong>å¦ä¸€ç”¨é€”å°±æ˜¯å®šä¹‰point free style</strong></p><ul><li><p>æ„Ÿè°¢æŸ¯é‡ŒåŒ–å‡½æ•°, å½“å‡½æ•°å‚æ•°æŒ‰é¡ºåºä»…ä»…å‡ºç°åœ¨å®ç°çš„å°¾éƒ¨æ—¶å€™æ—¶æˆ‘ä»¬å¯ä»¥å°†å‚æ•°çœç•¥, ä¾‹å¦‚</p><pre class="line-numbers language-haskell" data-language="haskell"><code class="language-haskell">myFun :: (Ord a) &#x3D;&gt; a -&gt; a -&gt; a
myFun x y &#x3D; max x y<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>ç®€åŒ–ä¸º</p><pre class="line-numbers language-haskell" data-language="haskell"><code class="language-haskell">myFun :: (Ord a) &#x3D;&gt; a -&gt; a -&gt; a
myFun &#x3D; max<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre></li><li><p>å¦‚æœå‚æ•°é¡ºåºå‡ºç°, ä½†æ˜¯å‚æ•°åœ¨æ‹¬å·å†…éƒ¨å‘¢?</p><pre class="line-numbers language-haskell" data-language="haskell"><code class="language-haskell">myFun x y &#x3D; (* 2) (max x y)<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>ä½¿ç”¨<code>.</code>å°†ä¸€ä¸ªå‚æ•°ä»æ‹¬å·ä¸­è§£æ”¾å‡ºæ¥</p><pre class="line-numbers language-haskell" data-language="haskell"><code class="language-haskell">myFun x &#x3D; (* 2) . max x<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><code>.</code>æ˜¯å³ç»“åˆçš„, æ‰€ä»¥æˆ‘ä»¬åªèƒ½è§£æ”¾ä¸€ä¸ªå‚æ•°</p><p>è¿™æ ·çš„çœç•¥å‚æ•°å½¢å¼å°±æ˜¯point free style</p></li></ul></li></ul><h3 id="æ¨¡å—">æ¨¡å—</h3><p>Haskell ä¸­çš„æ¨¡å—æ˜¯å«æœ‰ä¸€ç»„ç›¸å…³çš„å‡½æ•°ï¼Œå‹åˆ«å’Œå‹åˆ«ç±»çš„ç»„åˆã€‚è€Œ Haskell è¿›ç¨‹çš„æœ¬è´¨ä¾¿æ˜¯ä»ä¸»æ¨¡å—ä¸­å¼•ç”¨å…¶å®ƒæ¨¡å—å¹¶è°ƒç”¨å…¶ä¸­çš„å‡½æ•°æ¥æ‰§è¡Œæ“ä½œã€‚å…¶ä¸­ç¼ºçœè‡ªåŠ¨åŠ è½½çš„å‡½æ•°å‡åœ¨<code>Prelude</code>æ¨¡å—ä¸­. Haskellæ¨¡å—åŠ è½½è§„åˆ™ä¸Pythonç±»ä¼¼</p><pre class="line-numbers language-haskell" data-language="haskell"><code class="language-haskell">import Data.List             -- åŠ è½½Listæ¨¡å—
import Data.List(sort, nub)   -- ä»…åŠ è½½Listæ¨¡å—çš„sort&amp;nub
import Data.List hiding (nub) -- å¼•å…¥é™¤nubå¤–çš„Listæ¨¡å—(ä¸€èˆ¬ç”¨äºåå­—å†²çª)

sort [1,2,3]     -- ç›´æ¥è°ƒç”¨å³å¯, æ— éœ€æ¨¡å—å

import qualified Data.Map     -- å¼•å…¥Mapæ¨¡å—, ä½†æ˜¯ä½¿ç”¨éœ€è¦æŒ‡æ˜æ¨¡å—(ç”¨äºåå­—å†²çª)

Data.Map.sort [1,2,3]     -- æŒ‡æ˜æ¨¡å—åå¼•å…¥

import qualified Data.Map as M -- æŒ‡æ˜ç¼©å†™

M.sort [1,2,3]     -- æŒ‡æ˜æ¨¡å—åå¼•å…¥<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>åœ¨<code>ghci</code>ä¸­å¯ä»¥é‡‡ç”¨<code>:m æ¨¡å— [æ¨¡å—...]</code>çš„æ–¹å¼åŠ è½½</p><pre class="line-numbers language-haskell" data-language="haskell"><code class="language-haskell">:m Data.List Data.Map Data.Set<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h4 id="data.listæ¨¡å—"><code>Data.List</code>æ¨¡å—</h4><blockquote><p>æºç è§: <span class="exturl" data-url="aHR0cHM6Ly9oYWNrYWdlLmhhc2tlbGwub3JnL3BhY2thZ2UvYmFzZS00LjE2LjAuMC9kb2NzL3NyYy9EYXRhLUxpc3QuaHRtbA==">List<i class="fa fa-external-link-alt"></i></span> <span class="exturl" data-url="aHR0cHM6Ly9oYWNrYWdlLmhhc2tlbGwub3JnL3BhY2thZ2UvYmFzZS00LjE2LjAuMC9kb2NzL3NyYy9EYXRhLU9sZExpc3QuaHRtbA==">OldList<i class="fa fa-external-link-alt"></i></span></p><p>ä¸¤ä¸ªæ¨¡å—å…³ç³»:</p><pre class="line-numbers language-haskell" data-language="haskell"><code class="language-haskell">import Data.OldList hiding ( all, and, any, concat, concatMap, elem, find,
                             foldl, foldl1, foldl&#39;, foldr, foldr1, mapAccumL,
                             mapAccumR, maximum, maximumBy, minimum, minimumBy,
                             length, notElem, null, or, product, sum )<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre></blockquote><ul><li><p><code>intersperse</code>:</p><p>å°†å…ƒç´ ç½®äº List ä¸­æ¯<strong>å¯¹</strong>å…ƒç´ çš„ä¸­é—´</p><pre class="line-numbers language-haskell" data-language="haskell"><code class="language-haskell">intersperse&#39; :: a -&gt; [a] -&gt; [a]
intersperse&#39; _ [] &#x3D; []
intersperse&#39; _ [x] &#x3D; [x]
intersperse&#39; e (x : xs) &#x3D; x : e : intersperse&#39; e xs

intersperse&#39;&#39; :: a -&gt; [a] -&gt; [a]
intersperse&#39;&#39; _ [] &#x3D; []
intersperse&#39;&#39; e arr &#x3D; init $ foldr (\x aac -&gt; x : e : aac) [] arr<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li><li><p><code>intercalate</code> å–ä¸¤ä¸ª List ä½œå‚æ•°. å®ƒä¼šå°†ç¬¬ä¸€ä¸ª List äº¤å‰æ’å…¥ç¬¬äºŒä¸ª List ä¸­é—´ï¼Œå¹¶è¿”å›ä¸€ä¸ª List.</p><pre class="line-numbers language-haskell" data-language="haskell"><code class="language-haskell">intercalate&#39; :: [a] -&gt; [[a]] -&gt; [a]
intercalate&#39; _ [] &#x3D; []
intercalate&#39; _ [x] &#x3D; x
intercalate&#39; item (x : xs) &#x3D; x ++ item ++ intercalate&#39; item xs

intercalate&#39;&#39; :: [a] -&gt; [[a]] -&gt; [a]
intercalate&#39;&#39; item xs &#x3D; take (length mid - length item) mid
  where
    mid &#x3D; foldl (\aac x -&gt; aac ++ x ++ item) [] xs<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li><li><p><code>transpose</code> å‡½æ•°å¯ä»¥åè½¬ä¸€ç»„ List çš„ List. ä½ è‹¥æŠŠä¸€ç»„ List çš„ List çœ‹ä½œæ˜¯ä¸ª 2D çš„çŸ©é˜µï¼Œé‚£ <code>transpose</code> çš„æ“ä½œå°±æ˜¯å°†å…¶åˆ—è½¬ä¸ºè¡Œ</p><p>å°è¯•å®ç°ä¸€ä¸‹</p><ul><li><p>æœ€å¼€å§‹æˆ‘æƒ³ä¸åˆ°å¯ä»¥åŒæ—¶æ“ä½œå¤šæ•°ç»„åŒä¸€ä½ç½®çš„æ–¹æ³•, äºæ˜¯å€ŸåŠ©å‘½ä»¤å¼ç¼–ç¨‹çš„æ–¹æ³•æ„šè ¢å®ç°ğŸ™ƒ(ä½¿ç”¨List.Rangeå®ç°å¾ªç¯)</p><p><pre class="line-numbers language-haskell" data-language="haskell"><code class="language-haskell">transpose :: [[a]] -&gt; [[a]]
transpose xss &#x3D; [heads cur xss | cur &lt;- [0 .. (max2D xss - 1)]]
  where
    max2D xss &#x3D; foldl max 0 (map length xss)
    heads cur xss&#39; &#x3D; flat (map (\xs -&gt; if length xs &lt;&#x3D; cur then [] else [xs !! cur]) xss&#39;)
      where
        flat [] &#x3D; []
        flat (x : xs) &#x3D; x ++ flat xs<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></p></li><li><p>åæ¥æƒ³åˆ°</p><p>ğŸ¤”å¦‚æœè¿™æ˜¯Cè¯­è¨€, é‚£ä¹ˆäºŒç»´æ•°ç»„æœ¬è´¨å°±æ˜¯ä¸€ç»´æ•°ç»„ç»„åˆ, æ‰€ä»¥å¯ä»¥å°†ç¬¬äºŒè¡ŒåŒä¸€ä½ç½®çš„å…ƒç´ ç§»åŠ¨åˆ°ä¸Šä¸€è¡ŒåŒä½ç½®å³è¾¹å®ç°</p><p>ä½†æ˜¯åœ¨Haskellä¸­æ²¡æœ‰æŒ‡é’ˆè¿™ä¹ˆåº•å±‚çš„ä¸œè¥¿æŠŠçº¿æ€§ç»“æ„åˆ†ä¸ºäºŒç»´æ•°ç»„, ä½†æ˜¯æˆ‘ä»¬å¯ä»¥æ‰‹åŠ¨åˆ†ç•Œ</p><p>ğŸ˜<code>transpose'</code>å®ç°åŸç†å¤§æ¦‚æ˜¯</p><ol type="1"><li><p>å°†æ•°ç»„è½¬ä¸º3D</p><p><pre class="line-numbers language-haskell" data-language="haskell"><code class="language-haskell">[
    [1,2,3],
    [4,5,6],
    [7,8,9]
]
--&gt;
[
    [[1],[2],[3]],
    [[4],[5],[6]],
    [[7],[8],[9]]
]<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></p></li><li><p>ä¸¤ä¸¤åˆå¹¶</p><p><pre class="line-numbers language-haskell" data-language="haskell"><code class="language-haskell">[
    [[1],[2],[3]],
    [[4],[5],[6]],
    [[7],[8],[9]]
]
--&gt;
[
    [[1,4],[2,5],[3,6]],
    [[7],[8],[9]]
]
--&gt;
[
    [[1,4,7],[2,5,8],[3,6,9]],
]<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></p></li><li><p><code>transpose'''</code>å°±æ˜¯å°†ä¸åŒé•¿åº¦æ•°ç»„éƒ½<code>repeat</code>åˆ°ç­‰é•¿</p></li></ol><p>äºæ˜¯å¾—åˆ°</p><p><pre class="line-numbers language-haskell" data-language="haskell"><code class="language-haskell">-- æ™®é€šæ¬¾ğŸ‘‡
----- åˆå¹¶ä¸¤è¡Œ [7,8,9]-&gt;[[1,4],[2,5],[3,6]]-&gt;[[1,4,7],[2,5,8],[3,6,9]] 
mergeRow :: [[a]] -&gt; [[a]] -&gt; [[a]]
mergeRow &#x3D; zipWith (++)

----- å°†ä¸€ä¸ªä¸€ç»´æ•°ç»„è½¬åŒ–ä¸ºäºŒä½ [1,2,3] -&gt; [[1],[2],[3]]
form2D :: [a] -&gt; [[a]]
form2D &#x3D; map (: [])

transpose&#39; :: [[a]] -&gt; [[a]]
transpose&#39; &#x3D; foldl1 mergeRow . stakedForm
  where
    stakedForm &#x3D; map form2D

-- å‹è¡Œæ¬¾ğŸ‘‡ğŸ˜
transpose&#39;&#39; :: [[a]] -&gt; [[a]]
transpose&#39;&#39; &#x3D; foldl1 (zipWith (++)) . map (map (: []))

-- è§£å†³å¯¹ä¸é½ğŸ‘‡
transpose&#39;&#39;&#39; :: [[a]] -&gt; [[a]]
transpose&#39;&#39;&#39; &#x3D; foldl1 mergeRow&#39; . stakedForm
  where
    stakedForm &#x3D; map $ map (: [])
    mergeRow&#39; xs1 xs2 &#x3D; takeWhile (not . null) . zipWith (++) (infForm xs1) $ infForm xs2
      where
        infForm &#x3D; (++ repeat [])<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></p></li><li><p>ğŸ˜’ä½†æ˜¯ä¸å¤Ÿå‡½æ•°åŒ–, æˆ‘ä»¬ç›¸å½“äºå‘Šè¯‰Haskellæ‰§è¡Œçš„æ–¹å¼å°±æ˜¯æŠŠä¸¤ä¸ªListè¿èµ·æ¥, ç»§ç»­è¿›è¡Œä¸€ä¸‹ä¼˜åŒ–</p><p><pre class="line-numbers language-haskell" data-language="haskell"><code class="language-haskell">transpose&#39;&#39;&#39;&#39; :: [[a]] -&gt; [[a]]
transpose&#39;&#39;&#39;&#39; xs
  where
    zipWith&#39; _ [] yys &#x3D; yys
    zipWith&#39; _ xxs [] &#x3D; [[xx] | xx &lt;- xxs]
    zipWith&#39; f (xx : xxs) (yy : yys) &#x3D; f xx yy : zipWith&#39; f xxs yys
transpose&#39;&#39;&#39;&#39; [] &#x3D; []<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></p></li></ul></li><li><p><code>concat</code>å°†Listè¿èµ·æ¥(å»é™¤ä¸€å±‚åµŒå¥—)</p><pre class="line-numbers language-haskell" data-language="haskell"><code class="language-haskell">concat&#39; :: [[a]] -&gt; [a]
concat&#39; &#x3D; foldl1 (++)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre></li><li><p><code>concatMap</code>å°†Listè½¬æ¢ä¸ºäºŒç»´Listå†<code>concat</code></p><pre class="line-numbers language-haskell" data-language="haskell"><code class="language-haskell">concatMap&#39; :: [a -&gt; [b]] -&gt; [a] -&gt; [b]
concatMap&#39; f &#x3D; concat . (map f)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre></li><li><p><code>and</code>å–ä¸€ç»„å¸ƒå°”å€¼<code>List</code>ä½œå‚æ•°. åªæœ‰å…¶ä¸­çš„å€¼å…¨ä¸º<code>True</code>çš„æƒ…å†µä¸‹æ‰ä¼šè¿”å›<code>True</code>.</p><pre class="line-numbers language-haskell" data-language="haskell"><code class="language-haskell">and&#39; :: [Bool] -&gt; Bool
and&#39; &#x3D; foldl1 (&amp;&amp;)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre></li><li><p><code>or</code>ä¸€ç»„å¸ƒå°”å€¼<code>List</code>ä¸­è‹¥å­˜åœ¨ä¸€ä¸ª<code>True</code>å®ƒå°±è¿”å›<code>True</code></p><pre class="line-numbers language-haskell" data-language="haskell"><code class="language-haskell">or&#39; :: [Bool] -&gt; Bool
or&#39; &#x3D; foldl1 (||)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre></li><li><p><code>any</code>ä¸<code>all</code></p><pre class="line-numbers language-haskell" data-language="haskell"><code class="language-haskell">any&#39; :: [a -&gt; Bool] -&gt; [a]
any&#39; f &#x3D; or . (map f)

all&#39; :: [a -&gt; Bool] -&gt; [a]
all&#39; f &#x3D; and . (map f)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre></li><li><p><code>iterate</code>: å–ä¸€ä¸ªå‡½æ•°å’Œä¸€ä¸ªå€¼ä½œå‚æ•°. å®ƒä¼šç”¨è¯¥å€¼å»è°ƒç”¨è¯¥å‡½æ•°å¹¶ç”¨æ‰€å¾—çš„ç»“æœå†æ¬¡è°ƒç”¨è¯¥å‡½æ•°ï¼Œäº§ç”Ÿä¸€ä¸ªæ— é™çš„ List.</p><pre class="line-numbers language-haskell" data-language="haskell"><code class="language-haskell">iterate&#39; :: (a -&gt; a) -&gt; a -&gt; [a]
iterate&#39; f x &#x3D; x : iterate&#39; f (f x)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre></li><li><p><code>splitAt</code>å–ä¸€ä¸ª List å’Œæ•°å€¼ä½œå‚æ•°ï¼Œå°†è¯¥ List åœ¨ç‰¹å®šçš„ä½ç½®æ–­å¼€ã€‚è¿”å›ä¸€ä¸ªåŒ…å«ä¸¤ä¸ª List çš„äºŒå…ƒç»„.</p><pre class="line-numbers language-haskell" data-language="haskell"><code class="language-haskell">splitAt&#39; :: Int -&gt; [b] -&gt; ([b], [b])
splitAt&#39; n xs &#x3D; (lefts xs, rights)
  where
    len &#x3D; max 0 $ min (length xs) n
    lefts &#x3D; take len
    rights &#x3D; reverse . take (length xs - len) $ reverse xs<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>ä¾‹å¦‚</p><pre class="line-numbers language-haskell" data-language="haskell"><code class="language-haskell">let (a,b) &#x3D; splitAt 3 &quot;foobar&quot; in b ++ a  
-- &quot;barfoo&quot;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre></li><li><p><code>takeWhile</code>ä»ä¸€ä¸ª List ä¸­å–å…ƒç´ ï¼Œä¸€æ—¦é‡åˆ°ä¸ç¬¦åˆæ¡ä»¶çš„æŸå…ƒç´ å°±åœæ­¢.</p><pre class="line-numbers language-haskell" data-language="haskell"><code class="language-haskell">takeWhile&#39; :: (a -&gt; Bool) -&gt; [a] -&gt; [a]
takeWhile&#39; f (x : xs)
  | f x &#x3D; x : takeWhile&#39; f xs
  | otherwise &#x3D; []
takeWhile&#39; _ [] &#x3D; []<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre></li><li><p><code>dropWhile</code>ä¸<code>takeWhile</code>ç›¸ä¼¼ï¼Œä¸è¿‡æ˜¯æ‰”æ‰ç¬¦åˆæ¡ä»¶çš„å…ƒç´ ã€‚ä¸€æ—¦é™åˆ¶æ¡ä»¶è¿”å› <code>False</code>ï¼Œå®ƒå°±è¿”å› List çš„ä½™ä¸‹éƒ¨åˆ†.</p><pre class="line-numbers language-haskell" data-language="haskell"><code class="language-haskell">dropWhile&#39; :: (a -&gt; Bool) -&gt; [a] -&gt; [a]
dropWhile&#39; f (x : xs)
  | f x &#x3D; dropWhile&#39; f xs
  | otherwise &#x3D; xs
dropWhile&#39; _ [] &#x3D; []<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre></li><li><p><code>span</code>ä¸<code>break</code>è¿”å›é¦–æ¬¡å¤±è´¥/æˆåŠŸå·¦å³æ•°æ®</p><pre class="line-numbers language-haskell" data-language="haskell"><code class="language-haskell">span&#39; :: (a -&gt; Bool) -&gt; [a] -&gt; ([a], [a])
span&#39; f xs &#x3D; (takeWhile f xs, dropWhile f xs)

break&#39; :: (a -&gt; Bool) -&gt; [a] -&gt; ([a], [a])
break&#39; f &#x3D; span (not . f)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre></li><li><p><code>sort</code>æ’åºä¸€ä¸ª<code>List</code></p><pre class="line-numbers language-haskell" data-language="haskell"><code class="language-haskell">sort&#39; :: (Ord a)&#x3D;&gt;[a] -&gt; [a]
sort&#39; (tar:xs) &#x3D; lowers ++ [tar] ++ uppers
  where lowers &#x3D; sort&#39; [x|x&lt;-xs, x&lt;&#x3D;tar]
        uppers &#x3D; sort&#39; [x|x&lt;-xs, x&gt;tar]
sort&#39; [] &#x3D; []<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre></li><li><p><code>group</code>å–ä¸€ä¸ª List ä½œå‚æ•°ï¼Œå¹¶å°†å…¶ä¸­ç›¸é‚»å¹¶ç›¸ç­‰çš„å…ƒç´ å„è‡ªå½’ç±»ï¼Œç»„æˆä¸€ä¸ªä¸ªå­ List.</p><pre class="line-numbers language-haskell" data-language="haskell"><code class="language-haskell">group&#39; :: Eq a &#x3D;&gt; [a] -&gt; [[a]]
group&#39; (x : xs)
  | null res &#x3D; [[x]]
  | x &#x3D;&#x3D; head headx &#x3D; (x : headx) : tail res
  | otherwise &#x3D; [x] : res
  where
    res &#x3D; group&#39; xs
    headx &#x3D; head res
group&#39; [] &#x3D; []

-- çœ‹ä¸‹æºç çš„å®ç°æ¨¡å¼

group&#39; :: Eq a &#x3D;&gt; [a] -&gt; [[a]]
group&#39; [] &#x3D; []
group&#39; (x : xs) &#x3D; (x : ys) : group&#39; zs
  where
    (ys, zs) &#x3D; span (&#x3D;&#x3D; x) xs<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>ç»Ÿè®¡å…ƒç´ å‡ºç°æ¬¡æ•°</p><pre class="line-numbers language-haskell" data-language="haskell"><code class="language-haskell">ghci&gt; map (\l@(x:xs) -&gt; (x,length l)) . group . sort $ [1,1,1,1,2,2,2,2,3,3,2,2,2,5,6,7]  
-- [(1,4),(2,7),(3,2),(5,1),(6,1),(7,1)]<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre></li><li><p><code>inits</code> å’Œ <code>tails</code> ä¸ <code>init</code> å’Œ <code>tail</code> ç›¸ä¼¼ï¼Œåªæ˜¯å®ƒä»¬ä¼šé€’å½’åœ°è°ƒç”¨è‡ªèº«ç›´åˆ°ä»€ä¹ˆéƒ½ä¸å‰©</p><pre class="line-numbers language-haskell" data-language="haskell"><code class="language-haskell">inits&#39; :: [a] -&gt; [[a]]
inits&#39; xs &#x3D; scanr (\_ acc -&gt; init acc) xs xs

tails&#39; :: [a] -&gt; [[a]]
tails&#39; xs &#x3D; scanl (\acc _ -&gt; tail acc) xs xs<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre></li><li><p><code>isInfixOf</code>æ•°ç»„æ¨¡å¼åŒ¹é…</p><pre class="line-numbers language-haskell" data-language="haskell"><code class="language-haskell">import Data.List (tails)

isInfixOf&#39; :: Eq a &#x3D;&gt; [a] -&gt; [a] -&gt; Bool
isInfixOf&#39; needle haystack &#x3D; foldl (\acc x -&gt; acc || take len x &#x3D;&#x3D; needle) False $ tails haystack
  where
    len &#x3D; length needle<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li><li><p><code>isPrefixOf</code>ä¸<code>isSuffixOf</code>åˆ†åˆ«æ£€æŸ¥ä¸€ä¸ª List æ˜¯å¦ä»¥æŸå­ List å¼€å¤´æˆ–è€…ç»“å°¾.</p><pre class="line-numbers language-haskell" data-language="haskell"><code class="language-haskell">isPrefixOf&#39; :: (Eq a) &#x3D;&gt; [a] -&gt; [a] -&gt; Bool
isPrefixOf&#39; needle haystack &#x3D; needle &#x3D;&#x3D; take len haystack
  where
    len &#x3D; length needle

isSuffixOf&#39; :: (Eq a) &#x3D;&gt; [a] -&gt; [a] -&gt; Bool
isSuffixOf&#39; needle haystack &#x3D; reverse needle &#x3D;&#x3D; take len (reverse haystack)
  where
    len &#x3D; length needle<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li><li><p><code>elem</code>ä¸<code>notElem</code>æ£€æŸ¥ä¸€ä¸ª List æ˜¯å¦åŒ…å«æŸå…ƒç´ .</p><pre class="line-numbers language-haskell" data-language="haskell"><code class="language-haskell">elem&#39; :: Eq a &#x3D;&gt; a -&gt; [a] -&gt; Bool
elem&#39; v &#x3D; foldl (\acc x -&gt; acc || x &#x3D;&#x3D; v) False

notElem&#39; :: Eq a &#x3D;&gt; a -&gt; [a] -&gt; Bool
notElem&#39; v xs &#x3D; not (elem&#39; v xs)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre></li><li><p><code>partition</code> å–ä¸€ä¸ªé™åˆ¶æ¡ä»¶å’Œ List ä½œå‚æ•°ï¼Œè¿”å›ä¸¤ä¸ª Listï¼Œç¬¬ä¸€ä¸ª List ä¸­åŒ…å«æ‰€æœ‰ç¬¦åˆæ¡ä»¶çš„å…ƒç´ ï¼Œè€Œç¬¬äºŒä¸ª List ä¸­åŒ…å«ä½™ä¸‹çš„.</p><pre class="line-numbers language-haskell" data-language="haskell"><code class="language-haskell">partition&#39; :: (a -&gt; Bool) -&gt; [a] -&gt; ([a], [a])
partition&#39; p &#x3D; foldr (select&#39; p) ([], [])

select&#39; :: (a -&gt; Bool) -&gt; a -&gt; ([a], [a]) -&gt; ([a], [a])
select&#39; p x (ts, fs)
  | p x &#x3D; (x : ts, fs)
  | otherwise &#x3D; (ts, x : fs)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><code>partition</code>ä¸<code>span</code> å’Œ <code>break</code> ä¸åŒ, <code>span</code> å’Œ <code>break</code> ä¼šåœ¨é‡åˆ°ç¬¬ä¸€ä¸ªç¬¦åˆæˆ–ä¸ç¬¦åˆæ¡ä»¶çš„å…ƒç´ å¤„æ–­å¼€ï¼Œè€Œ <code>partition</code> åˆ™ä¼šéå†æ•´ä¸ª List</p></li><li><p><code>find</code> å–ä¸€ä¸ª List å’Œé™åˆ¶æ¡ä»¶ä½œå‚æ•°ï¼Œå¹¶è¿”å›é¦–ä¸ªç¬¦åˆè¯¥æ¡ä»¶çš„å…ƒç´ ï¼Œè€Œè¿™ä¸ªå…ƒç´ æ˜¯ä¸ª <code>Maybe</code> å€¼ï¼Œ<code>Maybe</code> å€¼æ˜¯ <code>Just something</code> æˆ– <code>Nothing</code>ã€‚ä¸ä¸€ä¸ª List å¯ä»¥ä¸ºç©ºä¹Ÿå¯ä»¥åŒ…å«å¤šä¸ªå…ƒç´ ç›¸ä¼¼ï¼Œä¸€ä¸ª <code>Maybe</code> å¯ä»¥ä¸ºç©ºï¼Œä¹Ÿå¯ä»¥æ˜¯å•ä¸€å…ƒç´ ã€‚åŒæ ·ä¸ List ç±»ä¼¼ï¼Œä¸€ä¸ª Int å‹çš„ List å¯ä»¥å†™ä½œ <code>[Int]</code>ï¼Œ<code>Maybe</code>æœ‰ä¸ª Int å‹å¯ä»¥å†™ä½œ <code>Maybe Int</code>ã€‚å…ˆè¯•ä¸€ä¸‹ <code>find</code> å‡½æ•°å†è¯´.</p><pre class="line-numbers language-haskell" data-language="haskell"><code class="language-haskell">find (&gt;4) [1,2,3,4,5,6]  
-- Just 5  
find (&gt;9) [1,2,3,4,5,6]  
-- Nothing  
:t find  
-- find :: (a -&gt; Bool) -&gt; [a] -&gt; Maybe a<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li><li><p><code>elemIndex</code> ä¸ <code>elem</code> ç›¸ä¼¼ï¼Œåªæ˜¯å®ƒè¿”å›çš„ä¸æ˜¯å¸ƒå°”å€¼ï¼Œå®ƒåªæ˜¯'å¯èƒ½' (Maybe)è¿”å›æˆ‘ä»¬æ‰¾çš„å…ƒç´ çš„ç´¢å¼•ï¼Œè‹¥è¿™ä¸€å…ƒç´ ä¸å­˜åœ¨ï¼Œå°±è¿”å› <code>Nothing</code>ã€‚</p><pre class="line-numbers language-haskell" data-language="haskell"><code class="language-haskell">:t elemIndex  
elemIndex :: (Eq a) &#x3D;&gt; a -&gt; [a] -&gt; Maybe Int  
4 &#96;elemIndex&#96; [1,2,3,4,5,6]  
-- Just 3  
10 &#96;elemIndex&#96; [1,2,3,4,5,6]  
-- Nothing<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li><li><p><code>elemIndices</code>ä¸ <code>elemIndex</code> ç›¸ä¼¼ï¼Œåªä¸è¿‡å®ƒè¿”å›çš„æ˜¯æ‰€æœ‰æ»¡è¶³æ¡ä»¶çš„<code>List</code></p><pre class="line-numbers language-haskell" data-language="haskell"><code class="language-haskell">elemIndices&#39; :: (Eq a) &#x3D;&gt; a -&gt; [a] -&gt; [Integer]
elemIndices&#39; target xs &#x3D; [cur| (x, cur) &lt;- zip xs [0..], x &#x3D;&#x3D; target]<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre></li><li><p><code>findIndex</code>ä¸<code>elemIndices</code>ç±»ä¼¼, ä½†ä¹‹è¿”å›ç¬¬ä¸€ä¸ªæ»¡è¶³æ¡ä»¶çš„ç´¢å¼•çš„Maybe</p></li><li><p><code>zip*</code>, <code>zipWith*</code>æ”¯æŒå¤šæ•°ç»„<code>zip</code>(æœ€å¤§åˆ°<code>zip7</code>)</p><pre class="line-numbers language-haskell" data-language="haskell"><code class="language-haskell">zip4 [2,3,3] [2,2,2] [5,5,3] [2,2,2]  
-- [(2,2,5,2),(3,2,5,2),(3,2,3,2)]<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre></li><li><p><code>lines</code>æ ¹æ®æ¢è¡Œç¬¦<code>split</code></p><pre class="line-numbers language-haskell" data-language="haskell"><code class="language-haskell">lines&#39; :: String -&gt; [String]
lines&#39; xs
  | null snds &#x3D; [fsts]
  | otherwise &#x3D; fsts : lines&#39; (tail snds)
  where
    (fsts, snds) &#x3D; span (&#x2F;&#x3D; &#39;\n&#39;) xs<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li><li><p><code>unlines</code>æ˜¯ <code>lines</code> çš„åå‡½æ•°ï¼Œå®ƒå–ä¸€ç»„å­—ä¸²çš„ <code>List</code>ï¼Œå¹¶å°†å…¶é€šè¿‡ <code>'\n'</code>åˆå¹¶åˆ°ä¸€å—.</p><pre class="line-numbers language-haskell" data-language="haskell"><code class="language-haskell">unlines&#39; :: [String] -&gt; String
unlines&#39; &#x3D; foldl (\acc x -&gt; acc ++ x ++ [&#39;\n&#39;]) &quot;&quot;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre></li><li><p><code>words</code>å’Œ<code>unwords</code>å¯ä»¥æŠŠä¸€ä¸ªå­—ä¸²åˆ†ä¸ºä¸€ç»„å•è¯æˆ–æ‰§è¡Œç›¸åçš„æ“ä½œ</p><pre class="line-numbers language-haskell" data-language="haskell"><code class="language-haskell">words &quot;hey these are the words in this\nsentence&quot;  
-- [&quot;hey&quot;,&quot;these&quot;,&quot;are&quot;,&quot;the&quot;,&quot;words&quot;,&quot;in&quot;,&quot;this&quot;,&quot;sentence&quot;]  
unwords [&quot;hey&quot;,&quot;there&quot;,&quot;mate&quot;]  
-- &quot;hey there mate&quot;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>å…¶ä¸­é—´éš”ç¬¦åˆ¤æ–­é‡‡ç”¨<code>Data.Char.isSpace</code></p><pre class="line-numbers language-haskell" data-language="haskell"><code class="language-haskell">isSpace c
  | uc &lt;&#x3D; 0x377 &#x3D; uc &#x3D;&#x3D; 32 || uc - 0x9 &lt;&#x3D; 4 || uc &#x3D;&#x3D; 0xa0
  | otherwise &#x3D; iswspace (ord c) &#x2F;&#x3D; 0
  where
    uc &#x3D; fromIntegral (ord c) :: Word<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>å³å…¨éƒ¨Unicodeç©ºæ ¼ä¸ <code>\t</code>, <code>\n</code>, <code>\r</code>, <code>\f</code>, <code>\v</code></p></li><li><p><code>delete</code>å–ä¸€ä¸ªå…ƒç´ å’Œ List ä½œå‚æ•°ï¼Œä¼šåˆ æ‰è¯¥ List ä¸­é¦–æ¬¡å‡ºç°çš„è¿™ä¸€å…ƒç´ .</p><pre class="line-numbers language-haskell" data-language="haskell"><code class="language-haskell">delete &#39;h&#39; &quot;hey there ghang!&quot;  
-- &quot;ey there ghang!&quot;  <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre></li><li><p><code>\</code>ç±»ä¼¼æŸ¥é›†, åœ¨æ’å…¥æ—¶æ£€æŸ¥å…ƒç´ æ˜¯å¦å·²ç»å­˜åœ¨, âš ä½†ä¸å»é‡å·¦æ“ä½œæ•°, ä¸å»é‡å³æ“ä½œæ•°</p><pre class="line-numbers language-haskell" data-language="haskell"><code class="language-haskell">ghci&gt; [1,2,2,3] \\ [2,2,3,3,4]
-- [1]
ghci&gt; [1,2,2,3] \\ [2,3,3,4]
-- [1,2]<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre></li><li><p><code>union</code>ç±»ä¼¼å¹¶é›†, åœ¨æ’å…¥æ—¶æ£€æŸ¥å…ƒç´ æ˜¯å¦å·²ç»å­˜åœ¨, âš ä¸å»é‡å·¦æ“ä½œæ•°</p><pre class="line-numbers language-haskell" data-language="haskell"><code class="language-haskell">[1,2,3,3] &#96;union&#96; [2,2,5,9]
-- [1,2,3,3,5,9]<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre></li><li><p><code>intersect</code>ç±»ä¼¼äº¤é›†, åœ¨æ’å…¥æ—¶æ£€æŸ¥å…ƒç´ æ˜¯å¦å·²ç»å­˜åœ¨, âš ä¸å»é‡å·¦æ“ä½œæ•°</p><pre class="line-numbers language-haskell" data-language="haskell"><code class="language-haskell">intersect [1,2,2,3] [2,2,2,3,3,4]
-- [2,2,3]<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre></li><li><p><code>insert</code>å¯ä»¥å°†ä¸€ä¸ªå…ƒç´ æ’å…¥ä¸€ä¸ª<strong>å¯æ’åº(è€Œä¸æ˜¯å·²æ’åº)</strong>çš„<code>List</code>, å¹¶å°†å…¶ç½®äºé¦–ä¸ªå¤§äºç­‰äºå®ƒçš„å…ƒç´ ä¹‹å‰ï¼Œå¦‚æœä½¿ç”¨ <code>insert</code> æ¥ç»™ä¸€ä¸ªæ’è¿‡åºçš„ List æ’å…¥å…ƒç´ ï¼Œè¿”å›çš„ç»“æœä¾ç„¶æ˜¯æ’åºçš„.</p><pre class="line-numbers language-haskell" data-language="haskell"><code class="language-haskell">insert 4 [1,2,3,5,6,7]  
--[1,2,3,4,5,6,7]  
insert &#39;g&#39; $ [&#39;a&#39;..&#39;f&#39;] ++ [&#39;h&#39;..&#39;z&#39;]  
-- &quot;abcdefghijklmnopqrstuvwxyz&quot;  
insert 3 [1,2,4,3,2,1]  
-- [1,2,3,4,3,2,1]<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li><li><p><code>length</code>,<code>take</code>,<code>drop</code>,<code>splitAt</code>,<code>!!</code>,<code>replicate</code>éƒ½æœ‰ä¸€ä¸ª<code>generic*</code>ç‰ˆæœ¬, åŒºåˆ«å°±æ˜¯å°†ç±»å‹å‚æ•°ä¸­çš„<code>Int</code>æ›¿æ¢ä¸º<code>Num</code>, ä¾‹å¦‚</p><pre class="line-numbers language-haskell" data-language="haskell"><code class="language-haskell">:t genericLength 
-- genericLength :: Num i &#x3D;&gt; [a] -&gt; i
:t length 
-- length :: Foldable t &#x3D;&gt; t a -&gt; Int<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre></li><li><p><code>nub</code>, <code>delete</code>, <code>union</code>, <code>intsect</code> , <code>group</code> éƒ½æœ‰<code>*By</code>ç‰ˆæœ¬, å®ƒä»¬çš„åŒºåˆ«å°±æ˜¯å‰ä¸€ç»„å‡½æ•°ä½¿ç”¨ <code>(==)</code> æ¥æµ‹è¯•æ˜¯å¦ç›¸ç­‰ï¼Œè€Œå¸¦ <code>By</code> çš„é‚£ç»„åˆ™å–ä¸€ä¸ªå‡½æ•°ä½œå‚æ•°æ¥åˆ¤å®šç›¸ç­‰æ€§ï¼Œ<code>group</code> å°±ä¸ <code>groupBy (==)</code> ç­‰ä»·</p><p>ä¾‹å¦‚å°†ç›¸é‚»ä¸”åŒå·å…ƒç´ æ”¾ä¸€èµ·</p><pre class="line-numbers language-haskell" data-language="haskell"><code class="language-haskell">let values &#x3D; [-4.3,-2.4,-1.2,0.4,2.3,5.9,10.5,29.1,5.3,-2.4,-14.5,2.9,2.3]  
groupBy (\x y -&gt; (x &gt; 0) &#x3D;&#x3D; (y &gt; 0)) values  
-- [[-4.3,-2.4,-1.2],[0.4,2.3,5.9,10.5,29.1,5.3],[-2.4,-14.5],[2.9,2.3]]<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre></li><li><p><code>on</code>å‡½æ•°</p><pre class="line-numbers language-haskell" data-language="haskell"><code class="language-haskell">on :: (b -&gt; b -&gt; c) -&gt; (a -&gt; b) -&gt; a -&gt; a -&gt; c  
f &#96;on&#96; g &#x3D; \x y -&gt; f (g x) (g y)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>ä¾‹å¦‚ä¸Šé¢åŠŸèƒ½å¯ä»¥äº›ä¸º</p><pre class="line-numbers language-haskell" data-language="haskell"><code class="language-haskell">groupBy ((&#x3D;&#x3D;) &#96;on&#96; (&gt; 0)) values  
-- [[-4.3,-2.4,-1.2],[0.4,2.3,5.9,10.5,29.1,5.3],[-2.4,-14.5],[2.9,2.3]]<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre></li><li><p><code>sort</code>ï¼Œ<code>insert</code>ï¼Œ<code>maximum</code>, <code>min</code>éƒ½æœ‰<code>*By</code>, åˆ¤åˆ«å‡½æ•°è¿”å›<code>Ordering</code>ç±»å‹(<code>LT</code>,<code>EQ</code>,<code>GT</code>)</p><p>ä¾‹å¦‚æŒ‰ç…§<code>List</code>é•¿åº¦å°†äºŒç»´<code>List</code>æ’åº</p><pre class="line-numbers language-haskell" data-language="haskell"><code class="language-haskell">xs &#x3D; [[5,4,5,4,4],[1,2,3],[3,5,4,3],[],[2],[2,2]]  
sortBy (compare &#96;on&#96; length) xs  
-- [[],[2],[2,2],[1,2,3],[3,5,4,3],[5,4,5,4,4]]<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre></li></ul><h4 id="data.charæ¨¡å—"><code>Data.Char</code>æ¨¡å—</h4><ul><li><p>èŒƒå›´åˆ¤æ–­å‡½æ•°</p><ul><li><code>isControl</code>: æ˜¯å¦æ˜¯æ§åˆ¶å­—</li><li><code>isSpace</code>: æ˜¯å¦æ˜¯ç©ºæ ¼</li><li><code>isUper</code>: æ˜¯å¦ä¸ºå¤§å†™</li><li><code>isAlpha</code>: æ˜¯å¦ä¸ºå­—æ¯</li><li><code>isAlphaNum</code>: æ˜¯å¦ä¸ºå­—æ¯æˆ–æ•°å­—</li><li><code>isPrint</code>: æ˜¯å¦æ˜¯å¯æ‰“å°çš„</li><li><code>isDigit</code>: æ˜¯å¦ä¸ºæ•°å­—.</li><li><code>isOctDigit</code>: æ˜¯å¦ä¸ºå…«è¿›åˆ¶æ•°å­—</li><li><code>isHexDigit</code>: æ˜¯å¦ä¸ºåå…­è¿›åˆ¶æ•°å­—</li><li><code>isLetter</code>: æ˜¯å¦ä¸ºå­—æ¯</li><li><code>isMark</code>: æ˜¯å¦ä¸º<code>unicode</code>æ³¨éŸ³å­—ç¬¦(å¦‚: <code>Ã©</code>).</li><li><code>isNumber</code>: æ˜¯å¦ä¸ºæ•°å­—</li><li><code>isPunctuation</code>:æ˜¯å¦ä¸ºæ ‡ç‚¹ç¬¦å·</li><li><code>isSymbol</code>: æ˜¯å¦ä¸ºè´§å¸ç¬¦å·</li><li><code>isSeperater</code>: æ˜¯å¦ä¸º<code>unicode</code>ç©ºæ ¼æˆ–åˆ†éš”ç¬¦.</li><li><code>isAscii</code>: æ˜¯å¦åœ¨<code>unicode</code>å­—æ¯è¡¨çš„å‰ 128 ä½</li><li><code>isLatin1</code>: æ˜¯å¦åœ¨<code>unicode</code>å­—æ¯è¡¨çš„å‰ 256 ä½.</li><li><code>isAsciiUpper</code>: æ˜¯å¦ä¸ºå¤§å†™çš„ ascii å­—ç¬¦</li><li><code>isAsciiLower</code>: æ˜¯å¦ä¸ºå°å†™çš„ ascii å­—ç¬¦</li></ul><p>å®ç°<code>words</code>å‡½æ•°</p><pre class="line-numbers language-haskell" data-language="haskell"><code class="language-haskell">words xs&#x3D; filter (not . any isSpace) . groupBy ((&#x3D;&#x3D;) &#96;on&#96; isSpace) $ xs<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><ul><li><p><code>generalCategory</code>è·å–å­—ç¬¦å±äºå“ªä¸ªåˆ†ç±», å‡½æ•°ç±»å‹ä¸º<code>generalCategory :: Char -&gt; GeneralCategory</code>, è¿™é‡Œçš„<code>GeneralCategory</code>ä¸<code>Ordering</code>ç±»ä¼¼, ä¸ºæšä¸¾ç±»å‹</p><pre class="line-numbers language-haskell" data-language="haskell"><code class="language-haskell">ghci&gt; generalCategory &#39; &#39;  
Space  
ghci&gt; generalCategory &#39;A&#39;  
UppercaseLetter  
ghci&gt; generalCategory &#39;a&#39;  
LowercaseLetter  
ghci&gt; generalCategory &#39;.&#39;  
OtherPunctuation  
ghci&gt; generalCategory &#39;9&#39;  
DecimalNumber  
ghci&gt; map generalCategory &quot; \t\nA9?|&quot;  
[Space,Control,Control,UppercaseLetter,DecimalNumber,OtherPunctuation,MathSymbol]<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li></ul></li><li><p>è½¬æ¢å‡½æ•°</p><ul><li><code>toUpper</code>: å°†ä¸€ä¸ªå­—ç¬¦è½¬ä¸ºå¤§å†™å­—æ¯</li><li><code>toLower</code>: å°†ä¸€ä¸ªå­—ç¬¦è½¬ä¸ºå°å†™å­—æ¯</li><li><code>toTitle</code>: å°†ä¸€ä¸ªå­—ç¬¦è½¬ä¸º<code>title-case</code>ï¼Œå¯¹å¤§å¤šæ•°å­—å…ƒè€Œè¨€ï¼Œ<code>title-case</code> å°±æ˜¯å¤§å†™.</li><li><code>digitToInt</code>: å°†ä¸€ä¸ª<strong>å­—ç¬¦(ä¸æ”¯æŒå­—ç¬¦ä¸²)</strong>è½¬ä¸º<code>Int</code>å€¼ï¼Œè€Œè¿™ä¸€å­—ç¬¦å¿…é¡»å¾—åœ¨<code>'1'..'9','a'..'f'</code>æˆ–<code>'A'..'F'</code> çš„èŒƒå›´ä¹‹å†…(ç›¸å½“äºè½¬æ¢ä¸º16è¿›åˆ¶, ä½†å› ä¸ºæ˜¯ç»™å­—ç¬¦è½¬æ¢, æ‰€ä»¥æ²¡ä»€ä¹ˆé—®é¢˜)</li><li><code>intToDigit</code>æ˜¯<code>digitToInt</code>çš„åå‡½æ•°, å–ä¸€ä¸ª <code>0</code> åˆ° <code>15</code> çš„ <code>Int</code> å€¼ä½œå‚æ•°ï¼Œå¹¶è¿”å›ä¸€ä¸ªå°å†™çš„å­—ç¬¦.</li><li><code>ord</code>ä¸<code>char</code> å‡½æ•°å¯ä»¥å°†å­—ç¬¦ä¸å…¶å¯¹åº”çš„æ•°å­—ç›¸äº’è½¬æ¢.</li></ul></li></ul><h4 id="data.mapæ¨¡å—"><code>Data.Map</code>æ¨¡å—</h4><p>é€šè¿‡æ ‘å®ç°çš„Map. ç”±äºMapä¸­å‡½æ•°ä¸å…¶ä»–å‡½æ•°å†²çªè¾ƒå¤š, æœ€å¥½é‡‡ç”¨<code>qualified import</code></p><ul><li><p><code>fromList</code>: <code>List</code>è½¬<code>Map</code>, Listä¸ºK-VäºŒå…ƒç»„, Keyç›¸åŒä¼šè¦†ç›–</p><pre class="line-numbers language-haskell" data-language="haskell"><code class="language-haskell">Map.fromList :: (Ord k) &#x3D;&gt; [(k,v)] -&gt; Map.Map k v

Map.fromList [(&quot;betty&quot;,&quot;555-2938&quot;),(&quot;bonnie&quot;,&quot;452-2928&quot;),(&quot;lucille&quot;,&quot;205-2928&quot;),(&quot;lucille&quot;,&quot;205-000&quot;)] 
-- fromList [(&quot;betty&quot;,&quot;555-2938&quot;),(&quot;bonnie&quot;,&quot;452-2928&quot;),(&quot;lucille&quot;,&quot;205-000&quot;)] <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre></li><li><p><code>fromListWith</code>ç”¨æ¥è§£å†³é‡å¤Kçš„é—®é¢˜</p><pre class="line-numbers language-haskell" data-language="haskell"><code class="language-haskell">import qualified Data.Map as M

res &#x3D; M.fromListWith (\v1 v2 -&gt; v1 ++ &quot;, &quot; ++ v2) [(&quot;betty&quot;, &quot;555-2938&quot;), (&quot;bonnie&quot;, &quot;452-2928&quot;), (&quot;lucille&quot;, &quot;205-2928&quot;), (&quot;lucille&quot;, &quot;205-000&quot;)]

-- fromList [(&quot;betty&quot;,&quot;555-2938&quot;),(&quot;bonnie&quot;,&quot;452-2928&quot;),(&quot;lucille&quot;,&quot;205-000, 205-2928&quot;)]<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre></li><li><p><code>empty</code>è¿”å›ç©º<code>Map</code></p><pre class="line-numbers language-haskell" data-language="haskell"><code class="language-haskell">empty
-- fromList []<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre></li><li><p><code>insert K V</code>æ’å…¥</p><pre class="line-numbers language-haskell" data-language="haskell"><code class="language-haskell">Map.insert 3 100 Map.empty
-- fromList [(3,100)] 
Map.insert 5 600 (Map.insert 4 200 ( Map.insert 3 100  Map.empty)) 
-- fromList [(3,100),(4,200),(5,600)]<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre></li><li><p><code>insertWith</code>ç”¨äºå¤„ç†é‡å¤K</p><pre class="line-numbers language-haskell" data-language="haskell"><code class="language-haskell">import qualified Data.Map as M
res &#x3D; M.insertWith (+) 3 100 $ M.fromList [(3, 4), (5, 103), (6, 339)]

-- fromList [(3,104),(5,103),(6,339)]<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre></li><li><p><code>null</code>åˆ¤ç©ºMap</p><pre class="line-numbers language-haskell" data-language="haskell"><code class="language-haskell">Data.Map.null empty
-- True<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre></li><li><p><code>size</code>è¿”å›Mapå¤§å°</p><pre class="line-numbers language-haskell" data-language="haskell"><code class="language-haskell">Data.Map.size $ Data.Map.fromList [(2,4),(3,3),(4,2),(5,4),(6,4)] 
-- 5<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre></li><li><p><code>singleton K V</code>è¿”å›ä¸€ä¸ªK-Vçš„Map</p><pre class="line-numbers language-haskell" data-language="haskell"><code class="language-haskell">Map.singleton 3 9 
-- fromList [(3,9)] <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre></li><li><p><code>lookup K</code>è¿”å›<code>Maybe V</code>/<code>Nothing</code></p><pre class="line-numbers language-haskell" data-language="haskell"><code class="language-haskell">import qualified Data.Map as M
t &#x3D; M.fromList [(&quot;betty&quot;, &quot;555-2938&quot;), (&quot;bonnie&quot;, &quot;452-2928&quot;), (&quot;lucille&quot;, &quot;205-2928&quot;), (&quot;lucille&quot;, &quot;205-000&quot;)]
res &#x3D; M.lookup &quot;bonnie&quot; t
-- Just &quot;452-2928&quot;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre></li><li><p><code>member K map</code>åˆ¤æ–­Ke yæ˜¯å¦å­˜åœ¨</p><pre class="line-numbers language-haskell" data-language="haskell"><code class="language-haskell">import qualified Data.Map as M

t &#x3D; M.fromList [(&quot;betty&quot;, &quot;555-2938&quot;), (&quot;bonnie&quot;, &quot;452-2928&quot;), (&quot;lucille&quot;, &quot;205-2928&quot;), (&quot;lucille&quot;, &quot;205-000&quot;)]

res &#x3D; M.member &quot;bonnie&quot; t<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre></li><li><p><code>map</code>, <code>filter</code>åŒ<code>List</code></p></li><li><p><code>toList</code> æ˜¯ <code>fromList</code> çš„åå‡½æ•°ã€‚</p><pre class="line-numbers language-haskell" data-language="haskell"><code class="language-haskell">Map.toList . Map.insert 9 2 $ Map.singleton 4 3 
-- [(4,3),(9,2)]<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre></li><li><p><code>keys</code>/<code>elems</code>è¿”å›<code>K/V</code>ç»„æˆçš„<code>List</code></p><pre class="line-numbers language-haskell" data-language="haskell"><code class="language-haskell">import qualified Data.Map as M

t &#x3D; M.fromList [(&quot;betty&quot;, &quot;555-2938&quot;), (&quot;bonnie&quot;, &quot;452-2928&quot;), (&quot;lucille&quot;, &quot;205-2928&quot;), (&quot;lucille&quot;, &quot;205-000&quot;)]

res &#x3D; M.elems t
-- [&quot;555-2938&quot;,&quot;452-2928&quot;,&quot;205-000&quot;]
res&#39; &#x3D; M.keys t
-- [&quot;betty&quot;,&quot;bonnie&quot;,&quot;lucille&quot;]<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li></ul><h4 id="data.set-æ¨¡å—"><code>Data.Set</code> æ¨¡å—</h4><p>ä½¿ç”¨æ ‘å®ç°çš„é›†åˆ, å»ºè®®ä½¿ç”¨<code>qualified import</code>å¼•å…¥</p><ul><li><p><code>fromList</code>, <code>List</code>è½¬<code>Set</code></p><pre class="line-numbers language-haskell" data-language="haskell"><code class="language-haskell">import qualified Data.Set as S

a &#x3D; S.fromList [1,2,3,4,3,2,1]
-- fromList [1,2,3,4]<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre></li><li><p><code>intersection</code>äº¤é›†, <code>difference</code>å·®é›†</p><pre class="line-numbers language-haskell" data-language="haskell"><code class="language-haskell">import qualified Data.Set as S

a &#x3D; S.fromList [1, 2, 3, 4, 3, 2, 1]
b &#x3D; S.fromList [1, 2, 2, 1]

S.intersection a b
-- fromList [1,2]

S.difference a b
-- fromList [3,4]

S.union a b
-- fromList [1,2,3,4]<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li><li><p><code>null</code>, <code>size</code>, <code>member</code>, <code>empty</code>, <code>singleton</code>, <code>insert</code>, <code>delete</code>ä¸Listç±»ä¼¼</p></li><li><p><code>isSubsetOf</code>, <code>isProperSubsetOf</code>åˆ¤æ–­æ˜¯ä¸æ˜¯å­é›†ä¸çœŸå­é›†</p><pre class="line-numbers language-haskell" data-language="haskell"><code class="language-haskell">import qualified Data.Set as S

a &#x3D; S.fromList [1, 2, 3, 4, 3, 2, 1]
b &#x3D; S.fromList [1, 2, 2, 1]
c &#x3D; S.fromList [1, 2]

b &#96;S.isSubsetOf&#96; a
-- True

c &#96;S.isProperSubsetOf&#96; b
-- False<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li><li><p>æ”¯æŒ<code>Map</code>, <code>Filter</code></p><pre class="line-numbers language-haskell" data-language="haskell"><code class="language-haskell">import qualified Data.Set as S

S.filter odd $ S.fromList [3, 4, 5, 6, 7, 2, 3, 4]
-- fromList [3,5,7]
S.map (+ 1) $ S.fromList [3, 4, 5, 6, 7, 2, 3, 4]
-- fromList [3,4,5,6,7,8]<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li><li><p>é€šå¸¸ä½¿ç”¨<code>Set</code>å®Œæˆ<code>List</code>çš„å»é‡æ“ä½œ, å…¶é€Ÿåº¦ä¼˜äº<code>List.nub</code></p><pre class="line-numbers language-haskell" data-language="haskell"><code class="language-haskell">setNub xs &#x3D; Set.toList $ Set.fromList xs  <span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>å”¯ä¸€çš„ç¼ºç‚¹æ˜¯ä¼šä¸¢å¤±é¡ºåº</p></li></ul><h4 id="å£°æ˜æ¨¡å—">å£°æ˜æ¨¡å—</h4><ul><li><p>å£°æ˜å•æ¨¡å—</p><ul><li><p>åˆ›å»ºæ–‡ä»¶, æ–‡ä»¶åä¸º<code>æ¨¡å—å.hs</code>, æ¨¡å—åéœ€å¼€å¤´å¤§å†™</p></li><li><p>æ–‡ä»¶é¦–éƒ¨å†™å‡ºæ¨¡å—åä¸éœ€è¦å¯¼å‡ºçš„æ–¹æ³•, ä¾‹å¦‚<code>Demo.hs</code></p><pre class="line-numbers language-haskell" data-language="haskell"><code class="language-haskell">module Demo
  ( demo1,
    demo2,
  )
where

demo1 :: Integer -&gt; Integer
demo1 &#x3D; demo3 . (1 +)

demo2 :: Integer -&gt; Integer
demo2 &#x3D; demo3 . (1 -)

-- demo3ä»…ä½œä¸ºå†…éƒ¨è°ƒç”¨ä½¿ç”¨, æ— éœ€å¯¼å‡º, å¯ä»¥ä¸åœ¨moduleä¸­å†™
demo3 :: Integer -&gt; Integer
demo3 &#x3D; (* 2)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li><li><p>å°†æ¨¡å—æ”¾åœ¨åŒçº§ç›®å½•, ä¾‹å¦‚</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">.
â”œâ”€â”€ Demo.hs
â””â”€â”€ test.hs<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>å°±å¯ä»¥åœ¨<code>test.hs</code>ä¸­è°ƒç”¨</p><pre class="line-numbers language-haskell" data-language="haskell"><code class="language-haskell">import Demo

res :: Integer
res &#x3D; demo1 1
-- 4<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre></li></ul></li><li><p>ä¹Ÿå¯ä»¥åˆ†å±‚è®¾è®¡æ¨¡å—, åªéœ€è¦å°†å…¶æ”¾å…¥å­æ–‡ä»¶ä¸­å¹¶ä½¿ç”¨<code>.</code>å¼•å…¥</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">.
â”œâ”€â”€ Demos
â”‚   â”œâ”€â”€ DemoA.hs
â”‚   â””â”€â”€ DemoB.hs
â””â”€â”€ test.hs<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>å…¶ä¸­</p><ul><li><p><code>DemoA.hs</code></p><pre class="line-numbers language-haskell" data-language="haskell"><code class="language-haskell">module Demos.DemoA
  ( demo1,
    demo2,
  )
where

demo1 :: Integer -&gt; Integer
demo1 &#x3D; demo3 . (1 +)

demo2 :: Integer -&gt; Integer
demo2 &#x3D; demo3 . (1 -)

demo3 :: Integer -&gt; Integer
demo3 &#x3D; (* 2)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li><li><p><code>DemoB.hs</code></p><pre class="line-numbers language-haskell" data-language="haskell"><code class="language-haskell">module Demos.DemoB
  ( demo1,
    demo2,
  )
where

demo1 :: Integer -&gt; Integer
demo1 &#x3D; demo3 . (2 +)

demo2 :: Integer -&gt; Integer
demo2 &#x3D; demo3 . (2 -)

demo3 :: Integer -&gt; Integer
demo3 &#x3D; (* 4)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li><li><p><code>test.hs</code></p><pre class="line-numbers language-haskell" data-language="haskell"><code class="language-haskell">import qualified Demos.DemoA as A
import qualified Demos.DemoB as B

a &#x3D; A.demo1 1
-- 4
b &#x3D; B.demo1 1
-- 12<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li></ul></li></ul><h3 id="å£°æ˜ç±»å‹ä¸ç±»å‹ç±»">å£°æ˜ç±»å‹ä¸ç±»å‹ç±»</h3><h4 id="ä»£æ•°æ•°æ®ç±»å‹">ä»£æ•°æ•°æ®ç±»å‹</h4><p>ä»£æ•°æ•°æ®ç±»å‹: ç”±å€¼çš„ä¸€äº›é›†åˆ, ä»¥åŠè¿™äº›é›†åˆä¹‹é—´çš„ä¸€äº›å‡½æ•°æ„æˆçš„ç±»å‹. è¿™äº›å‡½æ•°éƒ½æ˜¯ä¸€é˜¶å‡½æ•°, ä¸èƒ½ä»¥å…¶ä»–å‡½æ•°ä½œä¸ºå‚æ•°.</p><ul><li><p>ä¾‹å¦‚<code>Bool</code>ç±»å‹çš„å®šä¹‰</p><p><pre class="line-numbers language-haskell" data-language="haskell"><code class="language-haskell">data Bool &#x3D; False | True<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></p><ul><li><p><code>data</code>å…³é”®å­—ç”¨äºå£°æ˜æ–°ç±»åˆ«</p></li><li><p><code>=</code>å³è¾¹æ˜¯<strong>å€¼æ„é€ å­</strong>, åŒ…å«äº†è¿™ä¸ªç±»å‹çš„æ‰€æœ‰å¯èƒ½å€¼(å³<code>True</code>, <code>False</code>, ç”¨<code>|</code>åˆ†å¼€)</p></li><li><p>ä»€ä¹ˆæ˜¯å€¼æ„é€ å­å‘¢? å¬èµ·æ¥å¾ˆåƒå‘½ä»¤å¼ç¼–ç¨‹ä¸­çš„æ„é€ å‡½æ•°ğŸ¤”. ä¸å¦¨æ‰§è¡Œ<code>:t False</code>. å¾—åˆ°<code>False :: Bool</code>, æˆ‘ä»¬å¯ä»¥è¿™æ ·æƒ³: <code>False</code>æ˜¯ä¸€ä¸ªå‡½æ•°, è¿™ä¸ªå‡½æ•°æ˜¯ä¸€ä¸ªå¸¸å‡½æ•°, ä¸æ¥å—ä»»ä½•å‚æ•°, è¿”å›ä¸€ä¸ª<code>Bool</code>ç±»å‹çš„æ•°æ®</p><p><strong>å€¼æ„é€ å­çš„æœ¬è´¨æ˜¯ä¸ªå‡½æ•°ï¼Œå¯ä»¥è¿”å›ä¸€ä¸ªå‹åˆ«çš„å€¼</strong></p></li></ul></li><li><p>ä¾‹å¦‚å®šä¹‰ä¸€ä¸ªæ”¯æŒåœ†å½¢æˆ–æ­£æ–¹å½¢çš„<code>Shape</code>ç±»å‹.</p><ul><li><p>é¦–å…ˆæˆ‘ä»¬çŸ¥é“è¿™ä¸ªç±»å‹çš„å–å€¼åº”è¯¥æ˜¯åœ†/æ­£æ–¹å½¢:</p><p><pre class="line-numbers language-haskell" data-language="haskell"><code class="language-haskell">data Shape &#x3D; Circle | Rectangle<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></p></li><li><p>æœ‰ç‚¹åç›´è§‰, è¿™é‡Œçš„<code>Circle</code>ä¸<code>Rectangle</code>æ˜¯ä»€ä¹ˆ?</p><p>æ˜¯å€¼æ„é€ å­, ä¹Ÿå°±æ˜¯è¯´ä»–ä»¬å°±æ˜¯ä¸€ä¸ªä¸€ä¸ªç‹¬ç«‹çš„<strong>å€¼</strong>, è¿™é‡Œçš„<code>Circle</code>å’Œä¹‹å‰çš„<code>False</code>æ˜¯ä¸€ä¸ªä¸œè¥¿</p></li><li><p>å¦‚ä½•è¡¨ç¤ºä¸€ä¸ª<code>Circle</code>å‘¢, å¯ä»¥ä½¿ç”¨ä¸‰ä¸ªå‚æ•°(é¡¹)è¡¨ç¤º<code>x, y, r</code>. å¯ä»¥å°†å‚æ•°ç±»å‹é™„åœ¨å€¼æ„é€ å­åè¡¨ç¤ºè¿™ä¸ªæ„é€ å­çš„ç±»å‹. åŒç†å¯ä»¥ç”¨<code>x1, y1, x2, y2</code>è¡¨ç¤ºé•¿æ–¹å½¢</p><p><pre class="line-numbers language-haskell" data-language="haskell"><code class="language-haskell">data Shape &#x3D; Circle Float Float Float | Rectangle Float Float Float Float<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></p></li><li><p>å°è¯•æ£€æŸ¥<code>Circle</code>ç±»å‹:</p><p><pre class="line-numbers language-haskell" data-language="haskell"><code class="language-haskell">Circle :: Float -&gt; Float -&gt; Float -&gt; Shape<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></p><p>æ˜¯ä¸€ä¸ªå‡½æ•°, æ¥å—ä¸‰ä¸ª<code>Float</code>, è¿”å›ä¸€ä¸ª<code>Shape</code>. çœ‹èµ·æ¥ä¸å‘½ä»¤å¼ç¼–ç¨‹ç›¸å·®ç”šè¿œğŸ¤”, æˆ‘ä»¬å¹¶æ²¡æœ‰<strong>å®ç°å€¼æ„é€ å­—</strong>, æ²¡æœ‰æè¿°æˆ‘ä»¬æ˜¯å¦‚ä½•å°†ä¸‰ä¸ª<code>Float</code>ç±»å‹çš„å˜é‡è¡¨ç¤ºä¸ºä¸€ä¸ª<code>Shape</code>ç±»å‹çš„åœ†çš„. åˆ«å¿˜äº†Haskellçš„å‡½æ•°æ˜¯çº¯å‡½æ•°ğŸ˜†. ä½¿ç”¨ç›¸åŒçš„ä¸‰ä¸ªå‚æ•°å°±å¯ä»¥è·å–åŒä¸€ä¸ªåœ†. å¯ä»¥è¿™æ ·ç†è§£: <code>Circle 1 1 1</code>å°±ä»£è¡¨ä¸€ä¸ªåœ†, ä»–çš„ç±»å‹å°±æ˜¯<code>Shape</code>,</p></li></ul></li></ul><p><strong>ä¸è¦å°†å€¼æ„é€ å­ä¸ç±»æ··æ·†, ä¸€ä¸ªå¾ˆå¥½çš„æ–¹æ³•æ˜¯è®°ä½ä¾‹å­: <code>Bool</code>æ˜¯ç±»å‹, <code>True</code>æ˜¯å€¼æ„é€ å­</strong>, åœ¨å‡½æ•°å£°æ˜ç±»å‹çš„åº”è¯¥ä½¿ç”¨ç±»å‹è€Œä¸æ˜¯å€¼æ„é€ å­. ä¾‹å¦‚: å®ç°è·å–åœ†é¢ç§¯çš„å‡½æ•°</p><pre class="line-numbers language-haskell" data-language="haskell"><code class="language-haskell">data Shape &#x3D; Circle Float Float Float | Rectangle Float Float Float Float

getCiecleSize :: Shape -&gt; Float       -- ğŸ‘
getCiecleSize :: Circle -&gt; Float      -- ğŸ‘<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>åƒä¸‡ä¸è¦æŠŠå€¼æ„é€ å­ç”¨ä½œç±»å‹å£°æ˜, è¿™å°±å’Œä½ å°†<code>True</code>ç”¨ä½œç±»å‹å£°æ˜ä¸€æ ·æ„šè ¢</p><pre class="line-numbers language-haskell" data-language="haskell"><code class="language-haskell">tellMessage :: Bool -&gt; String      -- ğŸ‘
tellMessage :: True -&gt; String      -- ğŸ‘
tellMessage True &#x3D; &quot;Wow, it is true&quot;
tellMessage False &#x3D; &quot;Opps, it is false&quot;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>é—®é¢˜æ¥äº†, æˆ‘ä»¬åªæƒ³è®¡ç®—<code>Circle</code>çš„é¢ç§¯, ä½†æ˜¯æˆ‘ä»¬åœ¨å‡½æ•°å£°æ˜çš„æ—¶å€™åªè¦æ±‚å‚æ•°æ˜¯<code>Shape</code>, æ²¡æ³•è¿‡æ»¤<code>Rectangle</code>å•ŠğŸ¤¯! å¥½å¥½æƒ³æƒ³, å¦‚æœæˆ‘ä»¬åªæ˜¯æƒ³å®ç°è¾“å…¥<code>True</code>è¿”å›å­—ç¬¦ä¸², è¾“å…¥<code>Fasle</code>ä¸ç®¡, åº”è¯¥å¦‚ä½•å®ç°å‘¢? æ¨¡å¼åŒ¹é…</p><pre class="line-numbers language-haskell" data-language="haskell"><code class="language-haskell">tellMessage :: Bool -&gt; String
tellMessage True &#x3D; &quot;Wow, it is true&quot;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>ä¸€æ ·æ ·çš„, ä¸è¿‡<code>Circle</code>æ„é€ å­æœ‰å‚æ•°, æˆ‘ä»¬è¦ä¸€å¹¶åŒ¹é…</p><pre class="line-numbers language-haskell" data-language="haskell"><code class="language-haskell">getCiecleSize :: Shape -&gt; Float
getCiecleSize (Circle _ _ r) &#x3D; pi * r ^ 2<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>å†å®ç°ä¸€ä¸ªè·å–<code>Shape</code>é¢ç§¯çš„æ–¹æ³•</p><pre class="line-numbers language-haskell" data-language="haskell"><code class="language-haskell">surface :: Shape -&gt; Float
surface (Circle _ _ r) &#x3D; pi * r ^ 2
surface (Rectangle x1 y1 x2 y2) &#x3D; (abs $ x2 - x1) * (abs $ y2 - y1)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>ğŸ˜†æœ€åä¼˜åŒ–ä¸€ä¸‹, å®šä¹‰ä¸€ä¸ª<code>Point</code>ç±»</p><pre class="line-numbers language-haskell" data-language="haskell"><code class="language-haskell">data Point &#x3D; Point Float Float
data Shape &#x3D; Circle Point Float | Rectangle Point Point

surface :: Shape -&gt; Float
surface (Circle _ r) &#x3D; pi * r ^ 2
surface (Rectangle (Point x1 y1) (Point x2 y2)) &#x3D; (abs $ x2 - x1) * (abs $ y2 - y1)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>å€¼å¾—æ³¨æ„çš„æ˜¯ç±»å‹<code>Point</code>ä¸å€¼æ„é€ å­<code>Point</code>é‡åäº†. æ²¡å•¥ç¨€å¥‡çš„,</p><ul><li>å‰é¢çš„<code>Point</code>æ˜¯ç±»å‹, ç”¨äºç±»å‹å£°æ˜, ç±»ä¼¼äº<code>Bool</code></li><li>åé¢çš„<code>Point</code>æ˜¯å€¼æ„é€ å­, ç”¨äºè¡¨ç¤ºå€¼, ç±»ä¼¼äº<code>True</code></li></ul><p>ğŸ§°æˆ‘ä»¬è¿˜å¯ä»¥å°†<code>Shape</code>çš„å®šä¹‰ä¸æ–¹æ³•æ‰“åŒ…æˆæ¨¡å—</p><pre class="line-numbers language-haskell" data-language="haskell"><code class="language-haskell">module Shapes
( Point(..)
, Shape(..)
, surface
) where<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>ç±»å‹åçš„<code>(..)</code>è¡¨ç¤ºå¯¼å‡ºç±»å‹çš„å…¨éƒ¨å€¼æ„é€ å­. è¿™æ ·å¯¼å…¥è€…å°±å¯ä»¥ç›´æ¥å®šä¹‰ç±»å‹äº†. å¦‚æœæˆ‘ä»¬ä¸å¸Œæœ›å¯¼å…¥è€…ç›´æ¥æ„é€ å®ä¾‹, æˆ‘ä»¬å¯ä»¥å£°æ˜åƒ<code>Map.fromList</code>çš„å‡½æ•°æ„é€ ç±»å‹</p><h4 id="record-syntax">Record Syntax</h4><p>ğŸ·ï¸Haskellæä¾›äº†<code>record syntax</code>, å¯ä»¥åœ¨å®šä¹‰ç±»å‹çš„åŒæ—¶, ä¸ºæ¯ä¸ªå­—æ®µæŒ‡å®šè¯»å–å™¨. å°±åƒå‘½ä»¤å¼ç¼–ç¨‹ä¸€æ ·, æˆ‘ä»¬å¯ä»¥ä¸ºæ¯é¡¹èµ‹äºˆæ ‡è¯†, ä¾‹å¦‚å®šä¹‰<code>Person</code>ç±»å‹æ—¶, æˆ‘ä»¬å¯ä»¥å†™ä¸‹</p><pre class="line-numbers language-haskell" data-language="haskell"><code class="language-haskell">data Person &#x3D; Person &#123; firstName :: String
                     , lastName :: String
                     , age :: Int
                     , height :: Float
                     , phoneNumber :: String
                     , flavor :: String
                     &#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>è¿™æ ·å°±ä¸º<code>Person</code>å€¼æ„é€ å­å‚æ•°èµ‹äºˆäº†æ ‡ç­¾</p><p>ä¸ç›´æ¥ä½¿ç”¨<code>Person :: Person String String...</code>å£°æ˜ä¸åŒçš„æ˜¯<strong><code>Haskell</code>ä¸ºæ¯ä¸€ä¸ªå‚æ•°ç»‘å®šçš„æ ‡è¯†ç¬¦ç»‘å®šäº†ä¸€ä¸ªå‡½æ•°</strong>, ä¾‹å¦‚</p><pre class="line-numbers language-haskell" data-language="haskell"><code class="language-haskell">ghci&gt; :t flavor
flavor :: Person -&gt; String<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>è¿™ä¸ªå‡½æ•°å–<code>Person</code>ç±»å‹å€¼, è¿”å›è¿™ä¸ªå€¼ä¸­è¯¥å…ƒç´ æ‰€åœ¨ä½å€¼</p><pre class="line-numbers language-haskell" data-language="haskell"><code class="language-haskell">data Person &#x3D; Person
  &#123; firstName :: String,
    lastName :: String,
    age :: Int,
    height :: Float,
    phoneNumber :: String,
    flavor :: String
  &#125;

per &#x3D; Person &quot;Kairui&quot; &quot;Liu&quot; 12 123 &quot;13456789022&quot; &quot;i do not know&quot;

flavor per   -- &quot;i do not know&quot;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>ç­‰ä»·äº</p><pre class="line-numbers language-haskell" data-language="haskell"><code class="language-haskell">flavor&#39; :: Person -&gt; String
flavor&#39; (Person _ _ _ _ _ f) &#x3D; f<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><h4 id="ç±»å‹å‚æ•°">ç±»å‹å‚æ•°</h4><p>ç±»ä¼¼äºå‘½ä»¤å¼ç¼–ç¨‹ä¸­çš„"æ¨¡æ¿", å¯ä»¥åœ¨å£°æ˜ç±»å‹çš„æ—¶å€™åŠ å…¥ç±»å‹å˜é‡å‚æ•°, ä¾‹å¦‚<code>Maybe</code>ç±»å‹</p><pre class="line-numbers language-haskell" data-language="haskell"><code class="language-haskell">data Maybe a &#x3D; Nothing | Just a<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>æ¥å—ä¸€ä¸ªç±»å‹å‚æ•°å¹¶åœ¨<code>Just</code>ä¸­ä½¿ç”¨, åœ¨è°ƒç”¨<code>Just X</code>çš„æ—¶å€™, Haskellä¼šè‡ªåŠ¨åˆ¤æ–­ç±»å‹å¹¶è¿”å›</p><p>ç”šè‡³å¯ä»¥åœ¨ç±»å‹å®šä¹‰æ—¶é™å®šç±»å‹å˜é‡ç±»å‹(<strong>ä½†æ˜¯å¼ºçƒˆä¸å»ºè®®</strong>), å› ä¸ºåœ¨å‡½æ•°ç±»å‹å®šä¹‰æ—¶æˆ‘ä»¬è¿˜æ˜¯éœ€è¦å£°æ˜ç±»å‹çš„ç±»å‹ç±»</p><pre class="line-numbers language-haskell" data-language="haskell"><code class="language-haskell">data (Ord k) &#x3D;&gt; Map k v &#x3D; ...<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>å®ç°ä¸€ä¸ªçŸ¢é‡åŠ æ³•</p><pre class="line-numbers language-haskell" data-language="haskell"><code class="language-haskell">data Vector a &#x3D; Vector a a a deriving (Show)

plusV :: (Num a) &#x3D;&gt; Vector a -&gt; Vector a -&gt; Vector a
plusV (Vector x1 y1 z1) (Vector x2 y2 z2) &#x3D; Vector (x1 + x2) (y1 + y2) (z1 + z2)

plusV (Vector 1 2 3) (Vector 1 2 3)
-- Vector 2 4 6<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="é€’å½’å®šä¹‰ç±»å‹">é€’å½’å®šä¹‰ç±»å‹</h4><p>å®šä¹‰å€¼æ„é€ å­çš„æ—¶å€™ä½¿ç”¨æœ¬èº«çš„ç±»å‹å°±æ„æˆäº†æ•°æ®ç±»å‹é€’å½’å®šä¹‰.</p><ul><li><p>å®šä¹‰ä¸€ä¸ª<code>List</code>. ä¸€ä¸ª<code>List</code>è¦ä¹ˆæ˜¯ç©ºçš„<code>[]</code>, è¦ä¹ˆæ˜¯<code>elem:List</code></p><p><pre class="line-numbers language-haskell" data-language="haskell"><code class="language-haskell">data List a &#x3D; Empty | Cons a (List a) <span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></p><p>å…¶ä¸­<code>Cons</code>å°±æ˜¯<code>:</code></p><p><pre class="line-numbers language-haskell" data-language="haskell"><code class="language-haskell">ghci&gt; :t (:)
(:) :: a -&gt; [a] -&gt; [a]<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre></p><p>ä¹Ÿå°±æ˜¯: <code>List</code>æœ‰ä¸¤ä¸ªå€¼, è¦ä¹ˆæ˜¯<code>Empty</code>å€¼æ„é€ å­è¦ä¹ˆæ˜¯<code>Cons</code>å€¼æ„é€ å­. å…¶ä¸­<code>Cons</code>å€¼æ„é€ å­æœ‰ä¸¤ä¸ªå‚æ•°, <code>a</code>ä¸<code>List a</code></p><p>åŒæ ·ä¹Ÿå¯ä»¥ä½¿ç”¨<code>Record Syntax</code>å®šä¹‰<code>List</code></p><p><pre class="line-numbers language-haskell" data-language="haskell"><code class="language-haskell">data List a &#x3D; Empty | Cons &#123; listHead :: a, listTail :: List a&#125; <span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></p><p>ä¾‹å¦‚<code>[1,2,3]</code>ç›¸å½“äº<code>1:2:3:[]</code></p><p><pre class="line-numbers language-haskell" data-language="haskell"><code class="language-haskell">Cons 1 $ Cons 2 $ Cons 3 Empty<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></p><p>å®šä¹‰<code>++</code></p><p><pre class="line-numbers language-haskell" data-language="haskell"><code class="language-haskell">infixr 5  ++
(++) :: [a] -&gt; [a] -&gt; [a]
[]     ++ ys &#x3D; ys
(x:xs) ++ ys &#x3D; x : (xs ++ ys)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre></p></li><li><p>å®šä¹‰æœç´¢äºŒå‰æ ‘(å…ˆä¸ç®¡<code>deriving...</code>)</p><p><pre class="line-numbers language-haskell" data-language="haskell"><code class="language-haskell">data BST a &#x3D; EmptyTree | Node a (BST a) (BST a) deriving (Show, Eq)

-- è·å–å•å…ƒç´ 
getOne :: a -&gt; BST a
getOne a &#x3D; Node a EmptyTree EmptyTree

insertNode :: (Ord a, Eq a) &#x3D;&gt; a -&gt; BST a -&gt; BST a
insertNode x EmptyTree &#x3D; getOne x
insertNode x (Node a lt rt)
  | x &lt; a &#x3D; Node a (insertNode x lt) rt
  | x &gt; a &#x3D; Node a lt (insertNode x rt)
  | x &#x3D;&#x3D; a &#x3D; Node a lt rt

elemNode :: (Ord a, Eq a) &#x3D;&gt; a -&gt; BST a -&gt; Bool
elemNode x EmptyTree &#x3D; False
elemNode x (Node a lt rt)
  | x &#x3D;&#x3D; a &#x3D; True
  | x &lt; a &#x3D; elemNode x lt
  | x &gt; a &#x3D; elemNode x rt

t1 :: BST Integer
t1 &#x3D; insertNode 10 . insertNode 5 $ getOne 7
-- Node 7 (Node 5 EmptyTree EmptyTree) (Node 10 EmptyTree EmptyTree)

t2 :: Bool
t2 &#x3D; elemNode 3 t1
-- False

t3 :: Bool
t3 &#x3D; elemNode 10 t1
-- True<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></p></li></ul><h4 id="ç±»å‹åˆ«å">ç±»å‹åˆ«å</h4><p>ğŸ‘»ä¸å‘½ä»¤å¼ç¼–ç¨‹ä¸­ç±»å‹åˆ«åç±»ä¼¼.</p><ul><li><p>çœ‹çœ‹<code>String</code>è¯­æ³•ç³–æ˜¯å¦‚ä½•å®šä¹‰çš„</p><p><pre class="line-numbers language-haskell" data-language="haskell"><code class="language-haskell">type String &#x3D; [Char]<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></p><p>å°±æ˜¯å°†ç±»å‹æ˜ å°„åˆ°å¦ä¸€ä¸ªç±»å‹ç»„</p></li><li><p>å®šä¹‰ä¸€ä¸ªç”µè¯ç°¿</p><p><pre class="line-numbers language-haskell" data-language="haskell"><code class="language-haskell">-- æ­£å¸¸æ¬¾
phoneBook :: [(String,String)]
phoneBook &#x3D;
    [(&quot;betty&quot;,&quot;555-2938&quot;)
    ,(&quot;penny&quot;,&quot;853-2492&quot;)
    ]
    
-- åˆ«åæ¬¾
type PhoneBook &#x3D; [(String,String)]

-- Record Syntax åˆ«åæ¬¾
type PhoneNumber &#x3D; String
type Name &#x3D; String
type PhoneBook &#x3D; [(Name,PhoneNumber)]<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></p></li></ul><h4 id="æ´¾ç”Ÿ">æ´¾ç”Ÿ</h4><p>ç±»ä¼¼å‘½ä»¤å¼ç¼–ç¨‹çš„æ¥å£ä¸æ´¾ç”Ÿ, åœ¨Haskellä¸­å½“ç±»å‹å¯ä»¥é€šè¿‡æ´¾ç”Ÿçš„æ–¹å¼å½’å±äºä¸€ä¸ªç±»å‹ç±»</p><p><strong>æˆ‘ä»¬åªè®¨è®ºå¦‚ä½•å£°æ˜ç±»å‹ä¸ºé¢„å®šäº<code>Type Classes</code></strong>, ä¸è¿‡ç­‰è‡ªå·±ä¼šå®šä¹‰<code>Type Class</code>æ—¶è‡ªç„¶ä¹Ÿå°±ä¼šæ´¾ç”Ÿäº†</p><p>ç±»å‹æ˜¯å¯ä»¥å±äºä¸€ä¸ªç±»å‹ç±»çš„(ä¾‹å¦‚<code>Bool</code>æ˜¯ä¸€ä¸ª<code>Eq</code>ç±»å‹ç±»çš„), æˆ‘ä»¬ä¹Ÿå¯ä»¥å£°æ˜è‡ªå·±çš„ç±»å‹å±äºæŸä¸ªç±»å‹ç±». ä¾‹å¦‚</p><ul><li><p>å®šä¹‰<code>Shape</code>æ´¾ç”Ÿè‡ª<code>Show</code>(ä½¿å…¶å¯ä»¥è¢«æ‰“å°)</p><pre class="line-numbers language-haskell" data-language="haskell"><code class="language-haskell">data Shape &#x3D; Circle Float Float Float | Rectangle Float Float Float Float deriving (Show)<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>åªéœ€ä½¿ç”¨<code>deriving (Show)</code>å³å¯å£°æ˜ç±»å‹æ´¾ç”Ÿè‡ª<code>Show</code>. ä¹‹åå°±å¯ä»¥åœ¨<code>ghci</code>ä¸­æ‰“å°<code>Shape</code>äº†</p><p>ğŸåŒæ—¶, è‹¥ç±»ä¼¼æ˜¯é€šè¿‡<code>Record Syntax</code>å®šä¹‰çš„ , <code>show</code>åˆ°å¤„çš„å½¢å¼ä¼šç•¥æœ‰ä¸åŒ</p><pre class="line-numbers language-haskell" data-language="haskell"><code class="language-haskell">data Shape &#x3D; Circle Float Float Float | Rectangle Float Float Float Float deriving (Show)

data Shape&#39; &#x3D; Circle&#39; &#123;x :: Float, y :: Float, r :: Float&#125; | Rectangle&#39; &#123;x1 :: Float, y1 :: Float, x2 :: Float, y2 :: Float&#125; deriving (Show)

t &#x3D; show (Circle 1 2 3)
-- &quot;Circle 1.0 2.0 3.0&quot;
t&#39; &#x3D; show (Circle&#39; 1 2 3)
-- &quot;Circle&#39; &#123;x &#x3D; 1.0, y &#x3D; 2.0, r &#x3D; 3.0&#125;&quot;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>ğŸ¤”æœ‰ç‚¹å°é—®é¢˜, ä»å¤´åˆ°å°¾æˆ‘ä»¬éƒ½æ²¡æœ‰å®ç°<code>Show</code>ç±»å‹ç±»ä¸­çš„ä¸€ä¸ªå‡½æ•°å•Š. æ€ä¹ˆå°±æ‰“å°å‡ºæ¥äº†å‘¢?</p><p>è¿™æ˜¯å› ä¸º<code>Show</code>ç±»å‹ç±»ä¸­å­˜åœ¨é»˜è®¤å®ç°, æˆ‘ä»¬ä¹Ÿå¯ä»¥æ‰‹åŠ¨é‡å†™</p><pre class="line-numbers language-haskell" data-language="haskell"><code class="language-haskell">data Shape &#x3D; Circle Float Float Float | Rectangle Float Float Float Float    -- æ³¨æ„æ²¡æœ‰&quot;deriving&quot;

-- å®ç°æ¥å£
instance Show Shape where
  show (Circle x y r) &#x3D; &quot;Look! it is a circle, with origin (&quot; ++ show x ++ &quot;, &quot; ++ show y ++ &quot;), and r &#x3D; &quot; ++ show r
  show (Rectangle x1 y1 x2 y2) &#x3D; &quot;Look! it is a rectangle, from (&quot; ++ show x1 ++ &quot;, &quot; ++ show y1 ++ &quot;), to (&quot; ++ show x2 ++ &quot;, &quot; ++ show y2 ++ &quot;)&quot;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-haskell" data-language="haskell"><code class="language-haskell">ghci&gt; show (Circle 1 2 3)
&quot;Look! it is a circle, with origin (1.0, 2.0), and r &#x3D; 3.0&quot;
ghci&gt; show (Rectangle  1 2 3 4)
&quot;Look! it is a rectangle, from (1.0, 2.0), to (3.0, 4.0)&quot;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre></li><li><p>å®šä¹‰<code>Shape</code>æ´¾ç”Ÿè‡ª<code>Eq</code></p><p>é»˜è®¤<code>Eq</code>å®ç°ä¸º: åˆ†åˆ«æ¯”è¾ƒæ¯ä¸€ä¸ªå…ƒç´ æ˜¯å¦ç›¸ç­‰</p><pre class="line-numbers language-haskell" data-language="haskell"><code class="language-haskell">data Person &#x3D; Person &#123; firstName :: String
                     , lastName :: String
                     , age :: Int
                     &#125; deriving (Eq)

mikeD &#x3D; Person &#123;firstName &#x3D; &quot;Michael&quot;, lastName &#x3D; &quot;Diamond&quot;, age &#x3D; 43&#125;
adRock &#x3D; Person &#123;firstName &#x3D; &quot;Adam&quot;, lastName &#x3D; &quot;Horovitz&quot;, age &#x3D; 41&#125;
mca &#x3D; Person &#123;firstName &#x3D; &quot;Adam&quot;, lastName &#x3D; &quot;Yauch&quot;, age &#x3D; 44&#125;
mca &#x3D;&#x3D; adRock         -- False
mikeD &#x3D;&#x3D; adRock       -- False
mikeD &#x3D;&#x3D; mikeD        -- True
mikeD &#x3D;&#x3D; Person &#123;firstName &#x3D; &quot;Michael&quot;, lastName &#x3D; &quot;Diamond&quot;, age &#x3D; 43&#125;  
-- True<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>é‡å†™æ—¶éœ€è¦å®ç°<code>==</code></p><pre class="line-numbers language-haskell" data-language="haskell"><code class="language-haskell">data Shape &#x3D; Circle Float Float Float | Rectangle Float Float Float Float

instance Eq Shape where
  (Circle x1 y1 r1) &#x3D;&#x3D; (Circle x2 y2 r2) &#x3D; x1 &#x3D;&#x3D; x2 &amp;&amp; y1 &#x3D;&#x3D; y2 &amp;&amp; r1 &#x3D;&#x3D; r2
  (Rectangle x11 y11 x21 y21) &#x3D;&#x3D; (Rectangle x12 y12 x22 y22) &#x3D; x11 &#x3D;&#x3D; x12 &amp;&amp; y11 &#x3D;&#x3D; y12 &amp;&amp; x21 &#x3D;&#x3D; x22 &amp;&amp; y21 &#x3D;&#x3D; y22
  _ &#x3D;&#x3D; _ &#x3D; False

-- åˆ«çœ‹ä¸æ‡‚, åªæ˜¯ç®€å•çš„ä¸­ç¼€è¡¨è¾¾å¼

t1 &#x3D; Circle 1 1 1 &#x3D;&#x3D; Circle 1 1 1            -- True
t2 &#x3D; Circle 1 1 2 &#x3D;&#x3D; Circle 1 1 1            -- False
t3 &#x3D; Rectangle 1 1 2 3 &#x3D;&#x3D; Rectangle 1 1 2 3  -- True
t4 &#x3D; Rectangle 1 1 2 3 &#x3D;&#x3D; Rectangle 1 1 2 4  -- False
t5 &#x3D; Circle 1 1 2 &#x3D;&#x3D; Rectangle 1 1 2 4       -- False<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li><li><p>å®šä¹‰<code>Bool</code>ç±»å‹æ´¾ç”Ÿè‡ª<code>Ord</code>. ä½¿å¾—å…¶æ”¯æŒ<code>&lt;</code>, <code>&gt;</code>, <code>==</code>, <code>succ</code>, <code>pred</code>, <code>minBound</code>, <code>maxBound</code>, <code>..</code></p><pre class="line-numbers language-haskell" data-language="haskell"><code class="language-haskell">data Bool &#x3D; False | True deriving (Ord)

succ False      -- True
pred True       -- False<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p><code>Ord</code>çš„é¡ºåºå°±æ˜¯å®šä¹‰ç±»å‹æ—¶<code>|</code>çš„é¡ºåº.</p></li></ul><h4 id="å®šä¹‰typeclasses">å®šä¹‰<code>TypeClasses</code></h4><p><code>Haskell</code>çš„<code>TypeClasses</code>ä¸å‘½ä»¤å¼ç¼–ç¨‹ä¸­çš„æ¥å£ç±»ä¼¼. æˆ‘ä»¬éœ€è¦å®šä¹‰<code>TypeClasses</code>ä¸<code>TypeClasses</code>ä¸­å‡½æ•°. ä½¿ç”¨<code>class</code>å…³é”®å­—å®šä¹‰ğŸ™ƒ(å¤šå°‘æœ‰ç‚¹å˜²è®½), å…¶éœ€è¦å®ç°çš„æ–¹æ³•åœ¨<code>where</code>ä¸­. ä¾‹å¦‚</p><ul><li><p><code>Eq</code>ç±»å‹ç±»çš„å®šä¹‰</p><pre class="line-numbers language-haskell" data-language="haskell"><code class="language-haskell">class Eq a where
    (&#x3D;&#x3D;) :: a -&gt; a -&gt; Bool
    (&#x2F;&#x3D;) :: a -&gt; a -&gt; Bool
    x &#x3D;&#x3D; y &#x3D; not (x &#x2F;&#x3D; y)
    x &#x2F;&#x3D; y &#x3D; not (x &#x3D;&#x3D; y)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>ğŸ˜²çœ‹èµ·æ¥æœ‰ç‚¹ç¦»è°±, è¿™æ³¢å¾ªç¯å®šä¹‰å±å®æ˜¯æ²¡æƒ³åˆ°...è¦æ˜¯çœŸæ˜¯è¿™ä¹ˆå®šä¹‰çš„å¯å¤ªç¦»è°±äº†. å¯æ˜¯äººå®¶çœŸçš„æ˜¯è¿™ä¹ˆå®šä¹‰çš„. æ¯•ç«Ÿ, è¿™æ˜¯é»˜è®¤å®šä¹‰, æˆ‘ä»¬åœ¨å®ç°æ¥å£çš„æ—¶å€™å¯ä»¥é‡å†™</p><p>å®ç°ä¸€ä¸ªçº¢ç»¿ç¯ç±»å‹, å¹¶æ´¾ç”Ÿè‡ª<code>Eq</code></p><pre class="line-numbers language-haskell" data-language="haskell"><code class="language-haskell">data TrafficLight &#x3D; Red | Yellow | Green

instance Eq TrafficLight where
    Red &#x3D;&#x3D; Red &#x3D; True
    Green &#x3D;&#x3D; Green &#x3D; True
    Yellow &#x3D;&#x3D; Yellow &#x3D; True
    _ &#x3D;&#x3D; _ &#x3D; False<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>æˆ‘ä»¬å®šä¹‰äº†çº¢ç»¿ç¯çš„ä¸‰ä¸ªå€¼, å¹¶ä¸”é‡å†™äº†<code>==</code>(åªæœ‰ä¸‰ç§æƒ…å†µæ˜¯True, å…¶ä»–éƒ½æ˜¯<code>False</code>)</p><p>ç„¶åå°±ä¸ç”¨å®šä¹‰<code>/=</code>äº†, <code>Haskell</code>ç›´æ¥ä½¿ç”¨é»˜è®¤çš„<code>/=</code>å®šä¹‰</p></li></ul><p>å…¶ä¸­ç±»å‹å®šä¹‰ä¹Ÿå¯ä»¥å¯¹ç±»å‹å‚æ•°å˜é‡è¿›è¡Œå®šä¹‰, å®šä¹‰<code>Mybe</code>ç±»å‹çš„å…ƒç´ æ´¾ç”Ÿè‡ª<code>Eq</code></p><pre class="line-numbers language-haskell" data-language="haskell"><code class="language-haskell">instance (Eq m) &#x3D;&gt; Eq (Maybe m) where
    Just x &#x3D;&#x3D; Just y &#x3D; x &#x3D;&#x3D; y
    Nothing &#x3D;&#x3D; Nothing &#x3D; True
    _ &#x3D;&#x3D; _ &#x3D; False<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>å¯ä»¥ä½¿ç”¨<code>:info</code>è·å–ç±»å‹æ‰€æ´¾ç”Ÿçš„<code>TypeClasses</code></p><pre class="line-numbers language-haskell" data-language="haskell"><code class="language-haskell">ghci&gt; :info Maybe
type Maybe :: * -&gt; *
data Maybe a &#x3D; Nothing | Just a
        -- Defined in â€˜GHC.Maybeâ€™
instance Applicative Maybe -- Defined in â€˜GHC.Baseâ€™
instance Eq a &#x3D;&gt; Eq (Maybe a) -- Defined in â€˜GHC.Maybeâ€™
instance Functor Maybe -- Defined in â€˜GHC.Baseâ€™
instance Monad Maybe -- Defined in â€˜GHC.Baseâ€™
instance Semigroup a &#x3D;&gt; Monoid (Maybe a) -- Defined in â€˜GHC.Baseâ€™
instance Ord a &#x3D;&gt; Ord (Maybe a) -- Defined in â€˜GHC.Maybeâ€™
instance Semigroup a &#x3D;&gt; Semigroup (Maybe a)
  -- Defined in â€˜GHC.Baseâ€™
instance Show a &#x3D;&gt; Show (Maybe a) -- Defined in â€˜GHC.Showâ€™
instance Read a &#x3D;&gt; Read (Maybe a) -- Defined in â€˜GHC.Readâ€™
instance MonadFail Maybe -- Defined in â€˜Control.Monad.Failâ€™
instance Foldable Maybe -- Defined in â€˜Data.Foldableâ€™
instance Traversable Maybe -- Defined in â€˜Data.Traversableâ€™<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>çœ‹ä¸€ä¸ªä¾‹å­: <code>yes-no typeclass</code></strong>ğŸ˜</p><p><code>yes-no typeclass</code>ç±»ä¼¼å¼±ç±»å‹çš„<code>Bool</code></p><pre class="line-numbers language-haskell" data-language="haskell"><code class="language-haskell">class YesNo a where
    yesno :: a -&gt; Bool
    
instance YesNo Int where
    yesno 0 &#x3D; False
    yesno _ &#x3D; True
 
instance YesNo [a] where
    yesno [] &#x3D; False
    yesno _ &#x3D; True
    
instance YesNo Bool where
    yesno &#x3D; id    -- idçš„ä½œç”¨å°±æ˜¯è¿”å›å‚æ•°<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>å®ç°ä¸€ä¸ªæ–¹æ³•</p><pre class="line-numbers language-haskell" data-language="haskell"><code class="language-haskell">yesnoIf :: (YesNo y) &#x3D;&gt; y -&gt; a -&gt; a -&gt; a
yesnoIf yesnoVal yesResult noResult &#x3D;
    if yesno yesnoVal then yesResult else noResult<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><h4 id="functor-typeclass">Functor typeclass</h4><p>ğŸš§<code>Functor typeclass</code>æ˜¯Haskellä¸­å¾ˆé‡è¦çš„<code>TypeClasses</code>, å…¶ä»…å®šä¹‰äº†<code>fmap</code>æ–¹æ³•, è¯¥æ–¹æ³•ç”¨äºå®ç°è¯¥ç±»å‹çš„<code>map</code>, æ€ä¹ˆå¤„ç†<code>f x</code>åˆ°<code>y</code></p><pre class="line-numbers language-haskell" data-language="haskell"><code class="language-haskell">class Functor f where
    fmap :: (a -&gt; b) -&gt; f a -&gt; f b<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>ä¾‹å¦‚åœ¨<code>List</code>ä¸­</p><pre class="line-numbers language-haskell" data-language="haskell"><code class="language-haskell">instance Functor [] where
    fmap &#x3D; map
    
fmap (*2) [1..3]
-- [2,4,6]<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>åœ¨<code>Maybe</code>ä¸­å®ç°</p><pre class="line-numbers language-haskell" data-language="haskell"><code class="language-haskell">instance Functor Maybe where
    fmap f (Just x) &#x3D; Just (f x)
    fmap f Nothing &#x3D; Nothing<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>åœ¨<code>Either</code>ä¸­å®ç°(å¦‚æœæ˜¯<code>Right</code>å°±æ˜ å°„, å¦‚æœæ˜¯<code>Left</code>å°±ä¸)</p><pre class="line-numbers language-haskell" data-language="haskell"><code class="language-haskell">data Either a b &#x3D; Left a | Right b  -- Either å®šä¹‰

instance Functor (Either a) where
    fmap f (Right x) &#x3D; Right (f x)
    fmap f (Left x) &#x3D; Left x<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="kind">Kind</h4><p>åœ¨å®šä¹‰<code>Type</code>çš„æ—¶å€™æˆ‘ä»¬å¯ä»¥é€šè¿‡ç»™å®šç±»å‹å‚æ•°è€Œå®ç°ç±»ä¼¼"æ¨¡æ¿"("å¤šæ€")çš„åŠŸèƒ½. ä¹Ÿå°±æ˜¯è¯´, å®šä¹‰<code>Type</code>çš„æ—¶å€™å¯ä»¥ç»™ä¸€ä¸ªå‚æ•°ç±»å‹, è¿”å›ä¸€ä¸ª"å…·ä½“"çš„<code>Type</code>. ğŸ¤”çœ‹èµ·æ¥æœ‰ç‚¹åƒå‡½æ•°?</p><p>è¿˜æœ‰ä¸ªé—®é¢˜, çœ‹çœ‹<code>Just 5</code>çš„ç±»å‹<code>(Just 5) :: Num a =&gt; Maybe a</code>, ä»–æ˜¯æ€ä¹ˆçŸ¥é“<code>5</code>æ˜¯<code>Num</code>ç±»å‹çš„å‘¢? ğŸ¤”å¾ˆç®€å•, <code>5</code>ä¸Šè¾¹ç»‘å®šäº†ä¸€ä¸ª<code>Type</code>æ ‡ç­¾ğŸ·. å¯ä»¥ä½¿ç”¨<code>:k</code>æŸ¥çœ‹</p><pre class="line-numbers language-haskell" data-language="haskell"><code class="language-haskell">ghci&gt; :k Int
-- Int :: *<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p><code>*</code>æ ‡è®°è¡¨ç¤ºä¸€ä¸ª"å…·ä½“"çš„Type, å°±æ˜¯å®šä¹‰ç±»å‹çš„æ—¶å€™æ²¡æœ‰ç±»å‹å‚æ•°.</p><pre class="line-numbers language-haskell" data-language="haskell"><code class="language-haskell">ghci&gt; :k Maybe
-- Maybe :: * -&gt; *<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>ä¸<code>:t</code>ç±»ä¼¼, è¿™ä¸ª<code>Kind</code>çš„æ„æ€æ˜¯æ¥å—ä¸€ä¸ª<code>*</code>(å…·ä½“çš„ç±»å‹), è¿”å›ä¸€ä¸ª<code>*</code>(å…·ä½“çš„ç±»å‹), åŒç†</p><pre class="line-numbers language-haskell" data-language="haskell"><code class="language-haskell">ghci&gt; :k Maybe Int
-- Maybe Int :: *<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>è¡¨ç¤º<code>Maybe Int</code>æ˜¯ä¸€ä¸ªå…·ä½“çš„ç±»å‹. <code>Kind</code>ä¹Ÿæ”¯æŒæŸ¯é‡ŒåŒ–</p><pre class="line-numbers language-haskell" data-language="haskell"><code class="language-haskell">ghci&gt; :k Either
-- Either :: * -&gt; * -&gt; *
ghci&gt; :k Either String
-- Either String :: * -&gt; *
ghci&gt; :k Either String Int
-- Either String Int :: *<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><hr><h3 id="è¾“å…¥ä¸è¾“å‡º">è¾“å…¥ä¸è¾“å‡º</h3><p>åœ¨å‘½ä»¤å¼è¯­è¨€ä¸­è½»è€Œæ˜“ä¸¾å®ç°çš„IO, åœ¨<code>Haskell</code>å´æ˜¯ä¸€ä»¶éš¾äº‹, Terminalæ˜¾ç¤ºçš„å†…å®¹æœ¬èº«æ˜¯ä¸€ä¸ªå˜é‡, è€Œ<code>Haskell</code>çš„å‡½æ•°æ˜¯æ— å‰¯ä½œç”¨çš„çº¯å‡½æ•°. å‘å±å¹•è¾“å‡ºæ„å‘³ç€ä¿®æ”¹äº†å¤–éƒ¨å˜é‡. å°±åƒå°†IPv6æ•°æ®åŒ…æ‰“åŒ…æˆIPv4æ•°æ®åŒ…ä»¥é€šè¿‡IPv4ç¯å¢ƒä¸€æ ·. <code>Haslell</code>é‡‡å–äº†ç±»ä¼¼"éš§é“"çš„æ–¹æ³•è§£å†³è¿™ä¸€é—®é¢˜ğŸª†</p><ul><li>å°†éœ€è¦è¾“å‡ºçš„æ•°æ®"åŒ…è£…"æˆä¸€ç§ç‰¹æ®Šçš„ç±»å‹é€å‡ºå‡½æ•°, è¿™ä¸ªç‰¹æ®Šçš„ç±»å‹å¯ä»¥ä¸éçº¯å‡½æ•°ç¯å¢ƒæ¥è§¦, éçº¯å‡½æ•°ç¯å¢ƒä¸­å‡½æ•°è·å–åŒ…è£…ä¸­çš„æ•°æ®å¹¶è¾“å‡º</li><li>åœ¨è·å–è¾“å…¥æ—¶, éçº¯å‡½æ•°ç¯å¢ƒå°†æ•°æ®"åŒ…è£…"ä¸ºç‰¹æ®Šç±»å‹, å°†ç‰¹æ®Šç±»å‹æ•°æ®ä¼ å…¥<code>Haskell</code>, <code>Haskell</code>å–å‡ºå…¶å†…éƒ¨çš„æ•°æ®</li></ul><h4 id="åŸºç¡€ioå‡½æ•°">åŸºç¡€IOå‡½æ•°</h4><ul><li><p><strong><code>main</code>&amp;<code>do</code>æ–¹æ³•</strong>ğŸ“‡</p><p>é¦–å…ˆè¦äº†è§£çš„æ˜¯<code>main</code>, <strong>æ‰€æœ‰IOç›¸å…³åŠ¨ä½œéƒ½å¿…é¡»ç›´æ¥æˆ–é—´æ¥ç»‘å®šåœ¨<code>main</code>å‡½æ•°ä¸Šæ‰ä¼šè¢«æ‰§è¡Œ</strong></p><p><pre class="line-numbers language-haskell" data-language="haskell"><code class="language-haskell">main &#x3D; putStrLn &quot;hello, world&quot;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></p><p><code>main</code>ä¸­ä¸å¯èƒ½åªç»‘å®šä¸€ä¸ªIOå‡½æ•°, å¯ä»¥ä½¿ç”¨<code>do</code>å¯ä»¥é“¾æ¥ä¸€ä¸²IOæŒ‡ä»¤</p><pre class="line-numbers language-haskell" data-language="haskell"><code class="language-haskell">main &#x3D; do
    putStrLn &quot;Hello&quot;
    putStrLn &quot;Helloha&quot;
    putStrLn &quot;nihao&quot;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>å°†æ‰€æœ‰IOéƒ½ç›´æ¥å†™åœ¨<code>main</code>ä¸Šæ˜¯åœ¨æœ‰ç‚¹å†—é•¿, æˆ‘ä»¬å¯ä»¥é—´æ¥ç»‘å®šIOå‡½æ•°</p><pre class="line-numbers language-haskell" data-language="haskell"><code class="language-haskell">main &#x3D; do
  putStrLn &quot;hi&quot;
  name &lt;- getLine
  demo name

demo name &#x3D; putStrLn (&quot;Hi &quot; ++ name ++ &quot; !&quot;)

demo2 &#x3D; putStrLn &quot;hiii&quot; -- æ²¡ç»‘åœ¨mainä¸Šå°±ä¸æ‰§è¡Œ
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li><li><p><strong>"åŒ…è£…"çš„ç±»å‹</strong>ğŸ</p><ul><li><p>è™½ç„¶å¹¶ä¸çŸ¥é“IOå‡½æ•°æœ‰é‚£äº›, ä½†æ˜¯éšéšçº¦çº¦è¿˜æ˜¯çŸ¥é“ä¸Šé¢çš„<code>putStrLn</code>æ˜¯ç”¨æ¥è¾“å‡ºçš„, å°è¯•çœ‹çœ‹å…¶åŒ…è£…çš„ç±»å‹</p><p><pre class="line-numbers language-haskell" data-language="haskell"><code class="language-haskell">ghci&gt; :t putStrLn 
putStrLn :: String -&gt; IO ()<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre></p><p>æ”¶å…¥ä¸€ä¸ª<code>String</code>, å¾—åˆ°ä¸€ä¸ª<code>IO ()</code>ç±»å‹(<code>IO action</code>), è¿™é‡Œçš„<code>IO</code>å°±æ˜¯åŒ…è£…, åé¢æ¥ç€ä¸€ä¸ªç©ºTuple, ä½œä¸ºä¸€ä¸ªè¾“å‡ºå‡½æ•°, æˆ‘ä»¬å°†æ•°æ®æ”¾åœ¨ç›’å­é‡Œé¢è¾“å‡º, å¤–éƒ¨ç¯å¢ƒæ¥å—å¹¶æ‹¿èµ°æ•°æ®, è¿™ä¸ªåŒ…è£…é‡Œé¢å°±æˆç©ºçš„äº†, æ‰€ä»¥è¿”å›ä¸€ä¸ªç©ºåŒ…è£…</p></li><li><p>è™½ç„¶å¹¶ä¸çŸ¥é“IOå‡½æ•°æœ‰é‚£äº›, ä½†æ˜¯éšéšçº¦çº¦è¿˜æ˜¯çŸ¥é“ä¸Šé¢çš„<code>getLine</code>æ˜¯ç”¨æ¥è¾“å…¥çš„, å°è¯•çœ‹çœ‹å…¶åŒ…è£…çš„ç±»å‹</p><p><pre class="line-numbers language-haskell" data-language="haskell"><code class="language-haskell">ghci&gt; :t getLine
getLine :: IO String<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre></p><p>æ²¡æ¯›ç—…, å°±æ˜¯ä¸€ä¸ªIOåŒ…è£…, åŒ…è£…å†…æ˜¯ä¸€ä¸ª<code>String</code>.</p><p>é‚£ä¹ˆå¦‚ä½•è·å–åŒ…è£…ä¸­çš„æ•°æ®å‘¢? , ä½¿ç”¨<code>&lt;-</code>ç¬¦å·å°†åŒ…è£…ç±»å‹<code>IO String</code>è§£åŒ…ä¸º<code>String</code>, <strong>æ³¨æ„: <code>&lt;-</code>ç¬¦å·åªèƒ½ç”¨äº<code>do</code>è¯­å¥, è¿™ä¿è¯äº†ä¸çº¯ç²¹çš„ä¸œè¥¿åªå­˜åœ¨äºdoä¸­</strong></p></li><li><p><code>main</code>çš„ç±»å‹: <code>main</code>çš„ç±»å‹ä¸º<code>do</code>çš„æœ€åä¸€æ¡æŒ‡ä»¤å†³å®š, è€Œ<code>do</code>è¿”å›ç±»å‹å¿…é¡»æ˜¯<code>IO *</code></p><p><pre class="line-numbers language-haskell" data-language="haskell"><code class="language-haskell">main &#x3D; do
  putStrLn &quot;hi&quot;       -- ğŸ‘, ç±»å‹ä¸ºIO ()

main &#x3D; do
  putStrLn &quot;hi&quot;
  getLine             -- ğŸ‘, ç±»å‹ä¸ºIO String

main &#x3D; do
  putStrLn &quot;hi&quot;
  name &lt;- getLine     -- ğŸ‘, ç±»å‹ä¸ºString<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></p></li></ul></li><li><p><code>let binding</code></p><p>åœ¨å‡½æ•°ä¸­, æˆ‘ä»¬å¯ä»¥ä½¿ç”¨<code>where</code>/<code>let-in</code>æŒ‡å®šå±€éƒ¨å‡½æ•°, ä½†æ˜¯åœ¨<code>do</code>è¯­å¥ä¸­æˆ‘ä»¬åªèƒ½ä½¿ç”¨<code>let</code>(å› ä¸º<code>do</code>æ˜¯ä¸€ä¸ªè¡¨è¾¾å¼)</p><pre class="line-numbers language-haskell" data-language="haskell"><code class="language-haskell">import Data.Char

main &#x3D; do
    putStrLn &quot;What&#39;s your first name?&quot;
    firstName &lt;- getLine
    putStrLn &quot;What&#39;s your last name?&quot;
    lastName &lt;- getLine
    let bigFirstName &#x3D; map toUpper firstName
        bigLastName &#x3D; map toUpper lastName
    putStrLn $ &quot;hey &quot; ++ bigFirstName ++ &quot; &quot; ++ bigLastName ++ &quot;, how are you?&quot;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li><li><p><strong><code>do-block</code>ä¸<code>return</code></strong></p><p>ä»¥ä¸‹å‡½æ•°å®ç°äº†ä¸æ–­ä»Terminalè¯»å–å­—ç¬¦ä¸², å¹¶å°†å¥å­ä¸­çš„å•è¯åè½¬</p><pre class="line-numbers language-haskell" data-language="haskell"><code class="language-haskell">main &#x3D; do
    line &lt;- getLine
    if null line
        then return ()
        else do
            putStrLn $ reverseWords line
            main

reverseWords :: String -&gt; String
reverseWords &#x3D; unwords . map reverse . words<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li><p>å¯ä»¥çœ‹åˆ°<code>main</code>ä¹Ÿå¯ä»¥é€’å½’è°ƒç”¨, ä½†æ˜¯åœ¨è¿™ä¸ª<code>else</code>è¯­å¥ä¸­æˆ‘ä»¬é¡ºåºè°ƒç”¨äº†ä¸¤ä¸ªè¯­å¥, æ‰€ä»¥åº”è¯¥ç”¨<code>do</code>åŒ…èµ·æ¥</p></li><li><p>æ³¨æ„<code>line=null</code>åçš„<code>then return ()</code>, è¿™ä¸ª<code>return</code>çš„ä½œç”¨æ˜¯<strong>ä½¿ç”¨ä¸€ä¸ª <code>pure value</code>æ„é€ ä¸€ä¸ª<code>IO action</code></strong>, ä¹Ÿå°±æ˜¯è¯´è¿™é‡Œ<code>return ()</code>åªæ˜¯æ„é€ äº†ä¸€ä¸ª<code>IO Action ()</code>, ä½œä¸º<code>do-block</code>çš„æœ€åä¸€å¥, <code>IO Action ()</code>æˆä¸ºäº†è¿”å›å€¼</p></li><li><p>è°¨è®°: <code>return</code>å‡½æ•°åªæ˜¯æ„é€ äº†ä¸€ä¸ª<code>IO Action</code>, ç»ä¸æ˜¯å‘½ä»¤å¼ç¼–ç¨‹ä¸­çš„åœæ­¢è§£æè¿”å›, ä¸‹é¢çš„ä»£ç ä¼šè¿”å›<code>IO ()</code>(å› ä¸º<code>putStrLn</code>)</p><pre class="line-numbers language-haskell" data-language="haskell"><code class="language-haskell">main &#x3D; do
    return ()
    return &quot;HAHAHA&quot;
    line &lt;- getLine
    return &quot;BLAH BLAH BLAH&quot;
    return 4
    putStrLn line<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li></ul></li><li><p>å¸¸è§IOå‡½æ•°</p><ul><li><code>putStrLn string</code>å°†<code>string</code>æ‰“å°åœ¨Terminalä¸­å¹¶<strong>æ¢è¡Œ</strong></li><li><code>putStr string</code> è·Ÿ <code>putStrLn</code> åªæ˜¯ä¸æ¢è¡Œ</li><li><code>putChar char</code> æ¥å—ä¸€ä¸ªå­—ç¬¦ï¼Œå¹¶å›ä¼ ä¸€ä¸ª <code>IO action</code> å°†ä»–æ‰“å°åˆ°ç»ˆç«¯ä¸Š</li><li><code>print</code>æ¥å—<code>Show</code>ç±»å‹çš„å€¼ï¼Œè°ƒç”¨ <code>show</code> æ¥å°†å€¼å˜æˆå­—ä¸²ç„¶åå°†å…¶è¾“å‡ºåˆ°ç»ˆç«¯ä¸Š. åŸºæœ¬ä¸Š, ä»–å°±æ˜¯ <code>putStrLn . show</code></li><li><code>getChar</code> æ˜¯ä¸€ä¸ªä»è¾“å…¥è¯»è¿›ä¸€ä¸ªå­—ç¬¦çš„ <code>IO action</code></li><li><code>when</code>ä¼ å…¥<code>Bool</code>ä¸<code>IO Action</code>, è‹¥ä¸º<code>True</code>åˆ™å›ä¼ <code>IO Action</code>, ä¸º<code>False</code>åˆ™å›ä¼ <code>IO ()</code></li></ul></li><li><p>IOå‡½æ•°ä¸­çš„"<code>Functor</code>"</p><ul><li><p><code>sequence</code>: æ¥æ”¶<code>IO Action</code>çš„<code>List</code>, ä¾æ¬¡æ‰§è¡Œå¹¶è¿”å›<code>IO è¿”å›å€¼çš„List</code>å³: <code>[IO a] -&gt; IO [a]</code></p><pre class="line-numbers language-haskell" data-language="haskell"><code class="language-haskell">main &#x3D; do
  xs &lt;- sequence [getLine, getLine, getLine]
  print xs<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>è®°å¾—, <code>sequence</code>è¿”å›çš„æ˜¯<code>IO [a]</code>, æ‰€ä»¥è¿˜ç”¨<code>&lt;-</code>è¿”å›</p><pre class="line-numbers language-haskell" data-language="haskell"><code class="language-haskell">main &#x3D; do
  xs &lt;- sequence . map print $ [1 .. 3]
  print xs        -- [(),(),()] printè¿”å›çš„æ˜¯ç©ºTuple, è¿™é‡Œä¹Ÿæ˜¯<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre></li><li><p><code>mapM</code>ç›¸å½“äºå…ˆ<code>map</code>å†<code>sequence</code>. å³</p><pre class="line-numbers language-haskell" data-language="haskell"><code class="language-haskell">main &#x3D; do
  xs &lt;- mapM print [1, 2, 3]
  print xs<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>ç›¸å½“äº</p><pre class="line-numbers language-haskell" data-language="haskell"><code class="language-haskell">main &#x3D; do
  xs &lt;- mapM&#39; print [1, 2, 3]
  print xs

mapM&#39; :: (a -&gt; IO b) -&gt; [a] -&gt; IO [b]
mapM&#39; f &#x3D; (sequence . map f)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><code>mapM_</code>å°±æ˜¯è¿”å›ä¸º<code>return ()</code>çš„<code>mapM</code></p></li><li><p><code>forever</code>æ˜¯<code>Monad</code>çš„æ–¹æ³•, å…¶æ¥æ”¶ä¸€ä¸ª<code>IO Action</code>å¹¶æ­»å¾ªç¯æ‰§è¡Œ, å¦‚</p><pre class="line-numbers language-haskell" data-language="haskell"><code class="language-haskell">import Control.Monad.Logic (forever)
import Unicode.Char (toUpper)

main &#x3D; forever $ do
  t &lt;- getLine
  putStrLn $ map toUpper t<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>ç­‰ä»·äº</p><pre class="line-numbers language-haskell" data-language="haskell"><code class="language-haskell">import Control.Monad.Logic (forever)
import Unicode.Char (toUpper)

main &#x3D; do
  t &lt;- getLine
  putStrLn $ map toUpper t
  main<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li><li><p><code>forM</code>æ˜¯<code>Monad</code>çš„æ–¹æ³•, <code>forM</code>ä¹‹äº<code>forever</code>ç›¸å½“äº<code>mapM</code>ä¹‹äº<code>sequence</code>. ä½œç”¨æ˜¯å…ˆMap, å†å¯¹æ¯ä¸€é¡¹æ‰§è¡Œå‡½æ•°.</p><p>å®ç°è¾“å…¥å››ä¸ªå­—ç¬¦ä¸²å¹¶è¾“å‡º</p><pre class="line-numbers language-haskell" data-language="haskell"><code class="language-haskell">import Control.Monad

main &#x3D; do
    colors &lt;- forM [1,2,3,4] (\a -&gt; do
        putStrLn $ &quot;Which color do you associate with the number &quot; ++ show a ++ &quot;?&quot;
        color &lt;- getLine
        return color)
    putStrLn &quot;The colors that you associate with 1, 2, 3 and 4 are: &quot;
    mapM putStrLn colors<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>ç­‰ä»·äº</p><pre class="line-numbers language-haskell" data-language="haskell"><code class="language-haskell">main &#x3D; do
  t &lt;-
    forM&#39;
      [1, 2, 3, 4]
      ( \a -&gt; do
          putStrLn $ show a ++ &quot;: &quot;
          i &lt;- getLine
          return i
      )
  mapM putStrLn t

forM&#39; (x : xs) f &#x3D; f x : forM&#39; xs f
forM&#39; [] _ &#x3D; []<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li></ul></li></ul><h4 id="æ–‡ä»¶ä¸å­—ç¬¦æµ">æ–‡ä»¶ä¸å­—ç¬¦æµ</h4><ul><li><p><code>getContents</code>: ä»Terminalè¯»å–<code>String</code>ç›´åˆ°<code>EOF</code>, ä¸”<code>getContents</code>æ˜¯æƒ°æ€§çš„, éœ€è¦å¤šå°‘ä»å†…å­˜ä¸­æ‹¿å¤šå°‘, ä¹‹å‰<code>forever</code>å¤§å†™çš„ç¨‹åºå¯ä»¥æ”¹æˆ</p><pre class="line-numbers language-haskell" data-language="haskell"><code class="language-haskell">import Unicode.Char (toUpper)
main &#x3D; do
  t &lt;- getContents
  putStrLn $ map toUpper t<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>æ­£å› ä¸ºæ˜¯æƒ°æ€§çš„, æˆ‘ä»¬å¯ä»¥åˆ†æ‰¹è¾“å…¥å†…å®¹(åªæœ‰åœ¨<code>map</code>çš„æ—¶å€™æ‰ä¼šè°ƒå…¥)ğŸ«—</p></li><li><p>è¯»å†™æ–‡ä»¶ğŸ“„</p><pre class="line-numbers language-haskell" data-language="haskell"><code class="language-haskell">import System.IO

main &#x3D; do
    handle &lt;- openFile &quot;girlfriend.txt&quot; ReadMode
    contents &lt;- hGetContents handle
    putStr contents
    hClose handle<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>å…¶ä¸­, <code>openFile</code>è·å–æ–‡ä»¶Handle(å¯ä»¥ç†è§£æˆä¸€ä¸ªæ–‡ä»¶æŒ‡é’ˆåŠå…¶<code>Context</code>)ç±»å‹å®šä¹‰</p><pre class="line-numbers language-haskell" data-language="haskell"><code class="language-haskell">openFile :: FilePath -&gt; IOMode -&gt; IO Handle<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><code>IOMode</code>æè¿°äº†æ–‡ä»¶è¯»å†™çš„æ¨¡å¼, å®šä¹‰</p><pre class="line-numbers language-haskell" data-language="haskell"><code class="language-haskell">data IOMode &#x3D; ReadMode | WriteMode | AppendMode | ReadWriteMode<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><code>FilePath</code>å®šä¹‰</p><pre class="line-numbers language-haskell" data-language="haskell"><code class="language-haskell">type FilePath &#x3D; String<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><code>openFile</code>è¿”å›<code>IO Handle</code>, ä¹‹åä½¿ç”¨<code>hGetContents</code>å°†æ–‡ä»¶Handleä¸­æ•°æ®å–å‡ºå¾—åˆ°<code>IO String</code>. <code>hGetContents</code>ä¸<code>getContents</code>ç±»ä¼¼, ä¹Ÿæ˜¯Lazyçš„, åœ¨è¯»å–æ–‡ä»¶æ—¶å¹¶ä¸ä¼šå°†æ–‡ä»¶å…¨éƒ¨è¯»å…¥å†…å­˜. æ–‡ä»¶æ“ä½œç»“æŸåä½¿ç”¨<code>hClose</code>å…³é—­æ–‡ä»¶</p></li><li><p>å¦ä¸€ç§è¯»å†™æ–‡ä»¶çš„æ–¹å¼æ˜¯<code>withFile</code>, å®šä¹‰</p><pre class="line-numbers language-haskell" data-language="haskell"><code class="language-haskell">withFile :: FilePath -&gt; IOMode -&gt; (Handle -&gt; IO a) -&gt; IO a<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>å³: æ¥æ”¶ä¸¤ä¸ªå‚æ•°ä¸æ–‡ä»¶å¤„ç†å‡½æ•°, æœ€åè¿”å›ä¸€ä¸ª<code>IO</code>, ä¾‹å¦‚</p><pre class="line-numbers language-haskell" data-language="haskell"><code class="language-haskell">import System.IO

main &#x3D; do
    withFile &quot;girlfriend.txt&quot; ReadMode (\handle -&gt; do
            contents &lt;- hGetContents handle
            putStr contents)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>å®¹æ˜“å®ç°<code>withFile</code></p><pre class="line-numbers language-haskell" data-language="haskell"><code class="language-haskell">withFile&#39; :: FilePath -&gt; IOMode -&gt; (Handle -&gt; IO a) -&gt; IO a
withFile&#39; path mode f &#x3D; do
    handle &lt;- openFile path mode
    result &lt;- f handle
    hClose handle
    return result<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li><li><p>ä¸<code>hGetContents</code>æ¯”èµ·æ¥æ›´åŠ å®¹æ˜“çš„æ–‡ä»¶è¯»å…¥å‡½æ•°æœ‰<code>hGetLine</code>, <code>hPutStr</code>, <code>hPutStrLn</code>, <code>hGetChar</code>, ä»–ä»¬éƒ½æ¥å—ä¸€ä¸ª<code>IO Handle</code>, è¡Œä¸ºä¸å»æ‰<code>h</code>å‰ç¼€å‡½æ•°ç›¸åŒ</p></li><li><p>ä¹Ÿå¯ä»¥çœç•¥<code>IO Handle</code>ä¸<code>hClose</code>ä½¿ç”¨å¦‚ä¸‹<code>readFile</code>, <code>writeFile</code>, <code>appendFile</code>å‡½æ•°è¯»å†™æ–‡ä»¶</p><pre class="line-numbers language-haskell" data-language="haskell"><code class="language-haskell">import System.IO

main &#x3D; do
    contents &lt;- readFile &quot;girlfriend.txt&quot;
    putStr contents<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-haskell" data-language="haskell"><code class="language-haskell">import System.IO

main &#x3D; do
    contents &lt;- readFile &quot;girlfriend.txt&quot;
    writeFile &quot;girlfriendcaps.txt&quot; &quot;123456&quot;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-haskell" data-language="haskell"><code class="language-haskell">import System.IO

main &#x3D; do
    todoItem &lt;- getLine      -- getLine ä¸åŒ…å«å›è½¦
    appendFile &quot;todo.txt&quot; (todoItem ++ &quot;\n&quot;)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre></li><li><p>IOå‡½æ•°æ˜¯æƒ°æ€§çš„, å¯ä»¥æ‰‹åŠ¨ä½¿ç”¨<code>hSetBuffering</code>é…ç½®buffer, ç±»å‹å®šä¹‰æˆ‘iå“¦</p><pre class="line-numbers language-haskell" data-language="haskell"><code class="language-haskell">hSetBuffering -&gt; IO Handle -&gt; BufferMode<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>å…¶ä¸­</p><pre class="line-numbers language-haskell" data-language="haskell"><code class="language-haskell">type BufferMode &#x3D; NoBuffering | LineBuffering | BlockBuffering (Maybe Int)<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>æœ€åä¸€é¡¹è¡¨ç¤ºBufferå¤§å°ä¸ºå¤šå°‘Byte</p></li><li><p><code>openTempFile</code>å‡½æ•°å¯ä»¥åœ¨å½“å‰ç›®å½•ä¸‹åˆ›å»ºå¹¶æ‰“å¼€ä¸€ä¸ªéšæœºåå­—çš„æ–‡ä»¶, ç”¨äºæš‚å­˜æ•°æ®</p></li></ul><h4 id="å‘½ä»¤è¡Œå‚æ•°">å‘½ä»¤è¡Œå‚æ•°</h4><p><code>System.Environment</code>çš„<code>getArgs</code>ä¸<code>getProgName</code>å®šä¹‰äº†å‘½ä»¤è¡Œç›¸å…³å‚æ•°</p><ul><li><p><code>getArgs</code>è¿”å›å‚æ•°æ•°ç»„, æœ€åä¸€ä¸ªå…ƒç´ æ˜¯æ‰€æœ‰å‚æ•°String</p></li><li><p><code>getProgName</code>è¿”å›ç¨‹åºå, ä¾‹å¦‚</p><pre class="line-numbers language-haskell" data-language="haskell"><code class="language-haskell">import System.Environment
import Data.List

main &#x3D; do
    args &lt;- getArgs
    progName &lt;- getProgName
    putStrLn &quot;The arguments are:&quot;
    mapM putStrLn args
    putStrLn &quot;The program name is:&quot;
    putStrLn progName<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-haskell" data-language="haskell"><code class="language-haskell">$ .&#x2F;arg-test first second w00t &quot;multi word arg&quot;
The arguments are:
first
second
w00t
multi word arg
The program name is:
arg-test<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li></ul><h3 id="å‡½æ•°å¼åœ°è§£å†³é—®é¢˜">å‡½æ•°å¼åœ°è§£å†³é—®é¢˜</h3><p>ä¸€ä¸ªä¸é”™çš„æ€è€ƒæ€è·¯æ˜¯</p><ol type="1"><li>æ˜ç¡®æˆ‘ä»¬è¾“å…¥ä¸è¾“å‡ºçš„æ•°æ®ç±»å‹</li><li>å¿˜æ‰<code>Haskell</code>, æƒ³æƒ³æˆ‘ä»¬è‡ªå·±æ˜¯æ€ä¹ˆä¸€æ­¥æ­¥è§£é¢˜çš„</li><li>æ€è€ƒå¦‚ä½•åœ¨<code>Haskell</code>ä¸­è¡¨è¾¾æˆ‘ä»¬çš„æ•°æ®, åº”è¯¥å¦‚ä½•å®šä¹‰æˆ‘ä»¬çš„è¡Œä¸º</li><li>åœ¨ Haskell ä¸­è¦å¦‚ä½•å¯¹è¿™äº›æ•°æ®åšè¿ç®—æ¥äº§ç”Ÿå‡ºè§£ç­”</li></ol><h4 id="æ±‚è§£é€†æ³¢å…°è¡¨è¾¾å¼">æ±‚è§£é€†æ³¢å…°è¡¨è¾¾å¼</h4><p><span class="exturl" data-url="aHR0cHM6Ly96aC53aWtpcGVkaWEub3JnL3poLWNuLyVFOSU4MCU4NiVFNiVCMyVBMiVFNSU4NSVCMCVFOCVBMSVBOCVFNyVBNCVCQSVFNiVCMyU5NQ==">é€†æ³¢å…°è¡¨ç¤ºæ³•-wiki<i class="fa fa-external-link-alt"></i></span></p><p>åœ¨å‘½ä»¤å¼ç¼–ç¨‹ä¸­, æˆ‘ä»¬å¯ä»¥ä½¿ç”¨ä¸€ä¸ªæ ˆè½»æ¾å¤„ç†, åœ¨<code>Haskell</code>ä¸­, å‘ååŠ å…¥å…ƒç´ å¾ˆéº»çƒ¦, ä¸å¦‚å‘å‰åŠ å…¥å…ƒç´ </p><ol type="1"><li>æ˜ç¡®æˆ‘ä»¬è¾“å…¥ä¸è¾“å‡ºçš„æ•°æ®ç±»å‹: <code>String-&gt;Num</code></li><li>å¿˜æ‰<code>Haskell</code>, æƒ³æƒ³æˆ‘ä»¬è‡ªå·±æ˜¯æ€ä¹ˆä¸€æ­¥æ­¥è§£é¢˜çš„<ol type="1"><li>å¦‚æœæ•°å­—åˆ™å‹æ ˆ, é‡åˆ°ç¬¦å·åˆ™å¼¹ä¸¤ä¸ªå…ƒç´ , è®¡ç®—åå‹æ ˆ</li></ol></li><li>æ€è€ƒå¦‚ä½•åœ¨<code>Haskell</code>ä¸­è¡¨è¾¾æˆ‘ä»¬çš„æ•°æ®, åº”è¯¥å¦‚ä½•å®šä¹‰æˆ‘ä»¬çš„è¡Œä¸º<ol type="1"><li>å°†<code>String</code>å˜ä¸ºä¸€ä¸ªä¸ªå…ƒç´ <code>String</code>(æ•°å­—/ç¬¦å·)çš„<code>List</code></li><li>è®¡ç®—åˆ°æœ€åå°±å¾—åˆ°äº†ä¸€ä¸ªå•å…ƒç´ <code>List</code></li><li>å–å‡ºè¿™ä¸ªå…ƒç´ </li></ol></li><li>åœ¨ Haskell ä¸­è¦å¦‚ä½•å¯¹è¿™äº›æ•°æ®åšè¿ç®—æ¥äº§ç”Ÿå‡ºè§£ç­”<ol type="1"><li>ä½¿ç”¨<code>words</code>è§£æ</li><li>ä½¿ç”¨<code>flodl</code>éå†</li><li>ä½¿ç”¨<code>guard</code>åˆ¤æ–­å…ƒç´ ç±»å‹</li><li>ä½¿ç”¨<code>x:xs</code>å‹æ ˆ</li><li>ä½¿ç”¨<code>(x:y:ys)</code>æ¨¡å¼åŒ¹é…è·å–topsä¸å‰©ä¸‹å†…å®¹</li></ol></li></ol><pre class="line-numbers language-haskell" data-language="haskell"><code class="language-haskell">solveRPN :: (Fractional a, Read a) &#x3D;&gt; String -&gt; a
solveRPN xs &#x3D; head $ foldl foldingNum [] (words xs)
  where
    foldingNum (x : y : ys) &quot;+&quot; &#x3D; x + y : ys
    foldingNum (x : y : ys) &quot;-&quot; &#x3D; x - y : ys
    foldingNum (x : xs) &quot;-&quot; &#x3D; (-x) : xs    -- åªæœ‰åŒç›®è¿ç®—åŒ¹é…å¤±è´¥æ‰ä¼šåŒ¹é…
    foldingNum (x : y : ys) &quot;*&quot; &#x3D; x * y : ys
    foldingNum (x : y : ys) &quot;&#x2F;&quot; &#x3D; x &#x2F; y : ys
    foldingNum ys nums &#x3D; read nums : ys<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="æœ€çŸ­è·¯æœç´¢">æœ€çŸ­è·¯æœç´¢</h4><p>æœ‰ä¸¤ä¸ªèµ·ç‚¹ä¸ä¸¤ä¸ªç»ˆç‚¹, ä½ å¯ä»¥æŒ‡å®šèµ·ç‚¹ä¸ç»ˆç‚¹, æ±‚èµ·ç‚¹åˆ°ç»ˆç‚¹æœ€å°å€¼</p><p>æœ‰ä¸¤æ¡ä¸»è¦é“è·¯ï¼Œä»–ä»¬ä¸­é—´æœ‰å¾ˆå¤šå°è·¯è¿æ¥å½¼æ­¤ã€‚å¦‚æœä½ è¦èµ°å°è·¯çš„è¯éƒ½ä¼šèŠ±æ‰ä¸€å®šçš„æ—¶é—´ã€‚ä½ çš„é—®é¢˜å°±æ˜¯è¦é€‰ä¸€æ¡æœ€ä½³è·¯å¾„è®©ä½ å¯ä»¥å°½å¿«å‰å¾€ç»ˆç‚¹,</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">ST &#x3D;&#x3D;50&#x3D;&#x3D;+&#x3D;&#x3D;05&#x3D;&#x3D;+&#x3D;&#x3D;40&#x3D;&#x3D;+&#x3D;&#x3D;10&#x3D;&#x3D; ED
        ||     ||     ||
        30     20     25
        ||     ||     ||
ST &#x3D;&#x3D;10&#x3D;&#x3D;+&#x3D;&#x3D;90&#x3D;&#x3D;+&#x3D;&#x3D;02&#x3D;&#x3D;+&#x3D;&#x3D;8&#x3D;&#x3D; ED<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>è¾“å…¥æ ¼å¼: è·¯å¾„æŒ‰ç…§è‡ªå·¦å‘å³æ¯ç»„: ä¸Šä¸‹å³çš„æ¨¡å¼è¾“å…¥(æœ€åä¸¤ä¸ªEDä¹‹é—´é•¿åº¦ä¸º0), ä¾‹å¦‚ä¸Šä¾‹</p><pre class="line-numbers language-haskell" data-language="haskell"><code class="language-haskell">[50, 10, 30, 5, 90, 20, 40, 2, 25, 10, 8, 0]<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><ol type="1"><li>æ˜ç¡®æˆ‘ä»¬è¾“å…¥ä¸è¾“å‡ºçš„æ•°æ®ç±»å‹: <code>[Num]-&gt;[Char]</code></li><li>å¿˜æ‰<code>Haskell</code>, æƒ³æƒ³æˆ‘ä»¬è‡ªå·±æ˜¯æ€ä¹ˆä¸€æ­¥æ­¥è§£é¢˜çš„<ol type="1"><li>åˆ†åˆ«è®¡ç®—æ¯èµ°åˆ°ä¸€ä¸ªä¸Šä¸‹å²”è·¯å£çš„æœ€å°è·ç¦»</li></ol></li><li>æ€è€ƒå¦‚ä½•åœ¨<code>Haskell</code>ä¸­è¡¨è¾¾æˆ‘ä»¬çš„æ•°æ®, åº”è¯¥å¦‚ä½•å®šä¹‰æˆ‘ä»¬çš„è¡Œä¸º<ol type="1"><li>æˆ‘ä»¬éœ€è¦ä¸‹ä¸€ç»„è·¯å¾„çš„ä¸Šæ–¹è·¯çº¿èŠ±è´¹, ä¸‹æ–¹è·¯çº¿èŠ±è´¹, å²”è·¯ä¹‹é—´èŠ±è´¹, åˆ°è¾¾å‰ä¸€ä¸ªä¸Šä¸‹å²”è·¯å£èŠ±è´¹, è½¬ç§»åˆ°ä¸‹ä¸€ä¸ªå²”è·¯</li></ol></li><li>åœ¨ Haskell ä¸­è¦å¦‚ä½•å¯¹è¿™äº›æ•°æ®åšè¿ç®—æ¥äº§ç”Ÿå‡ºè§£ç­”<ol type="1"><li><code>åˆ°è¾¾ä¸Šæ–¹è·¯å£èŠ±è´¹=min(å‰ä¸€ä¸ªä¸Šæ–¹è·¯å£èŠ±è´¹+ä¸Šæ–¹è·¯çº¿èŠ±è´¹, å‰ä¸€ä¸ªä¸‹æ–¹è·¯å£èŠ±è´¹+ä¸‹æ–¹è·¯çº¿èŠ±è´¹+ä¸Šä¸‹è·¯å£èŠ±è´¹)</code></li><li>åˆ°è¾¾ä¸‹æ–¹è·¯å£èŠ±è´¹åŒç†</li></ol></li></ol><pre class="line-numbers language-haskell" data-language="haskell"><code class="language-haskell">pathGet :: (Num a, Ord a) &#x3D;&gt; [a] -&gt; a -&gt; a -&gt; [Char]
pathGet (t : b : r : xs) ct cb
  | cct &lt; ccb &#x3D; &#39;A&#39; : pathGet xs cct ccb
  | otherwise &#x3D; &#39;B&#39; : pathGet xs cct ccb
  where
    cct &#x3D; min (ct + t) (cb + b + r)
    ccb &#x3D; min (ct + t + r) (cb + b)
pathGet _ ct cb
  | ct &lt; cb &#x3D; &quot;A&quot;
  | otherwise &#x3D; &quot;B&quot;

res &#x3D; pathGet [50, 10, 30, 5, 90, 20, 40, 2, 25, 10, 8, 0] 0 0<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="ä»functoråˆ°monoids">ä»Functoråˆ°Monoids</h3><h4 id="functoræ˜¯ä»€ä¹ˆ">Functoræ˜¯ä»€ä¹ˆ</h4><p>åœ¨Haskellä¸­, <code>Functor</code>æ˜¯ä¸€ä¸ªç±»å‹ç±», å…¶ä»…å®šä¹‰äº†ä¸€ä¸ª<code>fmap</code>æ–¹æ³•ç”¨äºæè¿°Typeæ˜¯å¦‚ä½•è¢«Map Overçš„. ä»€ä¹ˆæ˜¯map overå‘¢?</p><p>Haskellçš„<code>List</code>ä¸­æœ‰ä¸€ä¸ª<code>map</code>æ–¹æ³•, å…è®¸ä¼ å…¥ä¸€ä¸ªå‡½æ•°ä¸<code>List</code>, è¿”å›ä¸€ä¸ªå°†Listçš„ä¸­æ¯ä¸€ä¸ªå…ƒç´ éƒ½æ‰§è¡Œå‡½æ•°çš„ç»“æœ. è¿™ä¸JSçš„<code>Array.map</code>ç±»ä¼¼. æ‰€ä»¥æˆ‘ä»¬å½“æ—¶è®¤ä¸º<code>Map</code>å°±æ˜¯ä¸€ä¸ªæ˜ å°„. ç„¶è€Œ, <code>Map</code>ä¸æ­¢å¯ä»¥åº”ç”¨äº<code>List</code>. <code>Map</code>å¯ä»¥ç”¨äºä»»ä½•å®šä¹‰äº†<code>fmap</code>çš„å¯¹è±¡</p><p>æˆ‘ä»¬å°†å¯¹è±¡åˆ†ä¸ºç®€å•å¯¹è±¡ä¸é«˜é˜¶å¯¹è±¡. ç®€å•å¯¹è±¡ä¹Ÿå¯ä»¥ç§°ä¹‹ä¸º"å€¼", ä¾‹å¦‚æ•°å­—, Charå°±æ˜¯ç®€å•å¯¹è±¡, æˆ‘ä»¬å¯ä»¥ç›´æ¥å¯¹å…¶è¿›è¡Œæœ´ç´ æ“ä½œ. é«˜é˜¶å¯¹è±¡å¥½åƒä¸€ä¸ªç”¨ç›’å­åŒ…è£…è¿‡çš„å¯¹è±¡ğŸ, å›é¡¾Listçš„å®šä¹‰</p><pre class="line-numbers language-haskell" data-language="haskell"><code class="language-haskell">data List a &#x3D; Empty | Cons a (List a) <span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>åœ¨è¿™é‡Œ, æˆ‘ä»¬å°†Listå½“ä½œä¸€ä¸ªæ•´ä½“. å…¶ä¸­åŒ…å«äº†ä¸€äº›ç›¸å¯¹"ç®€å•"çš„å¯¹è±¡. æˆ‘ä»¬æ— æ³•ç”¨æ™®é€šå‡½æ•°ç›´æ¥æ“ä½œè¿™äº›æ™®é€šå¯¹è±¡. ä¾‹å¦‚æˆ‘ä»¬æ²¡æ³•å¯¹ä¸€ä¸ª<code>[1,2,3]</code>è¿™ä¸ªæ•´ä½“æ‰§è¡Œ<code>(+1)</code>æ“ä½œ, å¦‚ä½•åˆºå…¥é«˜é˜¶å¯¹è±¡ğŸ¤º, è®©æ™®é€šå‡½æ•°æ“ä½œé«˜é˜¶å¯¹è±¡å†…éƒ¨çš„æ™®é€šå…ƒç´ å‘¢? å°†Typeå®šä¹‰ä¸ºä½¿ç”¨<code>Functor</code>å¹¶ä½¿ç”¨<code>fmap</code>, ä¾‹å¦‚æˆ‘æƒ³å°†<code>Maybe</code>ä¸­çš„å€¼<code>(+1)</code>:</p><pre class="line-numbers language-haskell" data-language="haskell"><code class="language-haskell">ghci&gt; t &#x3D; Just 2
ghci&gt; t + 1
-- &lt;interactive&gt;:2:1: error:
--     â€¢ Non type-variable argument in the constraint: Num (Maybe a)
--       (Use FlexibleContexts to permit this)
--     â€¢ When checking the inferred type
--         it :: forall &#123;a&#125;. (Num a, Num (Maybe a)) &#x3D;&gt; Maybe a
ghci&gt; fmap (+1) t
-- Just 3<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><code>Maybe</code>æ˜¯ä¸€ä¸ªé«˜é˜¶å¯¹è±¡, ä¹Ÿæ˜¯<code>Functor</code>çš„æ´¾ç”ŸType. å› æ­¤, æˆ‘ä»¬å¯ä»¥ä½¿ç”¨<code>fmap</code>å¯¹å†…éƒ¨å…ƒç´ è¿›è¡Œæ“ä½œ. é‚£, å…¶ä¸­<code>fmap</code>æ‹¿åˆ°å‡½æ•°ä¸<code>Maybe</code>ä¹‹åçš„è¡Œä¸ºç”±<code>Maybe</code>ç±»å‹å®šä¹‰æ—¶å®ç°(ç±»æ¯”, <code>map</code>æ‹¿åˆ°å‡½æ•°ä¸<code>List</code>ä¹‹åæ€ä¹ˆçŸ¥é“è¦å°†å‡½æ•°åº”ç”¨äºæ¯ä¸ªå…ƒç´ å‘¢? è¿™ä¹Ÿæ˜¯ç”±<code>List</code>æ´¾ç”Ÿ<code>Functor</code>æ—¶å€™å®ç°çš„)</p><p>ğŸ“Š<strong>æ€»ç»“: <code>Functor</code>æ˜¯ä¸€ä¸ªç±»å‹ç±», å®šä¹‰äº†ä¸€ä¸ª<code>fmap</code>å‡½æ•°, è¯¥å‡½æ•°æè¿°å¦‚ä½•ç”¨ä¸€ä¸ªæ™®é€šå‡½æ•°å¯¹é«˜é˜¶å¯¹è±¡è¿›è¡Œæ“ä½œ</strong></p><p><code>fmap</code>çš„å®šä¹‰å¦‚ä¸‹</p><pre class="line-numbers language-haskell" data-language="haskell"><code class="language-haskell">fmap :: (Functor f) &#x3D;&gt; (b -&gt; c) -&gt; f b -&gt; f c<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>å¯ä»¥çœ‹çœ‹<code>Maybe</code>çš„<code>Functor</code>å®ç°</p><pre class="line-numbers language-haskell" data-language="haskell"><code class="language-haskell">instance Functor Maybe where  
    fmap f (Just x) &#x3D; Just (f x)  
    fmap f Nothing &#x3D; Nothing<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>ä¹Ÿå¯ä»¥ä»¿åˆ¶ä¸€ä¸ª<code>List</code>çš„<code>Functor</code>å®ç°</p><pre class="line-numbers language-haskell" data-language="haskell"><code class="language-haskell">data List&#39; a &#x3D; Empty | Cons a (List&#39; a) deriving (Show)

instance Functor List&#39; where
  fmap _ Empty &#x3D; Empty
  fmap f (Cons x xs) &#x3D; Cons (f x) (fmap f xs)

t &#x3D; fmap (+ 1) $ Cons 1 $ Cons 2 $ Cons 3 Empty<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>âš–<strong>æœ€å: <code>Functor</code>çš„<code>fmap</code>å®ç°åº”è¯¥éµå¾ªå¦‚ä¸‹æ³•åˆ™</strong></p><ul><li>å¦‚æœæˆ‘ä»¬å¯¹ functor åš map <code>id</code>ï¼Œé‚£å¾—åˆ°çš„æ–°çš„ functor åº”è¯¥è¦è·ŸåŸæ¥çš„ä¸€æ ·. å³: <code>fmap id = id</code></li><li>å…ˆå°†ä¸¤ä¸ªå‡½æ•°åˆæˆå¹¶å°†ç»“æœ<code>map over</code>ä¸€ä¸ª<code>functor</code>çš„ç»“æœ, åº”è¯¥è·Ÿå…ˆå°†ç¬¬ä¸€ä¸ªå‡½æ•°<code>map over</code>ä¸€ä¸ª<code>functor</code>ï¼Œå†å°†ç¬¬äºŒä¸ªå‡½æ•°<code>map over</code>é‚£ä¸ª<code>functor</code>çš„ç»“æœæ˜¯ä¸€æ ·çš„. å³: <code>fmap (f . g) = fmap f . fmap g</code>æˆ–<code>fmap (f . g) F = fmap f (fmap g F)</code></li></ul><h4 id="applicative-functors">Applicative Functors</h4><p>ä»”ç»†çœ‹<code>fmap</code>çš„ç±»å‹å®šä¹‰, æˆ‘ä»¬çš„å‡½æ•°åªèƒ½æ¥æ”¶ä¸€ä¸ªå‚æ•°, å¹¶è¿”å›ä¸€ä¸ªå‚æ•°. æˆ‘ä»¬æ— æ³•è®©å‡½æ•°æ¥æ”¶å¤šä¸ªå‚æ•°, ä¾‹å¦‚<code>\ x y -&gt; x + y</code></p><p>âœ¨ä¸ºæ­¤, æˆ‘ä»¬å¯ä»¥é‡‡ç”¨<code>Functors</code>çš„å‡çº§ç‰ˆ<code>Applicative Functors</code>, å³<code>Applicative</code>ç±»å‹ç±», å…¶ç±»å‹å®šä¹‰å¦‚ä¸‹</p><pre class="line-numbers language-haskell" data-language="haskell"><code class="language-haskell">class (Functor f) &#x3D;&gt; Applicative f where  
    pure :: a -&gt; f a  
    (&lt;*&gt;) :: f (a -&gt; b) -&gt; f a -&gt; f b
    (&lt;$&gt;) :: (a -&gt; b) -&gt; f a -&gt; f b<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><ul><li><code>(Functor f) =&gt; Applicative f</code>è¯´æ˜<code>Applicative Functors</code>å¿…é¡»æ˜¯<code>Functors</code></li><li><code>pure</code>æ–¹æ³•æ¥æ”¶ä¸€ä¸ªå€¼, è¿”å›ä¸€ä¸ªå€¼ä¸ºè¯¥ç±»å‹çš„é«˜é˜¶å¯¹è±¡</li><li><code>&lt;*&gt;</code>æ¥æ”¶ä¸€ä¸ªåŒ…è£¹ç€å‡½æ•°çš„é«˜é˜¶å¯¹è±¡, å†æ¥æ”¶ä¸€ä¸ªé«˜é˜¶å¯¹è±¡, å¾—åˆ°å¦ä¸€ä¸ªé«˜é˜¶å¯¹è±¡. çœ‹èµ·æ¥ä¸<code>fmap</code>ç±»ä¼¼, åªä¸è¿‡æ¥æ”¶çš„å‡½æ•°ç”¨é«˜é˜¶å¯¹è±¡åŒ…èµ·æ¥äº†</li><li><code>&lt;$&gt;</code>çœ‹èµ·æ¥å°±æ˜¯å‡½æ•°ä¸åŒ…å¯¹è±¡çš„<code>&lt;*&gt;</code></li></ul><p><strong>å¯ä»¥çœ‹çœ‹<code>Maybe</code>çš„<code>Applicative Functors</code>å®šä¹‰</strong></p><pre class="line-numbers language-haskell" data-language="haskell"><code class="language-haskell">instance Applicative Maybe where  
  pure &#x3D; Just  
  Nothing &lt;*&gt; _ &#x3D; Nothing  
  (Just f) &lt;*&gt; something &#x3D; fmap f something
  f &lt;$&gt; x &#x3D; fmap f x<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>ä½¿ç”¨</p><pre class="line-numbers language-haskell" data-language="haskell"><code class="language-haskell">ghci&gt; Just (+3) &lt;*&gt; Just 9  
-- Just 12
ghci&gt; pure (+) &lt;*&gt; Just 3 &lt;*&gt; Just 5    -- ä¹Ÿå¯ä»¥ä½¿ç”¨pureè¿›è¡Œè½¬æ¢
-- Just 8  
ghci&gt; (+) &lt;$&gt; Just 3 &lt;*&gt; Just 4         -- è¿˜å¯ä»¥ç›´æ¥ä½¿ç”¨&lt;$&gt;
-- Just 7
ghci&gt; (++) &lt;$&gt; Just &quot;johntra&quot; &lt;*&gt; Just &quot;volta&quot;  
Just &quot;johntravolta&quot;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>äºæ˜¯æˆ‘ä»¬å¯ä»¥ç”¨<code>pure f &lt;*&gt; p1 &lt;*&gt; p2 &lt;*&gt; ...</code> / <code>f &lt;$&gt; p1 &lt;*&gt; p2 &lt;*&gt; ...</code>è¿›è¡Œå¤šå‚æ•°è°ƒç”¨äº†</p><p><strong>å†çœ‹ä¸‹<code>List</code>çš„<code>Applicative Functors</code>å®šä¹‰</strong></p><pre class="line-numbers language-haskell" data-language="haskell"><code class="language-haskell">instance Applicative [] where  
    pure x &#x3D; [x]  
    fs &lt;*&gt; xs &#x3D; [f x | f &lt;- fs, x &lt;- xs]<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><ul><li>ç¬¬ä¸€è¡Œè¿˜å¥½ç†è§£, æ”¶å…¥ä¸€ä¸ªæ™®é€šå…ƒç´ , è¿”å›å•å…ƒç´ <code>List</code></li><li>ç¬¬äºŒè¡Œè¯´<code>&lt;*&gt;</code>æ”¶å…¥ä¸¤ä¸ª<code>List</code>, ç”¨ç¬¬ä¸€ä¸ª<code>List</code>çš„æ¯ä¸ªå…ƒç´ æ‰§è¡Œç¬¬äºŒä¸ª<code>List</code></li><li>ğŸ˜’ä¸ºä»€ä¹ˆListçš„<code>&lt;*&gt;</code>æ˜¯è¿™æ ·å®šä¹‰çš„å‘¢, ä¸ºå•¥ä¸èƒ½åƒ<code>zipWith</code>ä¸€æ ·å·¥ä½œå‘¢? ğŸ˜±è¿™æ˜¯Haskellçš„Listçš„å®šä¹‰, ä¸è¦çº ç»“...</li></ul><p>ä¾‹å¦‚</p><pre class="line-numbers language-haskell" data-language="haskell"><code class="language-haskell">ghci&gt; [(*0),(+100),(^2)] &lt;*&gt; [1,2,3]  
-- [0,0,0,101,102,103,1,4,9]
ghci&gt; (++) &lt;$&gt; [&quot;ha&quot;,&quot;heh&quot;,&quot;hmm&quot;] &lt;*&gt; [&quot;?&quot;,&quot;!&quot;,&quot;.&quot;]  
-- [&quot;ha?&quot;,&quot;ha!&quot;,&quot;ha.&quot;,&quot;heh?&quot;,&quot;heh!&quot;,&quot;heh.&quot;,&quot;hmm?&quot;,&quot;hmm!&quot;,&quot;hmm.&quot;]
-- ç­‰ä»·äº
ghci&gt; [ x ++ y | x &lt;- [&quot;ha&quot;,&quot;heh&quot;,&quot;hmm&quot;], y &lt;- [&quot;?&quot;,&quot;!&quot;,&quot;.&quot;]]     
-- ç­‰ä»·äº
ghci&gt; [(++)] &lt;*&gt; [&quot;ha&quot;, &quot;heh&quot;, &quot;hmm&quot;] &lt;*&gt; [&quot;?&quot;, &quot;!&quot;, &quot;.&quot;]<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>çœ‹çœ‹<code>IO</code>çš„<code>Applicative Functors</code>å®šä¹‰</strong></p><pre class="line-numbers language-haskell" data-language="haskell"><code class="language-haskell">instance Applicative IO where  
    pure &#x3D; return  
    a &lt;*&gt; b &#x3D; do  
        f &lt;- a  
        x &lt;- b  
        return (f x)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>ä¾‹å¦‚</p><pre class="line-numbers language-haskell" data-language="haskell"><code class="language-haskell">main &#x3D; do  
    a &lt;- (++) &lt;$&gt; getLine &lt;*&gt; getLine  
    putStrLn $ &quot;The two lines concatenated turn out to be: &quot; ++ a<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p><strong>è¿˜æœ‰ä¸€ä¸ªæ¯”è¾ƒéš¾ç†è§£çš„<code>(-&gt;) r</code>çš„<code>Applicative Functors</code></strong></p><pre class="line-numbers language-haskell" data-language="haskell"><code class="language-haskell">instance Applicative ((-&gt;) r) where  
    pure x &#x3D; (\_ -&gt; x)  
    f &lt;*&gt; g &#x3D; \x -&gt; f x (g x)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p><code>(-&gt;) r</code>è¡¨ç¤ºä¸€ä¸ªæ¥æ”¶å‚æ•°ç±»å‹ä¸º<code>r</code>çš„å‡½æ•°, ä¾‹å¦‚</p><pre class="line-numbers language-haskell" data-language="haskell"><code class="language-haskell">ghci&gt; (\x y z -&gt; [x,y,z]) &lt;$&gt; (+3) &lt;*&gt; (*2) &lt;*&gt; (&#x2F;2) $ 5  
-- [8.0,10.0,2.5]<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p><strong>è¿˜æœ‰ç±»ä¼¼äº<code>Zip</code>çš„<code>List</code> <code>ZipList</code></strong></p><pre class="line-numbers language-haskell" data-language="haskell"><code class="language-haskell">instance Applicative ZipList where  
        pure x &#x3D; ZipList (repeat x)  
        ZipList fs &lt;*&gt; ZipList xs &#x3D; ZipList (zipWith (\f x -&gt; f x) fs xs)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>è¿™æ ·çš„æ“ä½œå¾ˆæ£’, <code>&lt;*&gt;</code>å…è®¸æˆ‘ä»¬åƒä½¿ç”¨<code>zipWith</code>ä¸€æ ·ä½¿ç”¨<code>&lt;*&gt; zipList</code></p><pre class="line-numbers language-haskell" data-language="haskell"><code class="language-haskell">ghci&gt; getZipList $ (+) &lt;$&gt; ZipList [1,2,3] &lt;*&gt; ZipList [100,100,100]  
-- [101,102,103]  
ghci&gt; getZipList $ (+) &lt;$&gt; ZipList [1,2,3] &lt;*&gt; ZipList [100,100..]  
-- [101,102,103]  (zipWithè¦æ±‚ç»“æœä»¥çŸ­Listä¸ºå‡†)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>âš–<strong>æœ€å: <code>Applicative Functors</code>çš„<code>fmap</code>å®ç°åº”è¯¥éµå¾ªå¦‚ä¸‹æ³•åˆ™</strong></p><ul><li>`pure f &lt;*&gt; x = fmap f x``</li><li>`pure id &lt;*&gt; v = v``</li><li>`pure (.) &lt;<em>&gt; u &lt;</em>&gt; v &lt;<em>&gt; w = u &lt;</em>&gt; (v &lt;*&gt; w)``</li><li>`pure f &lt;*&gt; pure x = pure (f x)``</li><li><code>u &lt;*&gt; pure y = pure ($ y) &lt;*&gt; u</code></li></ul><h4 id="newtype">newtype</h4><p>å¯ä»¥é€šè¿‡<code>data</code>å£°æ˜ä¸€ä¸ª<code>Type</code>, ç„¶è€Œ, å¦‚æœæˆ‘ä»¬çš„<code>Type</code>ä¸­åªæœ‰<strong>ä¸€ä¸ªå€¼æ„é€ å­, å€¼æ„é€ å­åªæœ‰ä¸€ä¸ªå­—æ®µ</strong>, æˆ‘ä»¬å¯ä»¥ä½¿ç”¨<code>newtype</code>å®šä¹‰</p><pre class="line-numbers language-haskell" data-language="haskell"><code class="language-haskell">data ZipList a &#x3D; ZipList &#123; getZipList :: [a] &#125;
-- ç­‰ä»·äº
newtype ZipList a &#x3D; ZipList &#123; getZipList :: [a] &#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>ä¼˜ç‚¹æœ‰</p><ul><li>ğŸƒâ€â™‚ï¸<code>newtype</code>æ¯”è¾ƒå¿«, Haskellä¼šå°†<code>newtype</code>ç†è§£ä¸ºç°æœ‰ç±»å‹çš„äºŒæ¬¡åŒ…è£…, åœ¨è°ƒç”¨çš„æ—¶å€™åªéœ€è¦è§£åŒ…å³å¯, æ— éœ€å…³å¿ƒå€¼åˆ°åº•åŒ¹é…åˆ°äº†å“ªä¸ªå€¼æ„é€ å­</li><li>ğŸ˜´<code>newtype</code>æ˜¯æƒ°æ€§çš„, ç±»å‹åªæœ‰åœ¨éœ€è¦çš„æ—¶å€™æ‰ä¼šè§£åŒ…, ç„¶åè®¡ç®—</li></ul><h4 id="monoids">Monoids</h4><p><code>Monoids</code>çš„æ„æ€æ˜¯ä¸­è¯‘æ˜¯å¹ºåŠç¾¤, ç›¸å…³æ•°å­¦å®šä¹‰å¦‚ä¸‹</p><ul><li><p><span class="math inline">\(G\)</span>ä¸ºéç©ºé›†åˆï¼Œå¦‚æœåœ¨<span class="math inline">\(G\)</span>ä¸Šå®šä¹‰çš„äºŒå…ƒè¿ç®— <em>ï¼Œæ»¡è¶³</em></p><ul><li>å°é—­æ€§: å¯¹äºä»»æ„<span class="math inline">\(a, b \in G\)</span>, æœ‰<span class="math inline">\(a * b \in G\)</span></li><li>ç»“åˆå¾‹: å¯¹äºä»»æ„<span class="math inline">\(a, b, c \in G\)</span>, æœ‰<span class="math inline">\((a*b)*c=a*(b*c)\)</span></li><li>å¹ºå…ƒ: å­˜åœ¨å¹ºå…ƒ<span class="math inline">\(e\)</span>, ä½¿å¾—å¯¹äºä»»æ„<span class="math inline">\(a\in G\)</span>, <span class="math inline">\(e*a=a*e=a\)</span></li><li>é€†å…ƒ: å¯¹äºä»»æ„<span class="math inline">\(a\in G\)</span>ï¼Œå­˜åœ¨é€†å…ƒ<span class="math inline">\(a^{-1}\)</span>ï¼Œä½¿å¾—<span class="math inline">\(a^{-1}*a=a*a^{-1}=e\)</span></li></ul><p>åˆ™ç§°<span class="math inline">\((G, *)\)</span>æ˜¯ç¾¤ï¼Œç®€ç§°<span class="math inline">\(G\)</span>æ˜¯ç¾¤</p></li><li><p>å¦‚æœä»…æ»¡è¶³å°é—­æ€§å’Œç»“åˆå¾‹, åˆ™ç§°<span class="math inline">\(G\)</span>æ˜¯ä¸€ä¸ªåŠç¾¤</p></li><li><p>å¦‚æœä»…æ»¡è¶³å°é—­æ€§, ç»“åˆå¾‹å¹¶ä¸”æœ‰å¹ºå…ƒ, åˆ™ç§°Gæ˜¯ä¸€ä¸ªå«å¹ºåŠç¾¤</p></li></ul><p>å†çœ‹ä¸‹<code>Monoid</code>åœ¨Haskellä¸­çš„å®šä¹‰</p><pre class="line-numbers language-haskell" data-language="haskell"><code class="language-haskell">class Monoid m where  
    mempty :: m              -- å¸¸æ•°, è¡¨ç¤ºå¹ºå…ƒ
    mappend :: m -&gt; m -&gt; m   -- å‡½æ•°, è¡¨ç¤ºå¹ºåŠç¾¤ä¸­çš„äºŒå…ƒè¿ç®—å‡½æ•°
    mconcat :: [m] -&gt; m      -- å‡½æ•°, å°†ä¸€å †Monoid&quot;å‹ç¼©&quot;ä¸ºä¸€ä¸ª
    mconcat &#x3D; foldr &#96;mappend&#96; mempty -- ç¼ºçœå®ç°, ä½¿ç”¨å¹ºå…ƒä½œä¸ºèµ·å§‹, ä½¿ç”¨äºŒå…ƒè¿ç®—åˆå¹¶<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>å…¶ä¸­äºŒå…ƒè¿ç®—éœ€è¦æ»¡è¶³å¹ºå…ƒä¸ç»“åˆå¾‹, å³</p><ul><li><code>mempty `mappend` x = x</code></li><li><code>x `mappend` mempty = x</code></li><li><code>(x `mappend` y) `mappend` z = x `mappend` (y `mappend` z)</code></li></ul><p><strong>çœ‹çœ‹ç†Ÿæ‚‰ç±»å‹çš„<code>Monoids</code>æ˜¯å¦‚ä½•å®šä¹‰äºŒå…ƒè¿ç®—ä¸å¹ºå…ƒçš„</strong></p><ul><li><p><code>List</code></p><pre class="line-numbers language-haskell" data-language="haskell"><code class="language-haskell">instance Monoid [a] where  
    mempty &#x3D; []  
    mappend &#x3D; (++)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><ul><li>å¹ºå…ƒä¸º<code>[]</code></li><li>äºŒå…ƒè¿ç®—ä¸º<code>++</code></li></ul><p>ä¾‹å¦‚</p><pre class="line-numbers language-haskell" data-language="haskell"><code class="language-haskell">ghci&gt; [1,2,3] &#96;mappend&#96; [4,5,6]  
-- [1,2,3,4,5,6]  
ghci&gt; (&quot;one&quot; &#96;mappend&#96; &quot;two&quot;) &#96;mappend&#96; &quot;tree&quot;  
-- &quot;onetwotree&quot;  
ghci&gt; &quot;one&quot; &#96;mappend&#96; (&quot;two&quot; &#96;mappend&#96; &quot;tree&quot;)  
-- &quot;onetwotree&quot;  
ghci&gt; &quot;one&quot; &#96;mappend&#96; &quot;two&quot; &#96;mappend&#96; &quot;tree&quot;  
-- &quot;onetwotree&quot;  
ghci&gt; &quot;pang&quot; &#96;mappend&#96; mempty  
-- &quot;pang&quot;  
ghci&gt; mconcat [[1,2],[3,6],[9]]  
-- [1,2,3,6,9]  
ghci&gt; mempty :: [a]  
-- []<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li><li><p>æ•°é›†ä¸Šçš„<code>*</code>ä¸<code>+</code></p><p>Haskellå®šä¹‰äº†<code>Sum</code>ä¸<code>Product</code></p><ul><li>å¹ºå…ƒåˆ†åˆ«ä¸º<code>0</code>, <code>1</code></li><li>äºŒå…ƒè¿ç®—åˆ†åˆ«ä¸º<code>+</code>, <code>*</code></li></ul><pre class="line-numbers language-haskell" data-language="haskell"><code class="language-haskell">newtype Product a &#x3D;  Product &#123; getProduct :: a &#125;  
    deriving (Eq, Ord, Read, Show, Bounded)

instance Num a &#x3D;&gt; Monoid (Product a) where  
    mempty &#x3D; Product 1  
    Product x &#96;mappend&#96; Product y &#x3D; Product (x * y)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>ä¾‹å¦‚</p><pre class="line-numbers language-haskell" data-language="haskell"><code class="language-haskell">ghci&gt; getProduct $ Product 3 &#96;mappend&#96; Product 9  
-- 27  
ghci&gt; getProduct $ Product 3 &#96;mappend&#96; mempty  
-- 3  
ghci&gt; getProduct $ Product 3 &#96;mappend&#96; Product 4 &#96;mappend&#96; Product 2  
-- 24  
ghci&gt; getProduct . mconcat . map Product $ [3,4,2]  
-- 24<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li><li><p><code>Any</code>ä¸<code>All</code></p><p>ç±»ä¼¼äºæ•°å­¦ä¸­çš„å­˜åœ¨ä¸ä»»æ„</p><ul><li>å¹ºå…ƒåˆ†åˆ«ä¸º<code>false</code>, <code>true</code></li><li>äºŒå…ƒè¿ç®—åˆ†åˆ«ä¸º<code>||</code>, <code>&amp;&amp;</code></li></ul><pre class="line-numbers language-haskell" data-language="haskell"><code class="language-haskell">newtype Any &#x3D; Any &#123; getAny :: Bool &#125;  
    deriving (Eq, Ord, Read, Show, Bounded)
    
instance Monoid Any where  
    mempty &#x3D; Any False  
    Any x &#96;mappend&#96; Any y &#x3D; Any (x || y)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-haskell" data-language="haskell"><code class="language-haskell">newtype All &#x3D; All &#123; getAll :: Bool &#125;  
        deriving (Eq, Ord, Read, Show, Bounded)

instance Monoid All where  
        mempty &#x3D; All True  
        All x &#96;mappend&#96; All y &#x3D; All (x &amp;&amp; y)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>ä¾‹å¦‚</p><pre class="line-numbers language-haskell" data-language="haskell"><code class="language-haskell">ghci&gt; getAny $ Any True &#96;mappend&#96; Any False  
-- True  
ghci&gt; getAny $ mempty &#96;mappend&#96; Any True  
-- True  
ghci&gt; getAny . mconcat . map Any $ [False, False, False, True]  
-- True  
ghci&gt; getAny $ mempty &#96;mappend&#96; mempty  
-- False
ghci&gt; getAll $ mempty &#96;mappend&#96; All True  
-- True  
ghci&gt; getAll $ mempty &#96;mappend&#96; All False  
-- False  
ghci&gt; getAll . mconcat . map All $ [True, True, True]  
-- True  
ghci&gt; getAll . mconcat . map All $ [True, True, False]  
-- False<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li><li><p><code>Maybe</code></p><ul><li>å¹ºå…ƒä¸º<code>Nothing</code></li><li>äºŒå…ƒè¿ç®—è§ä¸‹</li></ul><pre class="line-numbers language-haskell" data-language="haskell"><code class="language-haskell">instance Monoid a &#x3D;&gt; Monoid (Maybe a) where  
    mempty &#x3D; Nothing  
    Nothing &#96;mappend&#96; m &#x3D; m  
    m &#96;mappend&#96; Nothing &#x3D; m  
    Just m1 &#96;mappend&#96; Just m2 &#x3D; Just (m1 &#96;mappend&#96; m2)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>ä¾‹å¦‚</p><pre class="line-numbers language-haskell" data-language="haskell"><code class="language-haskell">ghci&gt; Nothing &#96;mappend&#96; Just &quot;andy&quot;  
-- Just &quot;andy&quot;  
ghci&gt; Just LT &#96;mappend&#96; Nothing  
-- Just LT  
ghci&gt; Just (Sum 3) &#96;mappend&#96; Just (Sum 4)  
-- Just (Sum &#123;getSum &#x3D; 7&#125;)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li></ul><p><strong>çœ‹çœ‹<code>Monoids</code>ä¸­çš„<code>mconcat</code>æœ‰ä»€ä¹ˆç”¨</strong></p><p>ä¸<code>fmap</code>ç±»ä¼¼çš„ä½¿ç”¨æ–¹å¼, å…¶ä½¿ç”¨<code>fold*</code>è°ƒç”¨, åªä¸è¿‡è¿™ä¸ª<code>fold*</code>å¹¶éprecludeçš„<code>List.fold*</code>, éœ€è¦æ‰‹åŠ¨å¼•å…¥</p><pre class="line-numbers language-haskell" data-language="haskell"><code class="language-haskell">import qualified Foldable as F

ghci&gt; :t F.foldr  
-- F.foldr :: (F.Foldable t) &#x3D;&gt; (a -&gt; b -&gt; b) -&gt; b -&gt; t a -&gt; b<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>ä¾‹å¦‚<code>Maybe</code>çš„<code>fold*</code></p><pre class="line-numbers language-haskell" data-language="haskell"><code class="language-haskell">ghci&gt; F.foldl (+) 2 (Just 9)  
-- 11  
ghci&gt; F.foldr (||) False (Just True)  
-- True<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>âš–<strong>æœ€å: <code>Monad</code>å®ç°åº”è¯¥éµå¾ªå¦‚ä¸‹æ³•åˆ™</strong></p><ul><li><code>retrun x &gt;&gt;= f</code>åº”è¯¥ç­‰äº <code>f x</code></li><li><code>m &gt;&gt;= return</code> ä¼šç­‰äº <code>m</code></li><li><code>(m &gt;&gt;= f) &gt;&gt;= g</code> è·Ÿ <code>m &gt;&gt;= (\x -&gt; f x &gt;&gt;= g)</code> æ˜¯ç›¸ç­‰çš„</li></ul><h3 id="monadåº”ç”¨">Monadåº”ç”¨</h3><p><code>Monad</code>å°è£…äº†é«˜é˜¶å¯¹è±¡ä¹‹é—´çš„è®¡ç®—ä¸è½¬æ¢æ–¹å¼, ä»è€Œä½¿é«˜é˜¶å¯¹è±¡å¯ä»¥è¢«è½»æ˜“çš„ç”¨æœ´ç´ çš„æ–¹æ³•æ“ä½œ</p><h4 id="monadä¸Šçš„æ–¹æ³•"><code>Monad</code>ä¸Šçš„æ–¹æ³•</h4><pre class="line-numbers language-haskell" data-language="haskell"><code class="language-haskell">class Monad m where  
    return :: a -&gt; m a  

    (&gt;&gt;&#x3D;) :: m a -&gt; (a -&gt; m b) -&gt; m b  

    (&gt;&gt;) :: m a -&gt; m b -&gt; m b  
    x &gt;&gt; y &#x3D; x &gt;&gt;&#x3D; \_ -&gt; y  

    fail :: String -&gt; m a  
    fail msg &#x3D; error msg<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li><code>return</code>ä¸<code>Applicative</code>ä¸­çš„<code>pure</code>ç±»ä¼¼</li><li><code>&gt;&gt;=</code>å‡½æ•°,æ¥å—ä¸€ä¸ª<code>Monad</code>ä¸ä¸€ä¸ªæ™®é€šå€¼åˆ°<code>Monad</code>çš„å‡½æ•°, è¿”å›ä¸€ä¸ª<code>Monad</code></li><li><code>&gt;&gt;</code>å‡½æ•°æ¥å—ä¸¤ä¸ª<code>Monad</code>, è¿”å›åè€…</li><li><code>fail</code>æ¥å—ä¸€ä¸ª<code>String</code>, æŠ›å‡ºä¸€ä¸ªå¼‚å¸¸</li></ul><p>çœ‹çœ‹<code>Maybe</code>çš„<code>Monad</code>å®ç°</p><pre class="line-numbers language-haskell" data-language="haskell"><code class="language-haskell">instance Monad Maybe where  
    return x &#x3D; Just x  
    Nothing &gt;&gt;&#x3D; f &#x3D; Nothing  
    Just x &gt;&gt;&#x3D; f  &#x3D; f x  
    fail _ &#x3D; Nothing<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="ç»´æŠ¤ä¸¤ä¸ªæ•°">ç»´æŠ¤ä¸¤ä¸ªæ•°</h4><p>æ†å­ä¸¤ç«¯æœ‰è‹¥å¹²åªé¸ŸğŸ¦, å½“å·¦å³ä¸¤ç«¯é¸Ÿæ•°å·®å°äºç­‰äº2æ—¶, æ†å­å¹³è¡¡, å¦åˆ™æ†å­å¤±è¡¡. ç»™è‹¥å¹²åŠ å‡é¸Ÿçš„æ“ä½œ, è¿”å›æ†å­çŠ¶æ€</p><p>æˆ‘ä»¬å¯ä»¥ç”¨<code>Maybe</code>çš„<code>Just</code>è¡¨ç¤ºå¹³è¡¡çŠ¶æ€, ç”¨<code>Nothing</code>è¡¨ç¤ºå¤±è¡¡</p><pre class="line-numbers language-haskell" data-language="haskell"><code class="language-haskell">type Birds &#x3D; Int  
type Pole &#x3D; (Birds,Birds)

landLeft :: Birds -&gt; Pole -&gt; Maybe Pole  
landLeft n (left,right)  
    | abs ((left + n) - right) &lt; 4 &#x3D; Just (left + n, right)  
    | otherwise                    &#x3D; Nothing  

landRight :: Birds -&gt; Pole -&gt; Maybe Pole  
landRight n (left,right)  
    | abs (left - (right + n)) &lt; 4 &#x3D; Just (left, right + n)  
    | otherwise                    &#x3D; Nothing<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>å¯ä»¥ä½¿ç”¨<code>&gt;&gt;=</code>è¿ç»­è°ƒç”¨å‡½æ•°â›“</p><pre class="line-numbers language-haskell" data-language="haskell"><code class="language-haskell">ghci&gt; return (0,0) &gt;&gt;&#x3D; landRight 2 &gt;&gt;&#x3D; landLeft 2 &gt;&gt;&#x3D; landRight 2  
-- Just (2,4)
ghci&gt; return (0,0) &gt;&gt;&#x3D; landLeft 1 &gt;&gt;&#x3D; landRight 4 &gt;&gt;&#x3D; landLeft (-1) &gt;&gt;&#x3D; landRight (-2)  
-- Nothing<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>å¯ä»¥ä½¿ç”¨<code>&gt;&gt;</code>ç›´æ¥è®¾ç½®çŠ¶æ€</p><pre class="line-numbers language-haskell" data-language="haskell"><code class="language-haskell">ghci&gt; return (0,0) &gt;&gt;&#x3D; landLeft 1 &gt;&gt; Nothing &gt;&gt;&#x3D; landRight 1  
-- Nothing<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p><strong>çœ‹æ¥<code>(&gt;&gt;=)</code>å¯ä»¥æ–¹ä¾¿çš„å®ç°ä¸€ä¸ª<code>Monad</code>è¢«å¤šä¸ªå‡½æ•°è°ƒç”¨, è€Œ<code>&lt;$&gt; ... &lt;*&gt;</code>å¯ä»¥å®ç°ä¸€ä¸ªå‡½æ•°è°ƒç”¨å¤šä¸ªå‚æ•°</strong></p><h4 id="doè¡¨ç¤ºæ³•"><code>do</code>è¡¨ç¤ºæ³•</h4><p>å¯ä»¥å°†<code>&gt;&gt;=</code>è¡¨è¾¾å¼é“¾</p><pre class="line-numbers language-haskell" data-language="haskell"><code class="language-haskell">foo :: Maybe String  
foo &#x3D; Just 3   &gt;&gt;&#x3D; (\x -&gt; 
      Just &quot;!&quot; &gt;&gt;&#x3D; (\y -&gt; 
      Just (show x ++ y)))<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>ç”¨<code>do</code>è¯­å¥è¡¨ç¤º</p><pre class="line-numbers language-haskell" data-language="haskell"><code class="language-haskell">foo :: Maybe String  
foo &#x3D; do  
    x &lt;- Just 3  
    y &lt;- Just &quot;!&quot;  
    Just (show x ++ y)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>çœ‹èµ·æ¥<code>do</code>å°±åƒæ˜¯å‘½ä»¤å¼å˜æˆçš„ä¸€ä¸ª<code>Block</code>, å…è®¸ç”¨æˆ·å­˜ä¸€äº›å˜é‡è¿›å», å†è¿”å›ç»“æœ, è¿™é‡Œä¹Ÿè¦é‡‡ç”¨<code>&lt;-</code>å°†å€¼ä»é«˜é˜¶å¯¹è±¡ä¸­å–å‡º</p><p>çš„ä½†æ˜¯è¿™ä¸ªå°±æ¯”è¾ƒç¦»è°±</p><pre class="line-numbers language-haskell" data-language="haskell"><code class="language-haskell">routine :: Maybe Pole
routine &#x3D; do
  start &lt;- return (0, 0)
  first &lt;- landLeft 2 start
  Nothing
  second &lt;- landRight 2 first
  final &lt;- landLeft 1 second
  return final<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>ä¸è®º<code>return final</code>è¿˜æ˜¯<code>start</code>, <code>first</code>, <code>second</code>éƒ½æ˜¯<code>Nothing</code>...</p><p>å½“æˆ‘ä»¬åœ¨ <code>do</code> è¡¨ç¤ºæ³•å†™äº†ä¸€è¡Œè¿ç®—ï¼Œä½†æ²¡æœ‰ç”¨åˆ° <code>&lt;-</code> æ¥ç»‘å®šå€¼çš„è¯ï¼Œå…¶å®å®é™…ä¸Šå°±æ˜¯ç”¨äº† <code>&gt;&gt;</code>, ç›¸å½“äºè®¾ç½®äº†çŠ¶æ€, ä¸æ˜¯å¾ˆç†è§£</p><pre class="line-numbers language-haskell" data-language="haskell"><code class="language-haskell">routine :: [Int]
routine &#x3D; do
  start &lt;- return 1
  []
  return (start + 1)

-- []<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-haskell" data-language="haskell"><code class="language-haskell">routine :: Maybe [Int]
routine &#x3D; do
  start &lt;- return [1]
  Just [1,2,3,4,5,6]
  return (999:start)
  
-- Just [999,1]<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-haskell" data-language="haskell"><code class="language-haskell">main &#x3D; do
  start &lt;- getLine
  first &lt;- getLine
  return &quot;opps&quot;
  second &lt;- getLine
  print start

-- 1\n2\n3\n
-- 1<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="listçš„monadå®šä¹‰"><code>List</code>çš„<code>Monad</code>å®šä¹‰</h4><pre class="line-numbers language-haskell" data-language="haskell"><code class="language-haskell">instance Monad [] where  
    return x &#x3D; [x]  
    xs &gt;&gt;&#x3D; f &#x3D; concat (map f xs)  
    fail _ &#x3D; []<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>ä¸<code>Applicative</code>æœ‰äº›åŒºåˆ«, ä¾‹å¦‚</p><pre class="line-numbers language-haskell" data-language="haskell"><code class="language-haskell">ghci&gt; (*) &lt;$&gt; [1,2,3] &lt;*&gt; [10,100,1000]  
-- [10,100,1000,20,200,2000,30,300,3000]
ghci&gt; [3,4,5] &gt;&gt;&#x3D; \x -&gt; [x,-x]  
-- [3,-3,4,-4,5,-5]<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><h4 id="éšæœºæ•°">éšæœºæ•°</h4><p>åœ¨å‘½ä»¤å¼ç¼–ç¨‹ä¸­å¯ä»¥å€ŸåŠ©<code>random</code>ç±»ä¼¼çš„å‡½æ•°è½»æ¾å®ç°éšæœºæ•°. ç„¶è€ŒHaskellä¸­å‡½æ•°éƒ½æ˜¯çº¯å‡½æ•°, è¿™æ„å‘³ç€æ¯æ¬¡<code>random</code>çš„ç»“æœéƒ½åº”è¯¥æ˜¯å®šå€¼ğŸ˜°, ä¸ºäº†è§£å†³è¿™ä¸€é—®é¢˜, Haskellå°†<code>random</code>å®šä¹‰ä¸ºäº†ä¸€ä¸ªç‰¹åˆ«çš„ç±»å‹</p><pre class="line-numbers language-haskell" data-language="haskell"><code class="language-haskell">random :: (RandomGen g, Random a) &#x3D;&gt; g -&gt; (a, g)<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>æˆ‘ä»¬éœ€è¦ä¼ å…¥ä¸€ä¸ª<code>RandomGen</code>ç„¶åè·å¾—ä¸€ä¸ªéšæœºæ•°<code>a</code>ä¸ä¸€ä¸ª<code>RandomGen</code>. <code>RandomGen</code>åƒæ˜¯ä¸€ä¸ªç”Ÿæˆå™¨ğŸ§«, é€šè¿‡åŒä¸€ä¸ªç”Ÿæˆå™¨è°ƒç”¨<code>random</code>å¯ä»¥å¾—åˆ°ç›¸åŒçš„ç»“æœ. æ¯æ¬¡<code>random</code>åæˆ‘ä»¬å¯ä»¥è·å¾—ä¸€ä¸ªå…¨æ–°çš„<code>RandomGen</code>ç”¨äºä¸‹æ¬¡<code>random</code>. å¯ä»¥åˆ©ç”¨<code>mkStdGen</code>ç”Ÿæˆä¸€ä¸ª<code>RandomGen</code></p><pre class="line-numbers language-haskell" data-language="haskell"><code class="language-haskell">mkStdGen :: Int -&gt; StdGen
ghci&gt; random (mkStdGen 100)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>äºæ˜¯æˆ‘ä»¬å¯ä»¥ç”Ÿæˆä¸€äº›ä¸åŒç±»å‹çš„<code>random</code></p><pre class="line-numbers language-haskell" data-language="haskell"><code class="language-haskell">ghci&gt; random (mkStdGen 949488) :: (Float, StdGen)
-- (0.8938442,1597344447 1655838864)
ghci&gt; random (mkStdGen 949488) :: (Bool, StdGen)
-- (False,1485632275 40692)
ghci&gt; random (mkStdGen 949488) :: (Integer, StdGen)
-- (1691547873,1597344447 1655838864)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>ğŸª™ç”Ÿæˆä¸‰æ¬¡æŠ•ç¡¬å¸çš„ç»“æœ</p><pre class="line-numbers language-haskell" data-language="haskell"><code class="language-haskell">threeCoins :: StdGen -&gt; (Bool, Bool, Bool)
threeCoins gen &#x3D;
    let (firstCoin, newGen) &#x3D; random gen
    (secondCoin, newGen&#39;) &#x3D; random newGen
    (thirdCoin, newGen&#39;&#39;) &#x3D; random newGen&#39;
    in  (firstCoin, secondCoin, thirdCoin)
    

ghci&gt; threeCoins (mkStdGen 21)
-- (True,True,True)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>Haskellè¿˜æä¾›<code>randomR</code>å®šä¹‰éšæœºæ•°ä¸Šä¸‹ç•Œ</p><pre class="line-numbers language-haskell" data-language="haskell"><code class="language-haskell">ghci&gt; randomR (1,6) (mkStdGen 359353)
-- (6,1494289578 40692)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>ä¹Ÿæä¾›äº†ç”Ÿæˆæ— é™ä¸ªæœ‰é™éšæœºæ•°çš„<code>randomRs</code></p><pre class="line-numbers language-haskell" data-language="haskell"><code class="language-haskell">ghci&gt; take 10 $ randomRs (&#39;a&#39;,&#39;z&#39;) (mkStdGen 3) :: [Char]
-- &quot;ndkxbvmomg&quot;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><h4 id="bytestring">ByteString</h4><p>åœ¨è¯»å–å¤§æ–‡ä»¶çš„æ—¶å€™<code>[Char]</code>çš„æ•ˆç‡å¾€å¾€å¾ˆä½, å¯ä»¥ä½¿ç”¨ByteString, å…¶æ¯ä¸ªå…ƒç´ éƒ½æ˜¯ä¸€ä¸ª<code>Byte</code>. å­˜åœ¨ä¸¤ä¸ª<code>ByteString</code></p><ul><li><code>strict</code>å‹: ä½äº<code>Data.ByteString</code>, éæƒ°æ€§, æ— <code>Thunk</code>, ä¿è¯äº†ä¸ä¼šå‡ºç°"over head"</li><li><code>Lazy</code>å‹: ä½äº<code>Data.ByteString.Lazy</code>, ä¿å­˜åœ¨64Kçš„chunksä¸­(è¿™ä¼¼çš„å…¶å¤§æ¦‚ç‡å¯ä»¥è¢«è£…å…¥L2 Cache)</li></ul><p>å…¶å®šä¹‰äº†æ–¹æ³•</p><ul><li><p><code>pack :: [Word8] -&gt; ByteString</code></p><p>æ¥å—ä¸€ä¸ª<code>Word8</code>æ•°ç»„, è¿”å›<code>ByteString</code>, å…¶ä¸­<code>Word8</code>å°±æ˜¯<code>0-255</code>çš„<code>Int</code></p><pre class="line-numbers language-haskell" data-language="haskell"><code class="language-haskell">import qualified Data.ByteString.Lazy as B
import qualified Data.ByteString as S

ghci&gt; B.pack [99,97,110]
-- Chunk &quot;can&quot; Empty
ghci&gt; B.pack [98..120]
-- Chunk &quot;bcdefghijklmnopqrstuvwx&quot; Empty<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li><li><p><code>unpack</code>ä¸<code>pack</code>ç›¸å, æŠŠä¸€ä¸ª<code>bytestring</code>å˜æˆä¸€ä¸ª<code>byte list</code></p></li><li><p><code>fromChunks</code>æ¥å—ä¸€ä¸²<code>strict</code>çš„<code>bytestrings</code>å¹¶æŠŠä»–å˜æˆä¸€ä¸²<code>lazy bytestring</code></p></li><li><p><code>toChunks</code>æ¥å—ä¸€ä¸ª<code>lazy bytestrings</code>å¹¶å°†ä»–å˜æˆä¸€ä¸²<code>strict bytestrings</code></p></li><li><p><code>ByteString</code>ä¹Ÿæ”¯æŒ<code>:</code>, å…¶ä¸­<code>B.empty</code>ç›¸å½“äº<code>[]</code></p></li></ul><h4 id="write-monad"><code>Write Monad</code></h4><p>âœï¸æˆ‘ä»¬å¸Œæœ›ç»´æŠ¤ä¸€ä¸ªçŠ¶æ€, å¹¶åœ¨æ¯æ¬¡applyå‡½æ•°çš„æ—¶å€™ä¸ºå…¶åŠ ä¸Šæ—¥å¿—, æ­¤æ—¶å°±å¯ä»¥ä½¿ç”¨<code>Write Monad</code></p><pre class="line-numbers language-haskell" data-language="haskell"><code class="language-haskell">instance (Monoid w) &#x3D;&gt; Monad (Writer w) where  
    return x &#x3D; Writer (x, mempty)  
    (Writer (x,v)) &gt;&gt;&#x3D; f &#x3D; let (Writer (y, v&#39;)) &#x3D; f x in Writer (y, v &#96;mappend&#96; v&#39;)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>ä¾‹å¦‚</p><pre class="line-numbers language-haskell" data-language="haskell"><code class="language-haskell">import Control.Monad.Writer  

newtype Writer w a &#x3D; Writer &#123; runWriter :: (a, w) &#125;

logNumber :: Int -&gt; Writer [String] Int  
logNumber x &#x3D; Writer (x, [&quot;Got number: &quot; ++ show x])  

multWithLog :: Writer [String] Int  
multWithLog &#x3D; do  
    a &lt;- logNumber 3  
    b &lt;- logNumber 5  
    return (a*b)
    
-- ghci&gt; runWriter multWithLog  
-- (15,[&quot;Got number: 3&quot;,&quot;Got number: 5&quot;])<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>å¯ä»¥ä½¿ç”¨difference-listsæé«˜å†™logçš„æ•ˆç‡</strong></p><p>ç®€å•ç†è§£æˆ‘ä»¬ä¹‹å‰ä½¿ç”¨çš„Liståœ¨æ‰§è¡Œ<code>[1,2]++[3,4]</code>æ—¶æ˜¯åŒæ­¥çš„, ä½†æ˜¯<code>DiffList</code>åœ¨æ‰§è¡Œçš„æ—¶å€™æ˜¯æƒ°æ€§çš„, è¿™ä¿è¯äº†å¯ä»¥å¿«é€Ÿ<code>++</code>, åªæœ‰åœ¨è¯»å–æ—¶æ‰æ‰§è¡Œ, å®ç°ä¹Ÿå¾ˆç®€å•</p><pre class="line-numbers language-haskell" data-language="haskell"><code class="language-haskell">instance Monoid (DiffList a) where  
    mempty &#x3D; DiffList (\xs -&gt; [] ++ xs)  
    (DiffList f) &#96;mappend&#96; (DiffList g) &#x3D; DiffList (\xs -&gt; f (g xs))<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><h4 id="reader-monad"><code>Reader Monad</code></h4><p><code>Reader Monad</code>æ˜¯å°†ä¸€ä¸ªæŸ¯é‡ŒåŒ–å‡½æ•°ä½œä¸º<code>Monad</code>å¯¹è±¡</p><pre class="line-numbers language-haskell" data-language="haskell"><code class="language-haskell">instance Monad ((-&gt;) r) where  
    return x &#x3D; \_ -&gt; x  
    h &gt;&gt;&#x3D; f &#x3D; \w -&gt; f (h w) w<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><h4 id="state-monad"><code>State Monad</code></h4><p><code>State Monad</code>ç”¨äºå®ç°çŠ¶æ€è½¬æ¢, ä»–ä¿å­˜äº†è®¡ç®—ç»“æœä¸ä¸‹ä¸€æ¬¡æ‰§è¡Œçš„state, ä¾‹å¦‚ä¹‹å‰éšæœºæ•°å°±ç”¨åˆ°äº†<code>State Monad</code></p><pre class="line-numbers language-haskell" data-language="haskell"><code class="language-haskell">instance Monad (State s) where  
    return x &#x3D; State $ \s -&gt; (x,s)  
    (State h) &gt;&gt;&#x3D; f &#x3D; State $ \s -&gt; let (a, newState) &#x3D; h s  
                                        (State g) &#x3D; f a  
                                    in  g newState<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="error-monad"><code>Error Monad</code></h4><p>å°±æ˜¯<code>Either</code>çš„<code>Monad</code>å®ç°. ç›¸æ¯”<code>Maybe</code>ä»–å¯ä»¥è®°å½•é”™è¯¯ä¿¡æ¯</p><pre class="line-numbers language-haskell" data-language="haskell"><code class="language-haskell">instance (Error e) &#x3D;&gt; Monad (Either e) where  
    return x &#x3D; Right x   
    Right x &gt;&gt;&#x3D; f &#x3D; f x  
    Left err &gt;&gt;&#x3D; f &#x3D; Left err  
    fail msg &#x3D; Left (strMsg msg)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="å…¶ä»–monadæ–¹æ³•">å…¶ä»–<code>Monad</code>æ–¹æ³•</h4><ul><li><p><code>leftM</code>ç›¸å½“äº<code>functor</code>çš„<code>fmap</code></p><pre class="line-numbers language-haskell" data-language="haskell"><code class="language-haskell">liftM :: (Monad m) &#x3D;&gt; (a -&gt; b) -&gt; m a -&gt; m b<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></li><li><p><code>join</code>ç›¸å½“äºå»æ‰ä¸€å±‚åŒ…è£¹</p><pre class="line-numbers language-haskell" data-language="haskell"><code class="language-haskell">join :: (Monad m) &#x3D;&gt; m (m a) -&gt; m a<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><pre class="line-numbers language-haskell" data-language="haskell"><code class="language-haskell">ghci&gt; join (Just (Just 9))  
Just 9  
ghci&gt; join (Just Nothing)  
Nothing  
ghci&gt; join Nothing  
Nothing<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li><li><p><code>filterM</code>å°†ä¸€ä¸ª<code>List</code>è½¬æ¢ä¸ºåˆæ³•çš„<code>Monad List</code></p><pre class="line-numbers language-haskell" data-language="haskell"><code class="language-haskell">filterM :: (Monad m) &#x3D;&gt; (a -&gt; m Bool) -&gt; [a] -&gt; m [a]<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></li><li><p><code>foldM</code>æŠ˜å ä¸€ä¸ª<code>List</code>å¹¶è½¬ä¸º<code>Monad</code></p><pre class="line-numbers language-haskell" data-language="haskell"><code class="language-haskell">foldM :: (Monad m) &#x3D;&gt; (a -&gt; b -&gt; m a) -&gt; a -&gt; [b] -&gt; m a<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>ä¾‹å¦‚</p><pre class="line-numbers language-haskell" data-language="haskell"><code class="language-haskell">ghci&gt; foldl (\acc x -&gt; acc + x) 0 [2,8,3,1]  
-- 14<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre></li></ul><h3 id="ç”¨zippersä¿å­˜çŠ¶æ€">ç”¨Zippersä¿å­˜çŠ¶æ€</h3><p>Haskellçš„å‡½æ•°æ˜¯çº¯å‡½æ•°å¼, è¿™æ„å‘³ç€å¯¹å‡½æ•°ä¼ å…¥ç›¸åŒçš„å˜é‡, å‡½æ•°ä¼šæœ‰ç›¸åŒçš„è¾“å‡º, ä½†æ˜¯æœ‰äº›æ—¶å€™æˆ‘ä»¬ä¹Ÿéœ€è¦è®°å½•æ‰§è¡Œçš„çŠ¶æ€ğŸ“¹(ä¾‹å¦‚éœ€è¦ç»´æŠ¤ä¸€ä¸ªæ ‘, ç„¶è€Œå½“æˆ‘é”å®šå¹¶ä¿®æ”¹å­æ ‘åHaskellåªèƒ½è¿”å›ä¸€ä¸ªæ–°å­æ ‘, ä¸èƒ½ä¿®æ”¹åŸæ ‘), è¿™æ—¶å¯ä»¥å®šä¹‰ä¸€ä¸ª<code>Zippers</code>æ•°æ®ç»“æ„ä¿å­˜çŠ¶æ€ğŸ¤</p><h4 id="ç»´æŠ¤äºŒå‰æœç´¢æ ‘">ç»´æŠ¤äºŒå‰æœç´¢æ ‘</h4><p>ä¹‹å‰å®šä¹‰è¿‡äºŒå‰æœç´¢æ ‘</p><pre class="line-numbers language-haskell" data-language="haskell"><code class="language-haskell">data Tree a &#x3D; Empty | Node a (Tree a) (Tree a) deriving (Show)<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>æ£€ç´¢æ ‘ä¸Šå…ƒç´ æ—¶å€™éœ€è¦å‘å·¦/å‘å³/å‘ä¸Šèµ°, è€Œçº¯å‡½æ•°çš„ç‰¹æ€§è®©æˆ‘ä»¬åªèƒ½å®šä¹‰è¿™æ ·çš„å‡½æ•°</p><pre class="line-numbers language-haskell" data-language="haskell"><code class="language-haskell">goLeft :: Tree a -&gt; Tree a<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>æˆ‘ä»¬çš„å‡½æ•°åªèƒ½è¿”å›ä¸€ä¸ªæ ‘çš„å­æ ‘, è¿™å¯¼è‡´å®ç°å‘ä¸Šèµ°æ˜¯éå¸¸å›°éš¾çš„ğŸ¤¦â€â™‚ï¸. åŒæ—¶, å¦‚æœä¸“é—¨å­˜å‚¨åŸæ ‘, æˆ‘ä»¬å°†æ— æ³•è·å–åŸæ ‘</p><pre class="line-numbers language-haskell" data-language="haskell"><code class="language-haskell">tree &#x3D; geLeft (Node 1 (Empty) (Empty))<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>æ­¤æ—¶<code>tree</code>æ˜¯<code>Empty</code>, ä½†æ˜¯åŸæ ‘æ˜¯ä»€ä¹ˆæˆ‘ä»¬ä¸çŸ¥é“. æˆ‘ä»¬éœ€è¦å°†åŸæ ‘ä½œä¸ºçŠ¶æ€å­˜å‚¨èµ·æ¥, å¯¹äºä¸€æ£µæ ‘</p><pre class="mermaid">graph TB
 Root(Root_cur) --> L
 Root --> R</pre><p>å½“æˆ‘ä»¬è¦å°†ä½ç½®ä»Rootè½¬æ¢åˆ°Læ—¶, æˆ‘ä»¬å¯ä»¥åƒä¹‹å‰Logä¸€æ ·æŠŠ<code>Root</code>ä¸<code>R</code>å­˜å‚¨èµ·æ¥, æˆ‘ä»¬å®šä¹‰ä¸€ä¸ªæ•°æ®ç»“æ„<code>Crumb</code>ğŸ¥¯, <code>LeftCrumb</code>è¡¨ç¤ºå…¶èµ°å‘äº†L, æ­¤æ—¶å­˜å‚¨äº†<code>LeftCrumb Root (Tree R)</code>, åä¹‹ç±»ä¼¼</p><pre class="line-numbers language-haskell" data-language="haskell"><code class="language-haskell">data Crumb a &#x3D; LeftCrumb a (Tree a) | RightCrumb a (Tree a) deriving (Show)<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>å¯ä»¥å°†çŠ¶æ€ä»¬å­˜å‚¨ä¸º<code>[Crumb]</code>, ç”¨<code>Tuple</code>å­˜å‚¨å½“å‰ä½ç½®ä¸çŠ¶æ€, æœ€åå¾—åˆ°äº†</p><pre class="line-numbers language-haskell" data-language="haskell"><code class="language-haskell">data Crumb a &#x3D; LeftCrumb a (Tree a) | RightCrumb a (Tree a) deriving (Show)
type Breadcrumbs a &#x3D; [Crumb a]

goLeft :: (Tree a, Breadcrumbs a) -&gt; (Tree a, Breadcrumbs a)
goLeft (Node x l r, bs) &#x3D; (l, LeftCrumb x r:bs)    -- å½“å‰ä¸ºå·¦å­æ ‘, rootä¸å³å­æ ‘å‹å…¥Breadcrumbs

goRight :: (Tree a, Breadcrumbs a) -&gt; (Tree a, Breadcrumbs a)  
goRight (Node x l r, bs) &#x3D; (r, RightCrumb x l:bs)

goUp :: (Tree a, Breadcrumbs a) -&gt; (Tree a, Breadcrumbs a)  
goUp (t, LeftCrumb x r:bs) &#x3D; (Node x t r, bs)    -- topçš„rootåšå½“å‰ä½ç½®, å±•å¼€å³å­æ ‘
goUp (t, RightCrumb x l:bs) &#x3D; (Node x l t, bs)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>æˆ‘ä»¬è¿˜, å¯ä»¥ä¸ºè¿™æ ·çš„å­˜å‚¨æ¨¡å¼èµ·ä¸ªåˆ«å</p><pre class="line-numbers language-haskell" data-language="haskell"><code class="language-haskell">type Zipper a &#x3D; (Tree a, Breadcrumbs a)<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>æœ€åå®ç°ä¸€ä¸‹èŠ‚ç‚¹çš„ç»´æŠ¤æ“ä½œ</p><pre class="line-numbers language-haskell" data-language="haskell"><code class="language-haskell">modify :: (a -&gt; a) -&gt; Zipper a -&gt; Zipper a  
modify f (Node x l r, bs) &#x3D; (Node (f x) l r, bs)  
modify f (Empty, bs) &#x3D; (Empty, bs)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>æ“ä½œ</p><pre class="line-numbers language-haskell" data-language="haskell"><code class="language-haskell">x -: f &#x3D; f x
freeTree &#x3D; ...
-- å‘å·¦, å‘å³, æ›¿æ¢ä¸ºP 
newFocus &#x3D; (freeTree,[]) -: goLeft -: goRight -: modify (\_ -&gt; &#39;P&#39;)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><h4 id="ç»´æŠ¤list">ç»´æŠ¤<code>List</code></h4><p>å¯ä»¥å°†ä¸€ä¸ªListåˆ†ä¸º<code>cur</code>åŠå…¶å³è¾¹çš„<code>List</code>ä¸<code>cur</code>å·¦è¾¹çš„<code>List</code>çš„é€†åº</p><pre class="line-numbers language-haskell" data-language="haskell"><code class="language-haskell">goForward :: ListZipper a -&gt; ListZipper a  
goForward (x:xs, bs) &#x3D; (xs, x:bs)  

goBack :: ListZipper a -&gt; ListZipper a  
goBack (xs, b:bs) &#x3D; (b:xs, bs)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>ä¾‹å¦‚</p><pre class="line-numbers language-haskell" data-language="haskell"><code class="language-haskell">ghci&gt; let xs &#x3D; [1,2,3,4]  
ghci&gt; goForward (xs,[])  
-- ([2,3,4],[1])  
ghci&gt; goForward ([2,3,4],[1])  
-- ([3,4],[2,1])  
ghci&gt; goForward ([3,4],[2,1])  
-- ([4],[3,2,1])  
ghci&gt; goBack ([4],[3,2,1])  
-- ([3,4],[2,1])<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="ç»´æŠ¤ä¸€ä¸ªæ–‡ä»¶ç³»ç»Ÿ">ç»´æŠ¤ä¸€ä¸ªæ–‡ä»¶ç³»ç»Ÿ</h4><p>ğŸ“ä¸€ä¸ªæ–‡ä»¶ç³»ç»Ÿå°±æ˜¯ä¸€ä¸ªå¤šå‰æ ‘, æ ‘ä¸Šæœ‰ä¸¤ç§ç±»å‹(æ–‡ä»¶ä¸æ–‡ä»¶å¤¹), ä»–ä»¬éƒ½æœ‰æ–‡ä»¶(å¤¹)å, æ–‡ä»¶å¤¹ä¸­åº”è¯¥è¿˜åŒ…å«ä¸€é¢—å­æ ‘, æ–‡ä»¶ä¸­åº”è¯¥åŒ…å«æ–‡ä»¶ä¸­çš„æ•°æ®</p><pre class="line-numbers language-haskell" data-language="haskell"><code class="language-haskell">import Data.List (break)  

type Name &#x3D; String  
type Data &#x3D; String  
-- ä¸€ä¸ªæ–‡ä»¶&#x2F;æ–‡ä»¶å¤¹
data FSItem &#x3D; File Name Data | Folder Name [FSItem] deriving (Show)

-- ä¸Šå±‚æ–‡ä»¶å¤¹å æ–‡ä»¶å¤¹ä¸­è¯¥æ–‡ä»¶å‰é¢çš„æ–‡ä»¶ æ–‡ä»¶å¤¹ä¸­è¯¥æ–‡ä»¶ä¹‹åçš„æ–‡ä»¶
data FSCrumb &#x3D; FSCrumb Name [FSItem] [FSItem] deriving (Show)
type FSZipper &#x3D; (FSItem, [FSCrumb])

-- å‘ä¸Šèµ°å°±æ˜¯å°†ä»–å‰åçš„æ–‡ä»¶å’Œä»–åˆåœ¨ä¸€èµ·
fsUp :: FSZipper -&gt; FSZipper  
fsUp (item, FSCrumb name ls rs:bs) &#x3D; (Folder name (ls ++ [item] ++ rs), bs)

-- è¿›å…¥æ–‡ä»¶å¤¹
fsTo :: Name -&gt; FSZipper -&gt; FSZipper  
fsTo name (Folder folderName items, bs) &#x3D;   
  let (ls, item:rs) &#x3D; break (nameIs name) items  
  in  (item, FSCrumb folderName ls rs:bs)  

-- åˆ¤æ–­æ–‡ä»¶(å¤¹)å
nameIs :: Name -&gt; FSItem -&gt; Bool  
nameIs name (Folder folderName _) &#x3D; name &#x3D;&#x3D; folderName  
nameIs name (File fileName _) &#x3D; name &#x3D;&#x3D; fileName

-- é‡å‘½åæ–‡ä»¶
fsRename :: Name -&gt; FSZipper -&gt; FSZipper  
fsRename newName (Folder name items, bs) &#x3D; (Folder newName items, bs)  
fsRename newName (File name dat, bs) &#x3D; (File newName dat, bs)

-- æ–°å»ºæ–‡ä»¶
fsNewFile :: FSItem -&gt; FSZipper -&gt; FSZipper  
fsNewFile item (Folder folderName items, bs) &#x3D;   
    (Folder folderName (item:items), bs)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>ä¾‹å¦‚</p><pre class="line-numbers language-haskell" data-language="haskell"><code class="language-haskell">-- myDisk &#x3D; ...

ghci&gt; let newFocus &#x3D; (myDisk,[]) -: fsTo &quot;pics&quot; -: fsTo &quot;skull_man(scary).bmp&quot;
ghci&gt; fst newFocus        -- æ˜¾ç¤ºFSItem
-- File &quot;skull_man(scary).bmp&quot; &quot;Yikes!&quot;
ghci&gt; let newFocus2 &#x3D; (myDisk,[]) -: fsTo &quot;pics&quot; -: fsRename &quot;cspi&quot; -: fsUp<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>ğŸ§—<strong>æœ€å, æ³¨æ„è€ƒè™‘è¾¹ç•Œ, ä¸ºæˆ‘ä»¬çš„å‡½æ•°è®¾ç½®å…œåº•æ¡ä»¶, <code>Maybe</code>å¯ä»¥ç”¨äºè¡¨ç¤ºç»™å‡ºçš„åŠ¨ä½œæ˜¯å¦åˆæ³•</strong>, ä¾‹å¦‚:</p><pre class="line-numbers language-haskell" data-language="haskell"><code class="language-haskell">goUp :: Zipper a -&gt; Maybe (Zipper a)  
goUp (t, LeftCrumb x r:bs) &#x3D; Just (Node x t r, bs)  
goUp (t, RightCrumb x l:bs) &#x3D; Just (Node x l t, bs)  
goUp (_, []) &#x3D; Nothing<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><hr><p>å‚è€ƒèµ„æ–™:</p><ul><li><span class="exturl" data-url="aHR0cHM6Ly9sZWFybnlvdWFoYXNrZWxsLm1ubzIub3JnL3poLWNu">Haskellè¶£å­¦æŒ‡å—<i class="fa fa-external-link-alt"></i></span></li><li><span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL3dpbnRlcmxhbmQxOTg5L21hZ2ljLWhhc2tlbGwv">é­”åŠ›Haskell<i class="fa fa-external-link-alt"></i></span></li><li><span class="exturl" data-url="aHR0cHM6Ly93d3cuemhpaHUuY29tL3F1ZXN0aW9uLzQ1MDc3MzEzMS9hbnN3ZXIvMTgwNzMyMTExMA==">çŸ¥ä¹ - ä¸ºä»€ä¹ˆå›½å¤–å¤§å­¦è®¡ç®—æœºç³»æœ¬ç§‘ç”ŸåŸ¹å…»å¦‚æ­¤å¼ºè°ƒå‡½æ•°å¼ç¼–ç¨‹?<i class="fa fa-external-link-alt"></i></span></li></ul></div><footer class="post-footer"><p class="post-end-coffee">-------- æœ¬æ–‡ç»“æŸ <i class="fa-solid fa-mug-hot"></i> æ„Ÿè°¢é˜…è¯» --------</p><div class="popular-posts-header">ç›¸å…³æ–‡ç« </div><ul class="popular-posts"><li class="popular-posts-item"><div class="popular-posts-title"><a href="/article/å¸¸è§çš„æ–‡ä»¶å¤´æ ¼å¼/" rel="bookmark">å¸¸è§çš„æ–‡ä»¶å¤´æ ¼å¼</a></div></li></ul><script>let post_body = document.querySelector('.post-body');
  let theme_switch = document.getElementById('theme_switch');
  const theme = {};
  Object.defineProperty(theme, 'value', {
    set(v){
      post_body.setAttribute('theme', v);
      localStorage.setItem('md_theme', v);
      theme_switch.value = v;
    }
  })
  theme.value = localStorage.getItem('md_theme') || 'sneh';
  theme_switch.addEventListener('change',e=>theme.value = e.target.value)
  document.getElementById('theme_switch_wapper').classList.remove('hidden');</script><div class="reward-container"><div></div><button>èµèµ</button><div class="post-reward"><div><img src="/images/wechatpay.png" alt="Liu Kairui å¾®ä¿¡"> <span>å¾®ä¿¡</span></div><div><img src="/images/alipay.png" alt="Liu Kairui æ”¯ä»˜å®"> <span>æ”¯ä»˜å®</span></div></div></div><div class="post-copyright"><ul><li class="post-copyright-author"><strong>æœ¬æ–‡ä½œè€…ï¼š </strong>Liu Kairui</li><li class="post-copyright-link"><strong>æœ¬æ–‡é“¾æ¥ï¼š</strong> <a href="https://blog.liukairui.me/article/%E5%87%BD%E6%95%B0%E5%BC%8F%E7%BC%96%E7%A8%8BHaskell%E5%88%9D%E6%8E%A2/" title="å‡½æ•°å¼ç¼–ç¨‹Haskellåˆæ¢">https://blog.liukairui.me/article/å‡½æ•°å¼ç¼–ç¨‹Haskellåˆæ¢/</a></li><li class="post-copyright-license"><strong>ç‰ˆæƒå£°æ˜ï¼š </strong>æœ¬åšå®¢æ‰€æœ‰æ–‡ç« é™¤ç‰¹åˆ«å£°æ˜å¤–ï¼Œå‡é‡‡ç”¨ <span class="exturl" data-url="aHR0cHM6Ly9jcmVhdGl2ZWNvbW1vbnMub3JnL2xpY2Vuc2VzL2J5LW5jLXNhLzQuMC9kZWVkLnpo"><i class="fab fa-fw fa-creative-commons"></i>BY-NC-SA</span> è®¸å¯åè®®ã€‚è½¬è½½è¯·æ³¨æ˜å‡ºå¤„ï¼</li></ul></div><div class="post-tags"><a href="/tags/%E7%9E%8E%E6%8A%98%E8%85%BE/" rel="tag"><i class="fa fa-tag"></i> çæŠ˜è…¾</a> <a href="/tags/%E5%87%BD%E6%95%B0%E5%BC%8F%E7%BC%96%E7%A8%8B/" rel="tag"><i class="fa fa-tag"></i> å‡½æ•°å¼ç¼–ç¨‹</a> <a href="/tags/Haskell/" rel="tag"><i class="fa fa-tag"></i> Haskell</a></div><div class="post-nav"><div class="post-nav-item"><a href="/article/JavaScript%E4%B8%A5%E6%A0%BC%E6%A8%A1%E5%BC%8F/" rel="prev" title="JavaScriptä¸¥æ ¼æ¨¡å¼"><i class="fa fa-chevron-left"></i> JavaScriptä¸¥æ ¼æ¨¡å¼</a></div><div class="post-nav-item"><a href="/article/%E6%95%B0%E7%91%9ECookie%E6%B7%B7%E6%B7%86%E6%98%AF%E5%A6%82%E4%BD%95%E5%B7%A5%E4%BD%9C%E7%9A%84/" rel="next" title="æ•°ç‘Cookieæ··æ·†æ˜¯å¦‚ä½•å·¥ä½œçš„">æ•°ç‘Cookieæ··æ·†æ˜¯å¦‚ä½•å·¥ä½œçš„ <i class="fa fa-chevron-right"></i></a></div></div></footer></article></div><div class="comments" id="valine-comments"></div></div></main><footer class="footer"><div class="footer-inner"><div class="copyright">&copy; 2019 â€“ <span itemprop="copyrightYear">2022</span> <span class="with-love"><i class="fa fa-heart"></i> </span><span class="author" itemprop="copyrightHolder">Liu Kairui</span></div><div class="wordcount"><span class="post-meta-item"><span class="post-meta-item-icon"><i class="fa fa-chart-line"></i> </span><span>æ€»å­—æ•°ï¼š</span> <span title="æ€»å­—æ•°">1.4m</span></span></div><div class="busuanzi-count"><span class="post-meta-item" id="busuanzi_container_site_uv"><span class="post-meta-item-icon"><i class="fa fa-user"></i> </span><span class="site-uv" title="æ€»è®¿å®¢é‡"><span id="busuanzi_value_site_uv"></span> </span></span><span class="post-meta-item" id="busuanzi_container_site_pv"><span class="post-meta-item-icon"><i class="fa fa-eye"></i> </span><span class="site-pv" title="æ€»è®¿é—®é‡"><span id="busuanzi_value_site_pv"></span></span></span></div><div class="powered-by">ç”± <span class="exturl" data-url="aHR0cHM6Ly9oZXhvLmlv">Hexo</span> & <span class="exturl" data-url="aHR0cHM6Ly90aGVtZS1uZXh0LmpzLm9yZy9taXN0Lw==">NexT.Mist</span> å¼ºåŠ›é©±åŠ¨</div><div class="addthis_inline_share_toolbox"><script src="//s7.addthis.com/js/300/addthis_widget.js#pubid=ra-630c5bd30a606ba8" async></script></div><div id="time_and_count"></div><script src="https://cdn.jsdelivr.net/npm/moment@2.22.2/moment.min.js"></script><script src="https://cdn.jsdelivr.net/npm/moment-precise-range-plugin@1.3.0/moment-precise-range.min.js"></script><script>function timer() {
    var ages = moment.preciseDiff(moment(),moment(20201101,"YYYYMMDD"));
    ages = ages.replace(/years?/, "å¹´");
    ages = ages.replace(/months?/, "æœˆ");
    ages = ages.replace(/days?/, "å¤©");
    ages = ages.replace(/hours?/, "å°æ—¶");
    ages = ages.replace(/minutes?/, "åˆ†");
    ages = ages.replace(/seconds?/, "ç§’");
    ages = ages.replace(/\d+/g, '<span class="daysCnt" style="color: #1890ff">$&</span>');
    div.innerHTML = `å°ç«™å·²æ‚„æ‚„è¿è¡Œäº† ${ages}`;
    div.className="workDays";
  }
  let div = document.createElement("div");
  let time_and_count = document.getElementById("time_and_count");
  time_and_count.appendChild(div);
  timer();
  setInterval("timer()",1000)</script><script>let footer = document.querySelector('.footer-inner')

let wordCount = document.querySelector('.wordcount')
wordCount.innerHTML = wordCount.innerText.replace('ï¼š',': ').replace('m','M')
if(wordCount){
  time_and_count.appendChild(wordCount);
}

let busaunzi = document.querySelector('.busuanzi-count')
if(busaunzi){
  footer.appendChild(busaunzi);
}

let powerby = document.querySelector('.powered-by')
if(powerby){
  footer.appendChild(powerby);
}</script></div></footer><script src="https://cdnjs.cloudflare.com/ajax/libs/animejs/3.2.1/anime.min.js" integrity="sha256-XL2inqUJaslATFnHdJOi9GfQ60on8Wx1C2H8DYiN1xY=" crossorigin="anonymous"></script><script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.6.1/jquery.min.js" integrity="sha256-o88AwQnZB+VDvE9tvIXrMQaPlFFSUTR+nldQm1LuPXQ=" crossorigin="anonymous"></script><script src="https://cdnjs.cloudflare.com/ajax/libs/fancybox/3.5.7/jquery.fancybox.min.js" integrity="sha256-yt2kYMy0w8AbtF89WXb2P1rfjcP/HTHLT7097U8Y5b8=" crossorigin="anonymous"></script><script src="https://cdnjs.cloudflare.com/ajax/libs/pangu/4.0.7/pangu.min.js" integrity="sha256-j+yj56cdEY2CwkVtGyz18fNybFGpMGJ8JxG3GSyO2+I=" crossorigin="anonymous"></script><script src="/js/comments.js"></script><script src="/js/utils.js"></script><script src="/js/motion.js"></script><script src="/js/schemes/muse.js"></script><script src="/js/next-boot.js"></script><script src="https://cdnjs.cloudflare.com/ajax/libs/algoliasearch/4.14.2/algoliasearch-lite.umd.js" integrity="sha256-dImjLPUsG/6p3+i7gVKBiDM8EemJAhQ0VvkRK2pVsQY=" crossorigin="anonymous"></script><script src="https://cdnjs.cloudflare.com/ajax/libs/instantsearch.js/4.46.3/instantsearch.production.min.js" integrity="sha256-TDBtvQ4sIGgJS5bk8VOKto+yvrblCB/JxE/9odR5u+M=" crossorigin="anonymous"></script><script src="/js/third-party/search/algolia-search.js"></script><script class="next-config" data-name="pdf" type="application/json">{"object_url":{"url":"https://cdnjs.cloudflare.com/ajax/libs/pdfobject/2.2.8/pdfobject.min.js","integrity":"sha256-tu9j5pBilBQrWSDePOOajCUdz6hWsid/lBNzK4KgEPM="},"url":"/lib/pdf/web/viewer"}</script><script src="/js/third-party/tags/pdf.js"></script><script class="next-config" data-name="mermaid" type="application/json">{"enable":true,"theme":"forest","js":{"url":"https://cdnjs.cloudflare.com/ajax/libs/mermaid/9.1.7/mermaid.min.js","integrity":"sha256-G58AID1YoX5YaEtWfXSI0VLrZ6N4kvNvwg0BI8zUFxE="}}</script><script src="/js/third-party/tags/mermaid.js"></script><script src="/js/third-party/fancybox.js"></script><script src="/js/third-party/pace.js"></script><script async src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><script class="next-config" data-name="leancloud_visitors" type="application/json">{"enable":true,"app_id":"ABKlVtS4cyaWYEwunPyK3sXt-9Nh9j0Va","app_key":"xxGXdTTEGEVifs2TLB35844I","server_url":"https://abklvts4.lc-cn-e1-shared.com","security":false}</script><script src="/js/third-party/statistics/lean-analytics.js"></script><script class="next-config" data-name="enableMath" type="application/json">true</script><script class="next-config" data-name="mathjax" type="application/json">{"enable":true,"tags":"none","js":{"url":"https://cdnjs.cloudflare.com/ajax/libs/mathjax/3.2.2/es5/tex-mml-chtml.js","integrity":"sha256-MASABpB4tYktI2Oitl4t+78w/lyA+D7b/s9GEP0JOGI="}}</script><script src="/js/third-party/math/mathjax.js"></script><script src="https://cdnjs.cloudflare.com/ajax/libs/quicklink/2.3.0/quicklink.umd.js" integrity="sha256-yvJQOINiH9fWemHn0vCA5lsHWJaHs6/ZmO+1Ft04SvM=" crossorigin="anonymous"></script><script class="next-config" data-name="quicklink" type="application/json">{"enable":true,"home":false,"archive":false,"delay":true,"timeout":3000,"priority":true,"url":"https://blog.liukairui.me/article/%E5%87%BD%E6%95%B0%E5%BC%8F%E7%BC%96%E7%A8%8BHaskell%E5%88%9D%E6%8E%A2/"}</script><script src="/js/third-party/quicklink.js"></script><script src="https://unpkg.com/darkmode-js@1.5.7/lib/darkmode-js.min.js"></script><script>var options = {
  bottom: '71px',
  right: 'unset',
  left: '30px',
  time: '0s',
  mixColor: 'transparent',
  backgroundColor: 'transparent',
  buttonColorDark: '#222',
  buttonColorLight: '#222',
  saveInCookies: true,
  label: '',
  autoMatchOsTheme: true
}
const darkmode = new Darkmode(options);
window.darkmode = darkmode;
darkmode.showWidget();</script><script>NexT.utils.loadComments('#valine-comments', () => {
  NexT.utils.getScript('https://cdn.jsdelivr.net/npm/valine@1.4.14/dist/Valine.min.js', () => {
    new Valine(Object.assign({"enable":true,"appId":"ABKlVtS4cyaWYEwunPyK3sXt-9Nh9j0Va","appKey":"xxGXdTTEGEVifs2TLB35844I","serverURLs":"https://abklvts4.lc-cn-e1-shared.com","placeholder":"è¯·å¼€å§‹ä½ çš„è¡¨æ¼”","avatar":"identicon","meta":["nick","mail","link"],"pageSize":10,"lang":"zh-CN","visitor":false,"comment_count":true,"recordIP":true,"enableQQ":true,"requiredFields":[]}, {
      el: '#valine-comments',
      path: "/article/%E5%87%BD%E6%95%B0%E5%BC%8F%E7%BC%96%E7%A8%8BHaskell%E5%88%9D%E6%8E%A2/",
      serverURLs: "https://abklvts4.lc-cn-e1-shared.com"
    }));
  }, window.Valine);
});</script><script src="/live2dw/lib/L2Dwidget.min.js?094cbace49a39548bed64abff5988b05"></script><script>L2Dwidget.init({pluginRootPath:"live2dw/",pluginJsPath:"lib/",pluginModelPath:"assets/",tagMode:!1,log:!1,model:{jsonPath:"/live2dw/assets/hijiki.model.json"},display:{position:"right",width:150,height:300},mobile:{show:!1},react:{opacity:.7}})</script></body></html>