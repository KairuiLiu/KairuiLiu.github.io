<!DOCTYPE html><html lang="zh-CN"><head><meta charset="UTF-8"><meta name="viewport" content="width=device-width"><meta name="theme-color" content="#222"><meta name="generator" content="Hexo 6.3.0"><link rel="preconnect" href="https://fonts.googleapis.com" crossorigin><link rel="preconnect" href="https://cdnjs.cloudflare.com" crossorigin><link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon.png"><link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32.png"><link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16.png"><link rel="mask-icon" href="/images/logo.svg" color="#222"><link rel="manifest" href="/images/manifest.json"><link rel="stylesheet" href="/css/main.css"><link rel="stylesheet" href="https://fonts.googleapis.com/css?family=LXGW+WenKai+TC:300,300italic,400,400italic,700,700italic%7CLXGW+WenKai:300,300italic,400,400italic,700,700italic%7CFira+Code:300,300italic,400,400italic,700,700italic&display=swap&subset=latin,latin-ext"><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.2.0/css/all.min.css" integrity="sha256-AbA177XfpSnFEvgpYu1jMygiLabzPCJCRIBtR5jGc0k=" crossorigin="anonymous"><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/animate.css/3.1.1/animate.min.css" integrity="sha256-PR7ttpcvz8qrF57fur/yAx1qXMFJeJFiA6pSzWi0OIE=" crossorigin="anonymous"><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/fancybox/3.5.7/jquery.fancybox.min.css" integrity="sha256-Vzbj7sDDS/woiFS3uNKo8eIuni59rjyNGtXfstRzStA=" crossorigin="anonymous"><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/pace/1.2.4/themes/greem/pace-theme-minimal.css"><script src="https://cdnjs.cloudflare.com/ajax/libs/pace/1.2.4/pace.min.js" integrity="sha256-gqd7YTjg/BtfqWSwsJOvndl0Bxc8gFImLEkXQT8+qj0=" crossorigin="anonymous"></script><script class="next-config" data-name="main" type="application/json">{"hostname":"blog.liukairui.me","root":"/","images":"/images","scheme":"Mist","darkmode":false,"version":"8.13.1","exturl":true,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"width":320},"copycode":{"enable":true,"style":"flat"},"bookmark":{"enable":false,"color":"#222","save":"auto"},"mediumzoom":false,"lazyload":false,"pangu":true,"comments":{"style":"tabs","active":"valine","storage":true,"lazyload":false,"nav":null,"activeClass":"valine"},"stickytabs":false,"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"fadeInDown","post_body":"fadeInDown","coll_header":"fadeInLeft","sidebar":"fadeInUp"}},"prism":false,"i18n":{"placeholder":"搜索...","empty":"没有找到任何搜索结果：${query}","hits_time":"找到 ${hits} 个搜索结果（用时 ${time} 毫秒）","hits":"找到 ${hits} 个搜索结果"},"algolia":{"appID":"GPJGYFJZH3","apiKey":"594eec10fca5caccffae82e82d066310","indexName":"hexo","hits":{"per_page":10}}}</script><script src="/js/config.js"></script><meta name="description" content="理解并尝试实现 React 的 Fiber 与 DOM 构建过程, 通过 Fiber 对比实现更新调度与简单 Hook (useState, useEffect)"><meta property="og:type" content="article"><meta property="og:title" content="React渲染与更新的基本原理与实现"><meta property="og:url" content="https://blog.liukairui.me/article/React%E6%B8%B2%E6%9F%93%E4%B8%8E%E6%9B%B4%E6%96%B0%E7%9A%84%E5%9F%BA%E6%9C%AC%E5%8E%9F%E7%90%86%E4%B8%8E%E5%AE%9E%E7%8E%B0/"><meta property="og:site_name" content="LiuKairui&#39;s Blog"><meta property="og:description" content="理解并尝试实现 React 的 Fiber 与 DOM 构建过程, 通过 Fiber 对比实现更新调度与简单 Hook (useState, useEffect)"><meta property="og:locale" content="zh_CN"><meta property="article:published_time" content="2024-03-10T16:00:01.000Z"><meta property="article:modified_time" content="2024-03-10T16:00:01.000Z"><meta property="article:author" content="Liu Kairui"><meta property="article:tag" content="前端"><meta property="article:tag" content="笔记"><meta property="article:tag" content="前端框架"><meta property="article:tag" content="React"><meta name="twitter:card" content="summary"><link rel="canonical" href="https://blog.liukairui.me/article/React%E6%B8%B2%E6%9F%93%E4%B8%8E%E6%9B%B4%E6%96%B0%E7%9A%84%E5%9F%BA%E6%9C%AC%E5%8E%9F%E7%90%86%E4%B8%8E%E5%AE%9E%E7%8E%B0/"><script class="next-config" data-name="page" type="application/json">{"sidebar":"","isHome":false,"isPost":true,"lang":"zh-CN","comments":true,"permalink":"https://blog.liukairui.me/article/React%E6%B8%B2%E6%9F%93%E4%B8%8E%E6%9B%B4%E6%96%B0%E7%9A%84%E5%9F%BA%E6%9C%AC%E5%8E%9F%E7%90%86%E4%B8%8E%E5%AE%9E%E7%8E%B0/","path":"article/React渲染与更新的基本原理与实现/","title":"React渲染与更新的基本原理与实现"}</script><script class="next-config" data-name="calendar" type="application/json">""</script><title>React渲染与更新的基本原理与实现 | LiuKairui's Blog</title><script>var titleTime,OriginTitile=document.title;document.addEventListener("visibilitychange",function(){document.hidden?(document.title="我们活着是为了什么? | "+OriginTitile,clearTimeout(titleTime)):(document.title="整点薯条 | "+OriginTitile,titleTime=setTimeout(function(){document.title=OriginTitile},2e3))})</script><noscript><link rel="stylesheet" href="/css/noscript.css"></noscript><link rel="alternate" href="/atom.xml" title="LiuKairui's Blog" type="application/atom+xml"><style>.darkmode--activated{--body-bg-color:#282828;--content-bg-color:#333;--card-bg-color:#555;--text-color:#ccc;--blockquote-color:#bbb;--link-color:#ccc;--link-hover-color:#eee;--brand-color:#ddd;--brand-hover-color:#ddd;--table-row-odd-bg-color:#282828;--table-row-hover-bg-color:#363636;--menu-item-bg-color:#555;--btn-default-bg:#222;--btn-default-color:#ccc;--btn-default-border-color:#555;--btn-default-hover-bg:#666;--btn-default-hover-color:#ccc;--btn-default-hover-border-color:#666;--highlight-background:#282b2e;--highlight-foreground:#a9b7c6;--highlight-gutter-background:#34393d;--highlight-gutter-foreground:#9ca9b6}.darkmode--activated img{opacity:.75}.darkmode--activated img:hover{opacity:.9}.darkmode--activated code{color:#69dbdc;background:0 0}button.darkmode-toggle{z-index:9999}.darkmode-ignore,img{display:flex!important}.beian img{display:inline-block!important}</style></head><body itemscope itemtype="http://schema.org/WebPage" class="use-motion"><div class="headband"></div><main class="main"><header class="header" itemscope itemtype="http://schema.org/WPHeader"><div class="header-inner"><div class="site-brand-container"><div class="site-nav-toggle"><div class="toggle" aria-label="切换导航栏" role="button"><span class="toggle-line"></span> <span class="toggle-line"></span> <span class="toggle-line"></span></div></div><div class="site-meta"><a href="/" class="brand" rel="start"><i class="logo-line"></i><p class="site-title">LiuKairui's Blog</p><i class="logo-line"></i></a><p class="site-subtitle" itemprop="description">整点薯条</p></div><div class="site-nav-right"><div class="toggle popup-trigger"><i class="fa fa-search fa-fw fa-lg"></i></div></div></div><nav class="site-nav"><ul class="main-menu menu"><li class="menu-item menu-item-home"><a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a></li><li class="menu-item menu-item-新活"><a href="/ff_monthly/" rel="section"><i class="fa fa-solid fa-newspaper fa-fw"></i>新活</a></li><li class="menu-item menu-item-categories"><a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类</a></li><li class="menu-item menu-item-tags"><a href="/tags/" rel="section"><i class="fas fa-hashtag fa-fw"></i>标签</a></li><li class="menu-item menu-item-收藏夹"><a href="/favorites/" rel="section"><i class="fab fa-gratipay fa-fw"></i>收藏夹</a></li><li class="menu-item menu-item-留言板"><a href="/messageBoard/" rel="section"><i class="fab fa-facebook-messenger fa-fw"></i>留言板</a></li><li class="menu-item menu-item-项目"><a href="/projects/" rel="section"><i class="fa fa-satellite fa-fw"></i>项目</a></li><li class="menu-item menu-item-about"><a href="/about/" rel="section"><i class="fa fa-user fa-fw"></i>关于</a></li><li class="menu-item menu-item-search"><a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>搜索</a></li></ul></nav><div class="search-pop-overlay"><div class="popup search-popup"><div class="search-header"><span class="search-icon"><i class="fa fa-search"></i></span><div class="search-input-container"></div><span class="popup-btn-close" role="button"><i class="fa fa-times-circle"></i></span></div><div class="search-result-container"><div class="algolia-stats"><hr></div><div class="algolia-hits"></div><div class="algolia-pagination"></div></div></div></div><script async src="/js/wobblewindow.js"></script><script async>window.addEventListener("load",function(){768<window.innerWidth&&($("body>main>header").wobbleWindow({radius:50,movementTop:!1,movementLeft:!1,movementRight:!1,debug:!1}),$("body>footer").wobbleWindow({radius:50,movementBottom:!1,movementLeft:!1,movementRight:!1,debug:!1}))})</script></div><div class="toggle sidebar-toggle" role="button"><span class="toggle-line"></span> <span class="toggle-line"></span> <span class="toggle-line"></span></div><aside class="sidebar"><div class="sidebar-inner sidebar-nav-active sidebar-toc-active"><ul class="sidebar-nav"><li class="sidebar-nav-toc">文章目录</li><li class="sidebar-nav-overview">站点概览</li></ul><div class="sidebar-panel-container"><div class="post-toc-wrap sidebar-panel"><div class="post-toc animated"><ol class="nav"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%80%BB%E8%A7%88%E4%B8%8E%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA"><span class="nav-text">总览与环境搭建</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%AE%9E%E7%8E%B0%E7%AE%80%E6%98%93%E6%8C%82%E8%BD%BD-%E5%90%8C%E6%AD%A5%E6%B8%B2%E6%9F%93-%E5%90%8C%E6%AD%A5%E6%8C%82%E8%BD%BD"><span class="nav-text">实现简易挂载 (同步渲染, 同步挂载)</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%BC%95%E5%85%A5-fiber-%E7%9A%84%E6%8C%82%E8%BD%BD-%E5%BC%82%E6%AD%A5%E6%B8%B2%E6%9F%93-%E5%BC%82%E6%AD%A5%E6%8C%82%E8%BD%BD"><span class="nav-text">引入 Fiber 的挂载 (异步渲染, 异步挂载)</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%AE%9E%E7%8E%B0%E6%9B%B4%E6%96%B0-%E6%96%B0%E5%A2%9E%E8%8A%82%E7%82%B9"><span class="nav-text">实现更新 (新增节点)</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%AE%9E%E7%8E%B0%E6%9B%B4%E6%96%B0-%E5%90%8C%E7%B1%BB%E5%9E%8B%E8%8A%82%E7%82%B9%E6%9B%B4%E6%96%B0"><span class="nav-text">实现更新 (同类型节点更新)</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%AE%9E%E7%8E%B0%E6%9B%B4%E6%96%B0-%E8%8A%82%E7%82%B9%E7%A7%BB%E9%99%A4"><span class="nav-text">实现更新 (节点移除)</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%AE%9E%E7%8E%B0%E6%9B%B4%E6%96%B0-%E4%B8%8D%E5%90%8C%E7%B1%BB%E5%9E%8B%E8%8A%82%E7%82%B9"><span class="nav-text">实现更新 (不同类型节点)</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%B0%86%E6%9B%B4%E6%96%B0%E7%B2%92%E5%BA%A6%E7%BC%A9%E5%B0%8F%E4%B8%BA%E7%BB%84%E4%BB%B6"><span class="nav-text">将更新粒度缩小为组件</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%AE%9E%E7%8E%B0%E7%AE%80%E6%98%93-usestate-hook-%E5%90%8C%E6%AD%A5%E6%9B%B4%E6%96%B0"><span class="nav-text">实现简易 useState Hook (同步更新)</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%AE%9E%E7%8E%B0-usestate-hook-%E5%BC%82%E6%AD%A5%E6%9B%B4%E6%96%B0"><span class="nav-text">实现 useState Hook (异步更新)</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%AE%9E%E7%8E%B0%E7%AE%80%E6%98%93-useeffect-hook-%E5%90%8C%E6%AD%A5%E5%9B%9E%E8%B0%83"><span class="nav-text">实现简易 useEffect Hook (同步回调)</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%AE%9E%E7%8E%B0-useeffect-hook-%E5%BC%82%E6%AD%A5%E5%9B%9E%E8%B0%83"><span class="nav-text">实现 useEffect Hook (异步回调)</span></a></li></ol></div></div><div class="site-overview-wrap sidebar-panel"><div class="site-author site-overview-item animated" itemprop="author" itemscope itemtype="http://schema.org/Person"><img class="site-author-image" itemprop="image" alt="Liu Kairui" src="/images/avatar.jpg"><p class="site-author-name" itemprop="name">Liu Kairui</p><div class="site-description" itemprop="description">LiuKairui's Personal Website</div></div><div class="site-state-wrap site-overview-item animated"><nav class="site-state"><div class="site-state-item site-state-posts"><a href="/archives/"><span class="site-state-item-count">74</span> <span class="site-state-item-name">日志</span></a></div><div class="site-state-item site-state-categories"><a href="/categories/"><span class="site-state-item-count">35</span> <span class="site-state-item-name">分类</span></a></div><div class="site-state-item site-state-tags"><a href="/tags/"><span class="site-state-item-count">83</span> <span class="site-state-item-name">标签</span></a></div></nav></div><div class="links-of-author site-overview-item animated"><span class="links-of-author-item"><span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL0thaXJ1aUxpdQ==" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;KairuiLiu"><i class="fab fa-github fa-fw"></i>GitHub</span> </span><span class="links-of-author-item"><span class="exturl" data-url="bWFpbHRvOm1lQGxpdWthaXJ1aS5tZQ==" title="E-Mail → mailto:me@liukairui.me"><i class="fa fa-envelope fa-fw"></i>E-Mail</span> </span><span class="links-of-author-item"><span class="exturl" data-url="aHR0cHM6Ly9xbS5xcS5jb20vY2dpLWJpbi9xbS9xcj9rPW9hZjNUb09sTjE3aHI1c0hWOThiVDhxeHNOWUdhdzVMJm5vdmVyaWZ5PTA=" title="QQ → https:&#x2F;&#x2F;qm.qq.com&#x2F;cgi-bin&#x2F;qm&#x2F;qr?k&#x3D;oaf3ToOlN17hr5sHV98bT8qxsNYGaw5L&amp;noverify&#x3D;0"><i class="fab fa-qq fa-fw"></i>QQ</span> </span><span class="links-of-author-item"><a href="/atom.xml" title="RSS → &#x2F;atom.xml"><i class="fa fa-rss fa-fw"></i>RSS</a> </span><span class="links-of-author-item"><span class="exturl" data-url="aHR0cHM6Ly9saXVrYWlydWkuYmxvZy5jc2RuLm5ldA==" title="CSDN → https:&#x2F;&#x2F;liukairui.blog.csdn.net"><i class="fab fa-cuttlefish fa-fw"></i>CSDN</span></span></div><div class="cc-license site-overview-item animated" itemprop="license"><span class="exturl cc-opacity" data-url="aHR0cHM6Ly9jcmVhdGl2ZWNvbW1vbnMub3JnL2xpY2Vuc2VzL2J5LW5jLXNhLzQuMC9kZWVkLnpo"><img src="https://cdnjs.cloudflare.com/ajax/libs/creativecommons-vocabulary/2020.11.3/assets/license_badges/small/by_nc_sa.svg" alt="Creative Commons"></span></div></div></div></div></aside><div class="sidebar-dimmer"></div></header><div class="back-to-top" role="button" aria-label="返回顶部"><i class="fa fa-arrow-up"></i> <span>0%</span></div><div class="reading-progress-bar"></div><noscript><div class="noscript-warning">Theme NexT works best with JavaScript enabled</div></noscript><div class="main-inner post posts-expand"><div class="post-block"><article itemscope itemtype="http://schema.org/Article" class="post-content" lang="zh-CN"><link itemprop="mainEntityOfPage" href="https://blog.liukairui.me/article/React%E6%B8%B2%E6%9F%93%E4%B8%8E%E6%9B%B4%E6%96%B0%E7%9A%84%E5%9F%BA%E6%9C%AC%E5%8E%9F%E7%90%86%E4%B8%8E%E5%AE%9E%E7%8E%B0/"><span hidden itemprop="author" itemscope itemtype="http://schema.org/Person"><meta itemprop="image" content="/images/avatar.jpg"><meta itemprop="name" content="Liu Kairui"></span><span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization"><meta itemprop="name" content="LiuKairui's Blog"><meta itemprop="description" content="LiuKairui's Personal Website"></span><span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork"><meta itemprop="name" content="React渲染与更新的基本原理与实现 | LiuKairui's Blog"><meta itemprop="description" content="理解并尝试实现 React 的 Fiber 与 DOM 构建过程, 通过 Fiber 对比实现更新调度与简单 Hook (useState, useEffect)"></span><header class="post-header"><h1 class="post-title" itemprop="name headline">React渲染与更新的基本原理与实现</h1><div class="post-meta-container"><div class="post-meta"><span class="post-meta-item"><span class="post-meta-item-icon"><i class="far fa-calendar"></i> </span><span class="post-meta-item-text">发表于</span> <time title="创建时间：2024-03-11 00:00:01" itemprop="dateCreated datePublished" datetime="2024-03-11T00:00:01+08:00">2024-03-11</time> </span><span class="post-meta-item"><span class="post-meta-item-icon"><i class="far fa-folder"></i> </span><span class="post-meta-item-text">分类于</span> <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/%E5%89%8D%E7%AB%AF/" itemprop="url" rel="index"><span itemprop="name">前端</span></a> </span>， <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/%E5%89%8D%E7%AB%AF/%E5%89%8D%E7%AB%AF%E6%A1%86%E6%9E%B6/" itemprop="url" rel="index"><span itemprop="name">前端框架</span></a> </span></span><span id="/article/React%E6%B8%B2%E6%9F%93%E4%B8%8E%E6%9B%B4%E6%96%B0%E7%9A%84%E5%9F%BA%E6%9C%AC%E5%8E%9F%E7%90%86%E4%B8%8E%E5%AE%9E%E7%8E%B0/" class="post-meta-item leancloud_visitors" data-flag-title="React渲染与更新的基本原理与实现" title="阅读次数"><span class="post-meta-item-icon"><i class="far fa-eye"></i> </span><span class="post-meta-item-text">阅读次数：</span> <span class="leancloud-visitors-count"></span> </span><span class="post-meta-item" title="阅读次数" id="busuanzi_container_page_pv"><span class="post-meta-item-icon"><i class="far fa-eye"></i> </span><span class="post-meta-item-text">阅读次数：</span> <span id="busuanzi_value_page_pv"></span> </span><span class="post-meta-item"><span class="post-meta-item-icon"><i class="far fa-comment"></i> </span><span class="post-meta-item-text">Valine：</span> <a title="valine" href="/article/React%E6%B8%B2%E6%9F%93%E4%B8%8E%E6%9B%B4%E6%96%B0%E7%9A%84%E5%9F%BA%E6%9C%AC%E5%8E%9F%E7%90%86%E4%B8%8E%E5%AE%9E%E7%8E%B0/#valine-comments" itemprop="discussionUrl"><span class="post-comments-count valine-comment-count" data-xid="/article/React%E6%B8%B2%E6%9F%93%E4%B8%8E%E6%9B%B4%E6%96%B0%E7%9A%84%E5%9F%BA%E6%9C%AC%E5%8E%9F%E7%90%86%E4%B8%8E%E5%AE%9E%E7%8E%B0/" itemprop="commentCount"></span> </a></span><span class="post-meta-item theme_switch_wapper hidden" id="theme_switch_wapper"><span class="post-meta-item-icon"><i class="fa-brands fa-markdown"></i></span> <span class="post-meta-item-text">主题： </span><select name="theme_switch" id="theme_switch"><option>sneh</option><option>mo</option><option>with</option><option>next</option></select> </span><span class="post-meta-item" title="本文字数"><span class="post-meta-item-icon"><i class="far fa-file-word"></i> </span><span class="post-meta-item-text">本文字数：</span> <span>27k</span></span></div><div class="post-description">理解并尝试实现 React 的 Fiber 与 DOM 构建过程, 通过 Fiber 对比实现更新调度与简单 Hook (useState, useEffect)</div></div></header><div class="post-body" itemprop="articleBody"><p>完整代码: <span class="exturl" data-url="aHR0cHM6Ly9naXN0LmdpdGh1Yi5jb20vS2FpcnVpTGl1L2RjOGFhYWIxNzc3NDI1ZWNlM2E3NDZlMzVmM2RlNDJj">GitHub Gist<i class="fa fa-external-link-alt"></i></span></p><h2 id="总览与环境搭建">总览与环境搭建</h2><p>模板: React 以 <code>[JT]sx</code> 作为模板, 无需自己实现编译模块.</p><p>响应式: React 对外暴露 <code>useState</code>, 用户调用 <code>setState</code> 后 React 对组件做重新构建, 对比 vDOM 的变化并完成节点的替换</p><p>核心: React 的基本数据结构 Fiber 串起整个渲染流, 挂载, 更新等机制都通过 Fiber 链这一数据结构完成.</p><p><strong>实验环境搭建</strong></p><ul><li><p>初始化项目</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">pnpm</span> init<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></li><li><p>安装 Vite 用于 jsx 的编译与项目打包</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">pnpm</span> i <span class="token parameter variable">-D</span> vite<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></li><li><p>创建入口文件</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token builtin class-name">.</span>
├── components
│   └── Welcome.jsx
├── core
│   ├── ReactDOM.js
│   └── React.js
├── index.html
├── main.jsx
├── package.json
└── pnpm-lock.yaml<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li></ul><h2 id="实现简易挂载-同步渲染-同步挂载">实现简易挂载 (同步渲染, 同步挂载)</h2><p><strong>实现 <code>index.html</code></strong></p><p>我们需要一个组件的挂载容器, 引入 JS 的入口文件 <code>main.jsx</code></p><pre class="line-numbers language-markup" data-language="markup"><code class="language-markup"><span class="token doctype"><span class="token punctuation">&lt;!</span><span class="token doctype-tag">doctype</span> <span class="token name">html</span><span class="token punctuation">></span></span>
<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>html</span> <span class="token attr-name">lang</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>en<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>
  <span class="token comment">&lt;!--...--></span>
  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>body</span><span class="token punctuation">></span></span>
    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>div</span> <span class="token attr-name">id</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>root<span class="token punctuation">"</span></span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>div</span><span class="token punctuation">></span></span>
    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>script</span> <span class="token attr-name">type</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>module<span class="token punctuation">"</span></span> <span class="token attr-name">src</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>/main.jsx<span class="token punctuation">"</span></span><span class="token punctuation">></span></span><span class="token script"></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>script</span><span class="token punctuation">></span></span>
  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>body</span><span class="token punctuation">></span></span>
<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>html</span><span class="token punctuation">></span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>实现 <code>main.jsx</code></strong></p><p>只需要实现获取挂载节点并挂载组件的操作</p><pre class="line-numbers language-jsx" data-language="jsx"><code class="language-jsx"><span class="token keyword">import</span> ReactDOM <span class="token keyword">from</span> <span class="token string">'./core/ReactDOM'</span><span class="token punctuation">;</span>
<span class="token keyword">import</span> React <span class="token keyword">from</span> <span class="token string">'./core/React'</span><span class="token punctuation">;</span>
<span class="token keyword">import</span> Welcome <span class="token keyword">from</span> <span class="token string">'./components/Welcome'</span><span class="token punctuation">;</span>

ReactDOM<span class="token punctuation">.</span><span class="token function">createRoot</span><span class="token punctuation">(</span>document<span class="token punctuation">.</span><span class="token function">getElementById</span><span class="token punctuation">(</span><span class="token string">'root'</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">render</span><span class="token punctuation">(</span>Welcome<span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>在这里 <code>import React from './core/React';</code> 可能会报错引入但没有使用. 我们应该保留这段代码, 因为所有的<code>JSX</code> Element 在编译后都会默认变成 <code>React.createElement(nodeName, props, ...children)</code> 如果不引入 <code>React</code> 编译后的代码就会报错找不到 <code>createElement</code></p><p><strong>暂时实现 <code>Welcome.jsx</code></strong></p><p>我们暂时没有实现函数式组件, 因此直接导出一个对象</p><pre class="line-numbers language-jsx" data-language="jsx"><code class="language-jsx"><span class="token keyword">import</span> React <span class="token keyword">from</span> <span class="token string">'../core/React'</span><span class="token punctuation">;</span>

<span class="token keyword">export</span> <span class="token keyword">default</span> <span class="token punctuation">(</span>
  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>div</span><span class="token punctuation">></span></span><span class="token plain-text">
    </span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>h1</span> <span class="token attr-name">id</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>title<span class="token punctuation">"</span></span><span class="token punctuation">></span></span><span class="token plain-text">
      Hello World </span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>span</span> <span class="token attr-name">id</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>emoji<span class="token punctuation">"</span></span><span class="token punctuation">></span></span><span class="token plain-text">🤗</span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>span</span><span class="token punctuation">></span></span><span class="token plain-text">
    </span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>h1</span><span class="token punctuation">></span></span><span class="token plain-text">
    </span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>p</span><span class="token punctuation">></span></span><span class="token plain-text">This is a mini react</span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>p</span><span class="token punctuation">></span></span><span class="token plain-text">
    Looks Cool !
  </span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>div</span><span class="token punctuation">></span></span>
<span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>在这里我们测试了:</p><ul><li>嵌套 Element 的构建</li><li>props 的构建</li><li>TextNode 与 Element 混杂构建</li></ul><p><strong>实现 <code>ReactDOM.js</code></strong></p><p>需要实现 <code>ReactDOM.createRoot</code> 用于接受挂载根, 并暴露 <code>render</code> 方法用来接受根节点的组件</p><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript"><span class="token keyword">import</span> React <span class="token keyword">from</span> <span class="token string">'./React.js'</span><span class="token punctuation">;</span>

<span class="token keyword">const</span> ReactDOM <span class="token operator">=</span> <span class="token punctuation">&#123;</span>
  <span class="token function">createRoot</span><span class="token punctuation">(</span><span class="token parameter">container</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
    <span class="token keyword">return</span> <span class="token punctuation">&#123;</span>
      <span class="token function">render</span><span class="token punctuation">(</span><span class="token parameter">app</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
        React<span class="token punctuation">.</span><span class="token function">render</span><span class="token punctuation">(</span>app<span class="token punctuation">,</span> container<span class="token punctuation">)</span><span class="token punctuation">;</span>
      <span class="token punctuation">&#125;</span><span class="token punctuation">,</span>
    <span class="token punctuation">&#125;</span><span class="token punctuation">;</span>
  <span class="token punctuation">&#125;</span><span class="token punctuation">,</span>
<span class="token punctuation">&#125;</span><span class="token punctuation">;</span>

<span class="token keyword">export</span> <span class="token keyword">default</span> ReactDOM<span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><code>render</code> 的实现交给 <code>React.js</code> 完成</p><p><strong>实现 <code>React.js</code></strong></p><p>首先看一下 Component 的编译后代码</p><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript"><span class="token keyword">import</span> React <span class="token keyword">from</span> <span class="token string">"/core/React.js"</span><span class="token punctuation">;</span>
<span class="token keyword">export</span> <span class="token keyword">default</span> <span class="token comment">/* @__PURE__ */</span>
<span class="token comment">// 创建最外层的 div, props 为空, 子元素有 h1, p, Looks Cool !</span>
React<span class="token punctuation">.</span><span class="token function">createElement</span><span class="token punctuation">(</span><span class="token string">"div"</span><span class="token punctuation">,</span> <span class="token keyword">null</span><span class="token punctuation">,</span> <span class="token comment">/* @__PURE__ */</span>
<span class="token comment">// h1 元素, 有 id="title" 子元素 Hello World, emoji</span>
React<span class="token punctuation">.</span><span class="token function">createElement</span><span class="token punctuation">(</span><span class="token string">"h1"</span><span class="token punctuation">,</span> <span class="token punctuation">&#123;</span>
    <span class="token literal-property property">id</span><span class="token operator">:</span> <span class="token string">"title"</span>
<span class="token punctuation">&#125;</span><span class="token punctuation">,</span> <span class="token string">"Hello World "</span><span class="token punctuation">,</span> <span class="token comment">/* @__PURE__ */</span>
React<span class="token punctuation">.</span><span class="token function">createElement</span><span class="token punctuation">(</span><span class="token string">"span"</span><span class="token punctuation">,</span> <span class="token punctuation">&#123;</span>
    <span class="token literal-property property">id</span><span class="token operator">:</span> <span class="token string">"emoji"</span>
<span class="token punctuation">&#125;</span><span class="token punctuation">,</span> <span class="token string">"🤗"</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token comment">/* @__PURE__ */</span>
React<span class="token punctuation">.</span><span class="token function">createElement</span><span class="token punctuation">(</span><span class="token string">"p"</span><span class="token punctuation">,</span> <span class="token keyword">null</span><span class="token punctuation">,</span> <span class="token string">"This is a mini react"</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token string">"Looks Cool !"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>我们需要实现 <code>createElement(nodeName, props, ...children)</code> 创建 vDOM. vDOM 的数据结构为</p><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript"><span class="token punctuation">&#123;</span>
  <span class="token literal-property property">nodeName</span><span class="token operator">:</span> string<span class="token operator">|</span><span class="token keyword">function</span><span class="token punctuation">,</span><span class="token comment">// 对于组件来说是 function, 对于 HTML Element 是标签名</span>
  <span class="token literal-property property">props</span><span class="token operator">:</span> <span class="token punctuation">&#123;</span>
    <span class="token literal-property property">attributeKey</span><span class="token operator">:</span> value
    <span class="token literal-property property">children</span><span class="token operator">:</span> <span class="token punctuation">[</span><span class="token punctuation">]</span>
  <span class="token punctuation">&#125;</span>
<span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>注意到函数有如下重载:</p><ul><li><code>props</code>: 可以为 <code>null</code> 或者 <code>&#123;k: v&#125;</code></li><li><code>children</code>: 可以为 <code>String</code>, <code>React.createElement()</code></li></ul><p>我们先将重载问题处理掉</p><ul><li>如果 <code>props</code> 是 null, 将 props 赋为 <code>&#123;&#125;</code></li><li>如果 <code>children</code> String, 我们就将他包一层 vDOM</li></ul><p>实现如下</p><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript"><span class="token keyword">function</span> <span class="token function">createElement</span><span class="token punctuation">(</span><span class="token parameter">nodeName<span class="token punctuation">,</span> props <span class="token operator">=</span> <span class="token punctuation">&#123;</span><span class="token punctuation">&#125;</span><span class="token punctuation">,</span> <span class="token operator">...</span>children</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
  <span class="token keyword">return</span> <span class="token punctuation">&#123;</span>
    nodeName<span class="token punctuation">,</span>
    <span class="token literal-property property">props</span><span class="token operator">:</span> <span class="token punctuation">&#123;</span>
      <span class="token operator">...</span>props<span class="token punctuation">,</span>
      <span class="token literal-property property">children</span><span class="token operator">:</span> children<span class="token punctuation">.</span><span class="token function">map</span><span class="token punctuation">(</span>formatNode<span class="token punctuation">)</span><span class="token punctuation">,</span>
    <span class="token punctuation">&#125;</span><span class="token punctuation">,</span>
  <span class="token punctuation">&#125;</span><span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>再实现一个格式化节点功能处理 <code>children</code> 值为 <code>String</code> 的问题</p><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript"><span class="token keyword">function</span> <span class="token function">isTextNode</span><span class="token punctuation">(</span><span class="token parameter">node</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
  <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token keyword">typeof</span> node <span class="token operator">===</span> <span class="token string">'function'</span><span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span> <span class="token comment">// 组件不是 TextNode</span>
  <span class="token keyword">if</span> <span class="token punctuation">(</span>node <span class="token operator">===</span> <span class="token keyword">null</span> <span class="token operator">||</span> <span class="token keyword">typeof</span> node <span class="token operator">!==</span> <span class="token string">'object'</span><span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span> <span class="token comment">// 考虑了 false 等非 string</span>
  <span class="token keyword">const</span> proto <span class="token operator">=</span> Object<span class="token punctuation">.</span><span class="token function">getPrototypeOf</span><span class="token punctuation">(</span>node<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 考虑了 Array 等情况</span>
  <span class="token keyword">return</span> proto <span class="token operator">!==</span> <span class="token class-name">Object</span><span class="token punctuation">.</span>prototype <span class="token operator">&amp;&amp;</span> proto <span class="token operator">!==</span> <span class="token keyword">null</span><span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span>

<span class="token keyword">function</span> <span class="token function">formatNode</span><span class="token punctuation">(</span><span class="token parameter">node</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
  <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">isTextNode</span><span class="token punctuation">(</span>node<span class="token punctuation">)</span><span class="token punctuation">)</span>
    <span class="token keyword">return</span> <span class="token punctuation">&#123;</span>
      <span class="token literal-property property">nodeName</span><span class="token operator">:</span> <span class="token string">'TEXT_ELEMENT'</span><span class="token punctuation">,</span>
      <span class="token literal-property property">props</span><span class="token operator">:</span> <span class="token punctuation">&#123;</span>
        <span class="token literal-property property">children</span><span class="token operator">:</span> <span class="token punctuation">[</span><span class="token template-string"><span class="token template-punctuation string">`</span><span class="token interpolation"><span class="token interpolation-punctuation punctuation">$&#123;</span>node<span class="token interpolation-punctuation punctuation">&#125;</span></span><span class="token template-punctuation string">`</span></span><span class="token punctuation">]</span><span class="token punctuation">,</span>
        <span class="token literal-property property">data</span><span class="token operator">:</span> <span class="token template-string"><span class="token template-punctuation string">`</span><span class="token interpolation"><span class="token interpolation-punctuation punctuation">$&#123;</span>node<span class="token interpolation-punctuation punctuation">&#125;</span></span><span class="token template-punctuation string">`</span></span><span class="token punctuation">,</span>
      <span class="token punctuation">&#125;</span><span class="token punctuation">,</span>
    <span class="token punctuation">&#125;</span><span class="token punctuation">;</span>

  node<span class="token punctuation">.</span>props <span class="token operator">??=</span> <span class="token punctuation">&#123;</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span>
  node<span class="token punctuation">.</span>props<span class="token punctuation">.</span>children <span class="token operator">??=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
  node<span class="token punctuation">.</span>props<span class="token punctuation">.</span>children <span class="token operator">=</span> Array<span class="token punctuation">.</span><span class="token function">isArray</span><span class="token punctuation">(</span>node<span class="token punctuation">.</span>props<span class="token punctuation">.</span>children<span class="token punctuation">)</span>
    <span class="token operator">?</span> node<span class="token punctuation">.</span>props<span class="token punctuation">.</span>children
    <span class="token operator">:</span> <span class="token punctuation">[</span>node<span class="token punctuation">.</span>props<span class="token punctuation">.</span>children<span class="token punctuation">]</span><span class="token punctuation">;</span>

  node<span class="token punctuation">.</span>props<span class="token punctuation">.</span>children<span class="token punctuation">.</span><span class="token function">forEach</span><span class="token punctuation">(</span>formatNode<span class="token punctuation">)</span><span class="token punctuation">;</span>

  <span class="token keyword">return</span> node<span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>最后实现 <code>render(component, container)</code> 函数交付给 ReactDOM 挂载. 渲染节点可以分为: DOM 创建, 绑定属性, 子节点处理, 挂载</p><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript"><span class="token keyword">function</span> <span class="token function">render</span><span class="token punctuation">(</span><span class="token parameter">component<span class="token punctuation">,</span> container</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
  <span class="token keyword">const</span> componentFormatted <span class="token operator">=</span> <span class="token function">formatNode</span><span class="token punctuation">(</span>component<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 格式化 String</span>
  <span class="token keyword">const</span> node <span class="token operator">=</span> <span class="token function">createNode</span><span class="token punctuation">(</span>componentFormatted<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 创建 Node</span>
  <span class="token function">patchProps</span><span class="token punctuation">(</span>node<span class="token punctuation">,</span> componentFormatted<span class="token punctuation">.</span>props<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 绑定属性</span>
  <span class="token function">fillNode</span><span class="token punctuation">(</span>node<span class="token punctuation">,</span> componentFormatted<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 填充子节点</span>
  container<span class="token punctuation">.</span><span class="token function">append</span><span class="token punctuation">(</span>node<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 挂载</span>
<span class="token punctuation">&#125;</span>

<span class="token comment">// 创建节点: 将 TextNode 与 Element 分开</span>
<span class="token keyword">function</span> <span class="token function">createNode</span><span class="token punctuation">(</span><span class="token parameter"><span class="token punctuation">&#123;</span> nodeName<span class="token punctuation">,</span> props <span class="token punctuation">&#125;</span></span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
  <span class="token keyword">if</span> <span class="token punctuation">(</span>nodeName <span class="token operator">===</span> <span class="token string">'TEXT_ELEMENT'</span><span class="token punctuation">)</span>
    <span class="token keyword">return</span> document<span class="token punctuation">.</span><span class="token function">createTextNode</span><span class="token punctuation">(</span>props<span class="token punctuation">.</span>children<span class="token operator">?.</span><span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">||</span> <span class="token string">''</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token keyword">return</span> document<span class="token punctuation">.</span><span class="token function">createElement</span><span class="token punctuation">(</span>nodeName<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span>

<span class="token comment">// 绑定属性: 将非 children 的属性绑定在 Element 上</span>
<span class="token keyword">function</span> <span class="token function">isEvent</span><span class="token punctuation">(</span><span class="token parameter">k</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
  <span class="token keyword">return</span> k<span class="token punctuation">.</span><span class="token function">match</span><span class="token punctuation">(</span><span class="token regex"><span class="token regex-delimiter">/</span><span class="token regex-source language-regex">^on[A-Z][a-zA-Z]*$</span><span class="token regex-delimiter">/</span></span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span>

<span class="token keyword">function</span> <span class="token function">getEventName</span><span class="token punctuation">(</span><span class="token parameter">k</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
  <span class="token keyword">return</span> k<span class="token punctuation">.</span><span class="token function">replace</span><span class="token punctuation">(</span>
    <span class="token regex"><span class="token regex-delimiter">/</span><span class="token regex-source language-regex">^on([A-Z])([a-zA-Z]*)$</span><span class="token regex-delimiter">/</span></span><span class="token punctuation">,</span>
    <span class="token punctuation">(</span><span class="token parameter">_<span class="token punctuation">,</span> prefix<span class="token punctuation">,</span> suffix</span><span class="token punctuation">)</span> <span class="token operator">=></span> prefix<span class="token punctuation">.</span><span class="token function">toLowerCase</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">+</span> suffix
  <span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span>

<span class="token keyword">function</span> <span class="token function">bindProps</span><span class="token punctuation">(</span><span class="token parameter">node<span class="token punctuation">,</span> k<span class="token punctuation">,</span> v</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
  <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">isEvent</span><span class="token punctuation">(</span>k<span class="token punctuation">)</span><span class="token punctuation">)</span> node<span class="token punctuation">.</span><span class="token function">addEventListener</span><span class="token punctuation">(</span><span class="token function">getEventName</span><span class="token punctuation">(</span>k<span class="token punctuation">)</span><span class="token punctuation">,</span> v<span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token keyword">else</span> node<span class="token punctuation">[</span>k<span class="token punctuation">]</span> <span class="token operator">=</span> v<span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span>

<span class="token keyword">function</span> <span class="token function">patchProps</span><span class="token punctuation">(</span><span class="token parameter">node<span class="token punctuation">,</span> props</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
  Object<span class="token punctuation">.</span><span class="token function">keys</span><span class="token punctuation">(</span>props<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">forEach</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token parameter">k</span><span class="token punctuation">)</span> <span class="token operator">=></span> <span class="token punctuation">&#123;</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>k <span class="token operator">===</span> <span class="token string">'children'</span><span class="token punctuation">)</span> <span class="token keyword">return</span><span class="token punctuation">;</span>
    <span class="token function">bindProps</span><span class="token punctuation">(</span>node<span class="token punctuation">,</span> k<span class="token punctuation">,</span> v<span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">&#125;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span>

<span class="token comment">// 填充子节点: 如果当前节点是 TextNode: 将孩子合并为 String, 否则 render 子节点</span>
<span class="token keyword">function</span> <span class="token function">fillNode</span><span class="token punctuation">(</span><span class="token parameter">node<span class="token punctuation">,</span> <span class="token punctuation">&#123;</span> nodeName<span class="token punctuation">,</span> <span class="token literal-property property">props</span><span class="token operator">:</span> <span class="token punctuation">&#123;</span> children <span class="token punctuation">&#125;</span> <span class="token punctuation">&#125;</span></span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
  <span class="token keyword">if</span> <span class="token punctuation">(</span>nodeName <span class="token operator">===</span> <span class="token string">'TEXT_ELEMENT'</span><span class="token punctuation">)</span>
    <span class="token keyword">return</span> <span class="token punctuation">(</span>node<span class="token punctuation">.</span>data <span class="token operator">=</span> children<span class="token punctuation">.</span><span class="token function">reduce</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token parameter">pre<span class="token punctuation">,</span> cur</span><span class="token punctuation">)</span> <span class="token operator">=></span> pre <span class="token operator">+</span> cur<span class="token punctuation">,</span> <span class="token string">''</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

  children<span class="token punctuation">.</span><span class="token function">forEach</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token parameter">childNode</span><span class="token punctuation">)</span> <span class="token operator">=></span> <span class="token function">render</span><span class="token punctuation">(</span>childNode<span class="token punctuation">,</span> node<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="引入-fiber-的挂载-异步渲染-异步挂载">引入 <code>Fiber</code> 的挂载 (异步渲染, 异步挂载)</h2><ul><li>Fiber是什么: Fiber 是 React 的工作单元, 对应 React 中的一个组件, Fiber 上不仅包含组件 vDOM, 还包含了渲染与更新的上下文</li><li>为什么引入 Fiber: 目前的 React 挂载是同步实现的, 渲染非常重的页面会造成同步代码阻塞. 为了减少同步代码阻塞, React 16 引入了基于 Fiber 的组件<strong>异步渲染与挂载</strong>并基于 Fiber 实现了任务优先级调度.</li><li>如何实现基于 Fiber 的挂载: Fiber 以链表的形式构造, 在 <code>render</code> 的时候构造 Root Fiber, 渲染 Root Fiber 后 React 将指针切换到下一个 Fiber 渲染下一个 Fiber 中的组件</li><li>如何实现异步渲染与挂载:<ul><li>异步渲染: React 使用 <code>requestIdleCallback</code> 向全局注册一个闲时回调, 只有在当前没有任务需要执行的时候浏览器才会调用 React 执行 Fiber 的渲染. 一旦有代码需要执行, React 会停止渲染, 保存当前的 Fiber 指针, 知道下一次全局空闲时执行</li><li>异步挂载: Fiber 在渲染后并不会直接挂载到全局, 只有当前全局 Fiber 全部执行完才会<strong>统一提交挂载</strong>. 这样一来减少了 DOM 重绘次数, 二来防止页面渲染了一半就展示给用户</li></ul></li></ul><p><strong>Fiber 的数据结构与 Fiber 链表</strong></p><p>vDOM 是一棵树, Fiber 链是一个链表, 使用 DFS 序将树转为链表. 一个 Fiber 的数据结构为</p><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript"><span class="token punctuation">&#123;</span>
  <span class="token comment">// 记录渲染信息</span>
  dom<span class="token punctuation">,</span> <span class="token comment">// 这个 vDOM 对应的 DOM</span>
  component<span class="token punctuation">,</span> <span class="token comment">// Fiber 对应的 vDOM</span>
  <span class="token comment">// 记录树上信息</span>
  parentFiber<span class="token punctuation">,</span> <span class="token comment">// 父 Fiber</span>
  firstChildFiber<span class="token punctuation">,</span> <span class="token comment">// 第一个孩子对应 Fiber</span>
  siblingFiber<span class="token punctuation">,</span> <span class="token comment">// 右兄弟组件对应 Fiber</span>
<span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>为了减少递归, 我们不会在 <code>render</code> 的时候计算整个链表, 而是在处理 fiber 的时候动态计算链表</p><p><strong>Fiber Loop 的实现</strong></p><p>在全局定义一个 <code>nextFiber</code> 存储接下来要处理的 Fiber. 每次 React 在空闲渲染的时候就从这个 <code>nextFiber</code> 开始渲染</p><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript"><span class="token keyword">let</span> nextFiber <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">;</span> <span class="token comment">// 接下来要处理的 Fiber</span>

<span class="token comment">// 用户提交 render 请求的时设置接下来要处理的 Fiber</span>
<span class="token keyword">function</span> <span class="token function">render</span><span class="token punctuation">(</span><span class="token parameter">component<span class="token punctuation">,</span> container</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
  <span class="token comment">// 这个 Fiber 比较特殊, 我们手动指定了 dom 为 container, 即 component 的父节点.</span>
  <span class="token comment">// 这是因为根节点是一个组件, 组件只能 return 一个 child 作为根. 我们可以跳过组件的渲染, 直接渲染他唯一的子组件</span>
  <span class="token comment">// 将本来的: container -> 根组件 -> 根组件唯一的 child</span>
  <span class="token comment">// 变成: container -> 根组件唯一的 child</span>
  nextFiber <span class="token operator">=</span> <span class="token punctuation">&#123;</span>
    <span class="token literal-property property">dom</span><span class="token operator">:</span> container<span class="token punctuation">,</span>
    component<span class="token punctuation">,</span>
    <span class="token literal-property property">parentFiber</span><span class="token operator">:</span> <span class="token keyword">null</span><span class="token punctuation">,</span>
    <span class="token literal-property property">firstChildFiber</span><span class="token operator">:</span> <span class="token keyword">null</span><span class="token punctuation">,</span>
    <span class="token literal-property property">siblingFiber</span><span class="token operator">:</span> <span class="token keyword">null</span><span class="token punctuation">,</span>
  <span class="token punctuation">&#125;</span><span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span>

<span class="token keyword">function</span> <span class="token function">performFiberLoop</span><span class="token punctuation">(</span><span class="token parameter">idleDeadline</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
  <span class="token comment">// 如果预计空闲时间 >1 有需要处理的 Fiber</span>
  <span class="token keyword">while</span> <span class="token punctuation">(</span>idleDeadline<span class="token punctuation">.</span><span class="token function">timeRemaining</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">></span> <span class="token number">1</span> <span class="token operator">&amp;&amp;</span> nextFiber<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
    <span class="token comment">// 处理 Fiber</span>
    <span class="token function">performFiber</span><span class="token punctuation">(</span>nextFiber<span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">&#125;</span>

  <span class="token function">requestIdleCallback</span><span class="token punctuation">(</span>performFiberLoop<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span>

<span class="token comment">// 在空闲时候调用 performFiberLoop 完成 Fiber Loop</span>
<span class="token function">requestIdleCallback</span><span class="token punctuation">(</span>performFiberLoop<span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>处理单个 Fiber (异步渲染, 同步挂载)</strong></p><p>实现单个 Fiber 的处理过程与实现无 Fiber 时的 <code>render</code> 类似. 在 <code>render</code> 外我们在处理当前 Fiber 时还构造了孩子的 Fiber 并确定了孩子 Fiber 之间的关系</p><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript"><span class="token comment">// 5. 处理当前 Fiber 的孩子</span>
<span class="token keyword">function</span> <span class="token function">processChildFiber</span><span class="token punctuation">(</span><span class="token parameter">fiber<span class="token punctuation">,</span> children</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
  <span class="token comment">// Text Node 是最小单元了, 不处理 Text Node 的孩子</span>
  <span class="token keyword">if</span> <span class="token punctuation">(</span>fiber<span class="token punctuation">.</span>component<span class="token punctuation">.</span>nodeName <span class="token operator">===</span> <span class="token string">'TEXT_ELEMENT'</span><span class="token punctuation">)</span> <span class="token keyword">return</span><span class="token punctuation">;</span>

  <span class="token comment">// 没有孩子直接返回</span>
  <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>children<span class="token punctuation">.</span>length<span class="token punctuation">)</span> <span class="token keyword">return</span><span class="token punctuation">;</span>

  <span class="token comment">// 遍历所有孩子, cur = 当前孩子, prev = 当前孩子的左兄弟</span>
  children<span class="token punctuation">.</span><span class="token function">reduce</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token parameter">prev<span class="token punctuation">,</span> cur</span><span class="token punctuation">)</span> <span class="token operator">=></span> <span class="token punctuation">&#123;</span>
    <span class="token comment">// 为当前孩子创建 Fiber</span>
    <span class="token keyword">const</span> curFiber <span class="token operator">=</span> <span class="token punctuation">&#123;</span>
      <span class="token literal-property property">dom</span><span class="token operator">:</span> <span class="token keyword">null</span><span class="token punctuation">,</span> <span class="token comment">// DOM 还没创建</span>
      <span class="token literal-property property">component</span><span class="token operator">:</span> cur<span class="token punctuation">,</span>
      <span class="token literal-property property">parentFiber</span><span class="token operator">:</span> fiber<span class="token punctuation">,</span>
      <span class="token literal-property property">firstChildFiber</span><span class="token operator">:</span> <span class="token keyword">null</span><span class="token punctuation">,</span>
      <span class="token literal-property property">siblingFiber</span><span class="token operator">:</span> <span class="token keyword">null</span><span class="token punctuation">,</span>
    <span class="token punctuation">&#125;</span><span class="token punctuation">;</span>

    <span class="token comment">// 如果是第一个孩子, 刷新父亲的第一个孩子信息</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>prev<span class="token punctuation">)</span> fiber<span class="token punctuation">.</span>firstChildFiber <span class="token operator">=</span> curFiber<span class="token punctuation">;</span>
    <span class="token comment">// 否则左兄弟的右兄弟就是当前 Fiber</span>
    <span class="token keyword">else</span> prev<span class="token punctuation">.</span>siblingFiber <span class="token operator">=</span> curFiber<span class="token punctuation">;</span>

    <span class="token keyword">return</span> curFiber<span class="token punctuation">;</span>
  <span class="token punctuation">&#125;</span><span class="token punctuation">,</span> <span class="token keyword">null</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span>

<span class="token comment">// 4. 获取下一个孩子</span>
<span class="token keyword">function</span> <span class="token function">getNextFiber</span><span class="token punctuation">(</span><span class="token parameter">fiber</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
  <span class="token comment">// 4.1. DFS 优先找孩子</span>
  <span class="token keyword">if</span> <span class="token punctuation">(</span>fiber<span class="token punctuation">.</span>firstChildFiber<span class="token punctuation">)</span> <span class="token keyword">return</span> fiber<span class="token punctuation">.</span>firstChildFiber<span class="token punctuation">;</span>
  <span class="token comment">// 4.2. 没有孩子找右兄弟</span>
  <span class="token keyword">if</span> <span class="token punctuation">(</span>fiber<span class="token punctuation">.</span>siblingFiber<span class="token punctuation">)</span> <span class="token keyword">return</span> fiber<span class="token punctuation">.</span>siblingFiber<span class="token punctuation">;</span>

  <span class="token comment">// 4.3. 没有兄弟则回溯到父亲节点, 找父亲的右兄弟, 如果没有兄弟就继续回溯</span>
  <span class="token keyword">let</span> grandFiber <span class="token operator">=</span> fiber<span class="token punctuation">.</span>parentFiber<span class="token punctuation">;</span>
  <span class="token keyword">while</span> <span class="token punctuation">(</span>grandFiber<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>grandFiber<span class="token punctuation">.</span>siblingFiber<span class="token punctuation">)</span> <span class="token keyword">return</span> grandFiber<span class="token punctuation">.</span>siblingFiber<span class="token punctuation">;</span>
    grandFiber <span class="token operator">=</span> grandFiber<span class="token punctuation">.</span>parentFiber<span class="token punctuation">;</span>
  <span class="token punctuation">&#125;</span>

  <span class="token comment">// 4.4. 都没有就说明 Fiber 链执行完毕</span>
  <span class="token keyword">return</span> <span class="token keyword">null</span><span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span>

<span class="token comment">// 3. 对于 FC, 他本身不需要渲染, 只需要将他的孩子加入他的父容器就可以</span>
<span class="token keyword">function</span> <span class="token function">processFunctionComponentFiber</span><span class="token punctuation">(</span><span class="token parameter">fiber</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
  <span class="token comment">// 执行函数, 获取组件</span>
  <span class="token keyword">const</span> component <span class="token operator">=</span> fiber<span class="token punctuation">.</span>component<span class="token punctuation">.</span><span class="token function">nodeName</span><span class="token punctuation">(</span>fiber<span class="token punctuation">.</span>component<span class="token punctuation">.</span>props<span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token comment">// 生成子 Fiber, 绑定链表关系</span>
  <span class="token function">processChildFiber</span><span class="token punctuation">(</span>fiber<span class="token punctuation">,</span> <span class="token punctuation">[</span>component<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span>

<span class="token comment">// 2. 对于非 FC</span>
<span class="token keyword">function</span> <span class="token function">processHostFiber</span><span class="token punctuation">(</span><span class="token parameter">fiber</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
  <span class="token comment">// 针对 render 的 根组件特殊 Fiber 的处理</span>
  <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>fiber<span class="token punctuation">.</span>dom<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
    fiber<span class="token punctuation">.</span>dom <span class="token operator">=</span> <span class="token function">createNode</span><span class="token punctuation">(</span>fiber<span class="token punctuation">.</span>component<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token function">patchProps</span><span class="token punctuation">(</span>fiber<span class="token punctuation">.</span>dom<span class="token punctuation">,</span> fiber<span class="token punctuation">.</span>component<span class="token punctuation">.</span>props<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token comment">// 完成同步挂载</span>
    <span class="token comment">// TODO: 未来要修改为异步挂载</span>
    fiber<span class="token punctuation">.</span>parentFiber<span class="token punctuation">.</span>dom<span class="token punctuation">.</span><span class="token function">append</span><span class="token punctuation">(</span>fiber<span class="token punctuation">.</span>dom<span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">&#125;</span>
  <span class="token comment">// 生成子 Fiber, 绑定链表关系</span>
  <span class="token function">processChildFiber</span><span class="token punctuation">(</span>fiber<span class="token punctuation">,</span> fiber<span class="token punctuation">.</span>component<span class="token punctuation">.</span>props<span class="token punctuation">.</span>children<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span>

<span class="token comment">// 判断是不是 FC</span>
<span class="token keyword">function</span> <span class="token function">isFunctionComponent</span><span class="token punctuation">(</span><span class="token parameter">component</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
  <span class="token keyword">return</span> component<span class="token punctuation">.</span>nodeName <span class="token keyword">instanceof</span> <span class="token class-name">Function</span><span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span>

<span class="token comment">// 1. 处理单个 Fiber</span>
<span class="token keyword">function</span> <span class="token function">performFiber</span><span class="token punctuation">(</span><span class="token parameter">fiber</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
  <span class="token comment">// 针对 FC 与 非 FC 分开处理</span>
  <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">isFunctionComponent</span><span class="token punctuation">(</span>fiber<span class="token punctuation">.</span>component<span class="token punctuation">)</span><span class="token punctuation">)</span>
    <span class="token function">processFunctionComponentFiber</span><span class="token punctuation">(</span>fiber<span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token keyword">else</span> <span class="token function">processHostFiber</span><span class="token punctuation">(</span>fiber<span class="token punctuation">)</span><span class="token punctuation">;</span>

  <span class="token comment">// 获取 DFS 序链表中下一元素, 移动指针</span>
  nextFiber <span class="token operator">=</span> <span class="token function">getNextFiber</span><span class="token punctuation">(</span>fiber<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>实现异步挂载 (统一提交)</strong></p><p>我们希望在 Fiber 全部执行完成后再实现节点的挂载, 也就是说在计算全部完成后重新遍历 Fiber 链完成 DOM 操作</p><p>首先删除同步挂载功能</p><pre class="line-numbers language-diff" data-language="diff"><code class="language-diff"><span class="token unchanged"><span class="token prefix unchanged"> </span><span class="token line"> function processHostFiber(fiber) &#123;
</span><span class="token prefix unchanged"> </span><span class="token line">   if (!fiber.dom) &#123;
</span><span class="token prefix unchanged"> </span><span class="token line">     fiber.dom = createNode(fiber.component);
</span><span class="token prefix unchanged"> </span><span class="token line">     patchProps(fiber.dom, fiber.component.props);
</span></span><span class="token deleted-sign deleted"><span class="token prefix deleted">-</span><span class="token line">     fiber.parentFiber.dom.append(fiber.dom);
</span></span><span class="token unchanged"><span class="token prefix unchanged"> </span><span class="token line">   &#125;
</span><span class="token prefix unchanged"> </span><span class="token line">   processChildFiber(fiber, fiber.component.props.children);
</span><span class="token prefix unchanged"> </span><span class="token line"> &#125;
</span></span>
<span class="token deleted-sign deleted"><span class="token prefix deleted">-</span><span class="token line"> function fillNode(node, &#123; nodeName, props: &#123; children &#125; &#125;) &#123;
</span><span class="token prefix deleted">-</span><span class="token line">   if (nodeName === 'TEXT_ELEMENT')
</span><span class="token prefix deleted">-</span><span class="token line">     return (node.data = children.reduce((pre, cur) => pre + cur, ''));
</span><span class="token prefix deleted">-</span><span class="token line">
</span><span class="token prefix deleted">-</span><span class="token line">   children.forEach((childNode) => render(childNode, node));
</span><span class="token prefix deleted">-</span><span class="token line"> &#125;</span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>持久化一个全局的 rootFiber, 用来记录这次 render 的时候的头 Fiber, 用于下次遍历</p><pre class="line-numbers language-diff" data-language="diff"><code class="language-diff"><span class="token inserted-sign inserted"><span class="token prefix inserted">+</span><span class="token line"> let rootFiber = null;
</span></span>
<span class="token unchanged"><span class="token prefix unchanged"> </span><span class="token line"> function render(component, container) &#123;
</span><span class="token prefix unchanged"> </span><span class="token line">   nextFiber = &#123;
</span><span class="token prefix unchanged"> </span><span class="token line">     dom: container,
</span><span class="token prefix unchanged"> </span><span class="token line">     component,
</span><span class="token prefix unchanged"> </span><span class="token line">     parentFiber: null,
</span><span class="token prefix unchanged"> </span><span class="token line">     firstChildFiber: null,
</span><span class="token prefix unchanged"> </span><span class="token line">     siblingFiber: null,
</span><span class="token prefix unchanged"> </span><span class="token line">   &#125;;
</span></span><span class="token inserted-sign inserted"><span class="token prefix inserted">+</span><span class="token line">   // 保存这次 render 的头 Fiber 方便提交的时候再次遍历链表
</span><span class="token prefix inserted">+</span><span class="token line">   rootFiber = nextFiber;
</span></span><span class="token unchanged"><span class="token prefix unchanged"> </span><span class="token line"> &#125;</span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>在全部 Fiber 执行完成后调用提交函数执行全部 DOM</p><pre class="line-numbers language-diff" data-language="diff"><code class="language-diff"><span class="token unchanged"><span class="token prefix unchanged"> </span><span class="token line"> function performFiberLoop(idleDeadline) &#123;
</span><span class="token prefix unchanged"> </span><span class="token line">   while (idleDeadline.timeRemaining() > 1 &amp;&amp; nextFiber) &#123;
</span><span class="token prefix unchanged"> </span><span class="token line">     performFiber(nextFiber);
</span><span class="token prefix unchanged"> </span><span class="token line">   &#125;
</span></span>
<span class="token inserted-sign inserted"><span class="token prefix inserted">+</span><span class="token line">   // 已经没有要处理的 Fiber 了 (Fiber 执行完成 / 当前 Callback 没有任务) &amp;&amp;
</span><span class="token prefix inserted">+</span><span class="token line">   // 当前 render 还没有结束, 不是没有任务的 callback => 提交并重置 rootFiber
</span><span class="token prefix inserted">+</span><span class="token line">   if (!nextFiber &amp;&amp; rootFiber) &#123;
</span><span class="token prefix inserted">+</span><span class="token line">     applySubmit(getNextFiber(rootFiber));
</span><span class="token prefix inserted">+</span><span class="token line">     rootFiber = null;
</span><span class="token prefix inserted">+</span><span class="token line">   &#125;
</span></span>
<span class="token unchanged"><span class="token prefix unchanged"> </span><span class="token line">   requestIdleCallback(performFiberLoop);
</span><span class="token prefix unchanged"> </span><span class="token line"> &#125;</span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>提交的过程是对 Fiber 的第二次遍历, 我们每次提交以 Fiber</p><ul><li>如果当前 Fiber 是 FC: FC 组件本身不渲染节点, 我们直接处理他的子 Fiber. 例如<pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript"><span class="token keyword">const</span> <span class="token function-variable function">TextFC</span> <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">=></span><span class="token punctuation">(</span><span class="token operator">&lt;</span>div<span class="token operator">></span>text<span class="token operator">&lt;</span><span class="token operator">/</span>div<span class="token operator">></span><span class="token punctuation">)</span>
<span class="token operator">&lt;</span>div id<span class="token operator">=</span><span class="token string">"container"</span><span class="token operator">></span><span class="token operator">&lt;</span>TestFC <span class="token operator">/</span><span class="token operator">></span><span class="token operator">&lt;</span><span class="token operator">/</span>div<span class="token operator">></span>
<span class="token comment">// 对应的函数是</span>
React<span class="token punctuation">.</span><span class="token function">createElement</span><span class="token punctuation">(</span>  <span class="token comment">// &lt;- 这个 vDOM 并不会渲染为 DOM</span>
  TextFC<span class="token punctuation">,</span>
  <span class="token punctuation">&#123;</span><span class="token punctuation">&#125;</span><span class="token punctuation">,</span>
  React<span class="token punctuation">.</span><span class="token function">createElement</span><span class="token punctuation">(</span><span class="token string">'div'</span><span class="token punctuation">,</span> <span class="token punctuation">&#123;</span><span class="token punctuation">&#125;</span><span class="token punctuation">,</span> <span class="token string">'text'</span><span class="token punctuation">)</span> <span class="token comment">// &lt;- 我们需要将这个 vDOM 渲染到 container 上</span>
<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li><li>如果当前 Fiber 不是 FC: 我们应该将他的子节点挂载到他的 DOM 上, 如果他本身没有 DOM, 就挂载在他父亲身上(如果父亲也没有, 就继续回溯)</li></ul><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript"><span class="token comment">// 将当前 fiber 中的 DOM 加入最近的有 DOM 的祖先中</span>
<span class="token keyword">function</span> <span class="token function">appendDOM</span><span class="token punctuation">(</span><span class="token parameter">fiber</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
  <span class="token keyword">let</span> containerFiber <span class="token operator">=</span> fiber<span class="token punctuation">.</span>parentFiber<span class="token punctuation">;</span>
  <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token operator">!</span>containerFiber<span class="token punctuation">.</span>dom<span class="token punctuation">)</span> containerFiber <span class="token operator">=</span> containerFiber<span class="token punctuation">.</span>parentFiber<span class="token punctuation">;</span>
  containerFiber<span class="token punctuation">.</span>dom<span class="token punctuation">.</span><span class="token function">append</span><span class="token punctuation">(</span>fiber<span class="token punctuation">.</span>dom<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span>

<span class="token comment">// 切换到下一个 Fiber 并更新指针</span>
<span class="token keyword">function</span> <span class="token function">switchFiber</span><span class="token punctuation">(</span><span class="token parameter">fiber</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
  <span class="token keyword">const</span> nextFiber <span class="token operator">=</span> <span class="token function">getNextFiber</span><span class="token punctuation">(</span>fiber<span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token keyword">return</span> nextFiber <span class="token operator">&amp;&amp;</span> <span class="token function">applySubmit</span><span class="token punctuation">(</span>nextFiber<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span>

<span class="token comment">// 提交挂载</span>
<span class="token keyword">function</span> <span class="token function">applySubmit</span><span class="token punctuation">(</span><span class="token parameter">fiber</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
  <span class="token comment">// 如果是 FC 直接切换处理子节点</span>
  <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">isFunctionComponent</span><span class="token punctuation">(</span>fiber<span class="token punctuation">.</span>component<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token function">switchFiber</span><span class="token punctuation">(</span>fiber<span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token comment">// 如果不是 FC 就将当前 Fiber 挂载起来</span>
  <span class="token function">appendDOM</span><span class="token punctuation">(</span>fiber<span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token comment">// 切换 Fiber</span>
  <span class="token function">switchFiber</span><span class="token punctuation">(</span>fiber<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="实现更新-新增节点">实现更新 (新增节点)</h2><p>更新的基本逻辑是重新渲染一份新的 Fiber 链, 在每一个新创建的 Fiber 上记录这个 Fiber 对应的老 Fiber (alternate Fiber), 对比新老 Fiber 确定更新的具体操作</p><p>例如, 当页面中新增了一个节点时</p><pre class="mermaid">graph LR
    subgraph Fiber
        Fiber1 --> Fiber2 ----> Fiber3
    end
    subgraph newFiber
        newFiber1 --> newFiber2 --> newFiber4 --> newFiber3
    end

    newFiber1 -.alternate.-> Fiber1
    newFiber2 -.alternate.-> Fiber2
    newFiber3 -.alternate.-> Fiber3</pre><p>我们会发现 Fiber 链表中多了一个 <code>newFiber4</code> 并且这个 <code>newFiber4</code> 没有 alternate Fiber, 这就意味着 <code>newFiber4</code> 是一个新增的节点, 我们将其加入即可</p><p><strong>新增变量记录老队列队头</strong></p><p>用户手动调用 <code>React.update()</code> 发起更新, 在更新时我们需要分别记录新链表和老链表的头, 因此我们要创建全局变量记录老链表.</p><p>我们已经实现过</p><ul><li><code>nextFiber</code>: 为实现异步任务调度, 在全局注册的指向<strong>当前要处理的 Fiber</strong></li><li><code>rootFiber</code>: 为实现统一提交, 在全局注册的记录的<strong>正在处理的链表的根 Fiber</strong></li></ul><p>我们定义一个新的 Fiber</p><ul><li><code>currentRootFiber</code>: 表示在这次更新之前的根节点 (即将要被取代的链表的链表头)</li></ul><p>将 <code>rootFiber</code> 改名为 <code>wipRootFiber</code>. 这样我们就有了三个全局变量</p><ul><li><code>nextFiber</code>: 指向当前要挂载/更新的 Fiber</li><li><code>wipRootFiber</code>: 挂载轮次中要挂载的 Fiber 链表的根 Fiber / 更新轮次中新 Fiber 链表的根 Fiber</li><li><code>currentRootFiber</code>: 当前更新轮次中老的链表的根 Fiber</li></ul><p><strong>扩充 Fiber 属性</strong></p><ul><li>新增属性 <code>alternateFiber</code> 记录新 Fiber 对应的老 Fiber. 如果 <code>alternateFiber</code> 存在, 说明是在更新链上的</li><li>新增属性 <code>effectTag</code> 标记统一提交时应该如何处理 Fiber (如果是 <code>placement</code> 表示要新挂载, <code>update</code> 表示 DOM 已经存在, 只需要更新)</li></ul><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript"><span class="token punctuation">&#123;</span>
  dom<span class="token punctuation">,</span>
  component<span class="token punctuation">,</span>
  parentFiber<span class="token punctuation">,</span>
  firstChildFiber<span class="token punctuation">,</span>
  siblingFiber<span class="token punctuation">,</span>
  <span class="token comment">// 新增属性</span>
  alternateFiber<span class="token punctuation">,</span> <span class="token comment">// 新 Fiber 对应的老 Fiber</span>
  <span class="token literal-property property">effectTag</span><span class="token operator">:</span> <span class="token string">'update'</span> <span class="token operator">|</span> <span class="token string">'placement'</span> <span class="token comment">// 统一提交时应该如何处理</span>
<span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>重命名<code>wipRootFiber</code></strong></p><pre class="line-numbers language-diff" data-language="diff"><code class="language-diff"><span class="token deleted-sign deleted"><span class="token prefix deleted">-</span><span class="token line"> let rootFiber = null;
</span></span><span class="token inserted-sign inserted"><span class="token prefix inserted">+</span><span class="token line"> let wipRootFiber = null;
</span></span>
<span class="token unchanged"><span class="token prefix unchanged"> </span><span class="token line"> function render(component, container) &#123;
</span><span class="token prefix unchanged"> </span><span class="token line">   nextFiber = &#123;
</span><span class="token prefix unchanged"> </span><span class="token line">     dom: container,
</span><span class="token prefix unchanged"> </span><span class="token line">     component,
</span><span class="token prefix unchanged"> </span><span class="token line">     parentFiber: null,
</span><span class="token prefix unchanged"> </span><span class="token line">     firstChildFiber: null,
</span><span class="token prefix unchanged"> </span><span class="token line">     siblingFiber: null,
</span><span class="token prefix unchanged"> </span><span class="token line">   &#125;;
</span></span><span class="token deleted-sign deleted"><span class="token prefix deleted">-</span><span class="token line">   rootFiber = nextFiber;
</span></span><span class="token inserted-sign inserted"><span class="token prefix inserted">+</span><span class="token line">   wipRootFiber = nextFiber;
</span></span><span class="token unchanged"><span class="token prefix unchanged"> </span><span class="token line"> &#125;</span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-diff" data-language="diff"><code class="language-diff"><span class="token unchanged"><span class="token prefix unchanged"> </span><span class="token line"> function performFiberLoop(idleDeadline) &#123;
</span><span class="token prefix unchanged"> </span><span class="token line">   while (idleDeadline.timeRemaining() > 1 &amp;&amp; nextFiber) &#123;
</span><span class="token prefix unchanged"> </span><span class="token line">     performFiber(nextFiber);
</span><span class="token prefix unchanged"> </span><span class="token line">   &#125;
</span></span>
<span class="token deleted-sign deleted"><span class="token prefix deleted">-</span><span class="token line">   if (!nextFiber &amp;&amp; rootFiber) &#123;
</span><span class="token prefix deleted">-</span><span class="token line">     applySubmit(getNextFiber(rootFiber));
</span><span class="token prefix deleted">-</span><span class="token line">     rootFiber = null;
</span><span class="token prefix deleted">-</span><span class="token line">   &#125;
</span></span>
<span class="token inserted-sign inserted"><span class="token prefix inserted">+</span><span class="token line">   if (!nextFiber &amp;&amp; wipRootFiber) &#123;
</span><span class="token prefix inserted">+</span><span class="token line">     applySubmit(getNextFiber(wipRootFiber));
</span><span class="token prefix inserted">+</span><span class="token line">     currentRootFiber = wipRootFiber; // 提交完成后刷新上一轮的 Root Fiber
</span><span class="token prefix inserted">+</span><span class="token line">     wipRootFiber = null;
</span><span class="token prefix inserted">+</span><span class="token line">   &#125;
</span></span>
<span class="token unchanged"><span class="token prefix unchanged"> </span><span class="token line">   requestIdleCallback(performFiberLoop);
</span><span class="token prefix unchanged"> </span><span class="token line"> &#125;</span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>构造新的 Fiber</strong></p><p>调用函数, 构造一个新的 Fiber 链的头, 将这个头设为下一个需要执行的 Fiber</p><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript"><span class="token comment">// 存储上一轮 Fiber 头</span>
<span class="token keyword">let</span> currentRootFiber <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">;</span>
<span class="token keyword">function</span> <span class="token function">update</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
  <span class="token comment">// 如果还没有挂载, 就直接返回</span>
  <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>currentRootFiber<span class="token punctuation">)</span> <span class="token keyword">return</span><span class="token punctuation">;</span>

  <span class="token comment">// 新建 Fiber 头, 新 Fiber 头继承上一轮的 Fiber 头属性, 同时加入 alternateFiber 表示这个新 Fiber 对应的老 Fiber</span>
  wipRootFiber <span class="token operator">=</span> <span class="token punctuation">&#123;</span>
    <span class="token operator">...</span>currentRootFiber<span class="token punctuation">,</span>
    <span class="token literal-property property">alternateFiber</span><span class="token operator">:</span> currentRootFiber<span class="token punctuation">,</span>
  <span class="token punctuation">&#125;</span><span class="token punctuation">;</span>

  <span class="token comment">// 刷新下一个需要执行的 Fiber 等待 FiberLoop 的调用</span>
  nextFiber <span class="token operator">=</span> wipRootFiber<span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>对于仅有新节点增加的情况, 统一提交的时候页面会新增 Fiber 链表中新加入的节点</p><h2 id="实现更新-同类型节点更新">实现更新 (同类型节点更新)</h2><p>当一个新 Fiber 存在老 Fiber 的时候我们需要对其 DOM 更新. 我们无法修改 DOM 的 Node Name, 所以我们只对同类型节点做更新.</p><p>更新的时候考虑三个属性:</p><ul><li><code>nodeName</code>: 保证相同, 无需更新</li><li><code>props</code>: 需要更新</li><li><code>children</code>: 无需在本轮次更新, 因为下一个 Fiber 就是当前 Fiber 的孩子, 孩子们会在之后的 Fiber 处理中完成更新. 这与 Vue 的处理逻辑不同, Vue 在更新元素的时候要递归处理子元素, 但是因为 React 是链式处理, 已经将 DFS 转换为一条链. 因此我们只需要聚焦节点, 关心当前节点的变换</li></ul><p>因此在更新时, 我们只需要考虑 <code>props</code> 的更新 (或者说 React 对 Fiber 的更新是 shadow 的)</p><p><strong>实现同类节点判定</strong></p><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript"><span class="token keyword">function</span> <span class="token function">isSameType</span><span class="token punctuation">(</span><span class="token parameter">component<span class="token punctuation">,</span> alternateComponent</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
  <span class="token keyword">return</span> component<span class="token punctuation">.</span>nodeName <span class="token operator">===</span> alternateComponent<span class="token operator">?.</span>nodeName<span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p><strong>实现节点更新任务标注</strong></p><p>创建新根组件 Fiber 后, 我们还需要修改子组件 Fiber 的实现 (将 <code>processChildFiber</code> 改名为 <code>reconcileChildren</code> 扩充功能).</p><pre class="line-numbers language-diff" data-language="diff"><code class="language-diff"><span class="token deleted-sign deleted"><span class="token prefix deleted">-</span><span class="token line"> function processChildFiber(fiber, children) &#123;
</span></span><span class="token inserted-sign inserted"><span class="token prefix inserted">+</span><span class="token line"> function reconcileChildren(fiber, children) &#123;
</span></span><span class="token unchanged"><span class="token prefix unchanged"> </span><span class="token line">   if (fiber.component.nodeName === 'TEXT_ELEMENT') return;
</span></span>
<span class="token inserted-sign inserted"><span class="token prefix inserted">+</span><span class="token line">   // alternateFiber 是父 fiber 的第一个孩子, 将来将作为 cur 对应的 Fiber 同步步进
</span><span class="token prefix inserted">+</span><span class="token line">   let alternateFiber = fiber?.alternateFiber?.firstChildFiber;
</span></span>
<span class="token unchanged"><span class="token prefix unchanged"> </span><span class="token line">   children.reduce((prev, cur) => &#123;
</span><span class="token prefix unchanged"> </span><span class="token line">     const curFiber = &#123;
</span><span class="token prefix unchanged"> </span><span class="token line">       dom: null,
</span><span class="token prefix unchanged"> </span><span class="token line">       component: cur,
</span><span class="token prefix unchanged"> </span><span class="token line">       parentFiber: fiber,
</span><span class="token prefix unchanged"> </span><span class="token line">       firstChildFiber: null,
</span><span class="token prefix unchanged"> </span><span class="token line">       siblingFiber: null,
</span></span><span class="token inserted-sign inserted"><span class="token prefix inserted">+</span><span class="token line">       effectTag: null,
</span></span><span class="token unchanged"><span class="token prefix unchanged"> </span><span class="token line">     &#125;;
</span></span>
<span class="token inserted-sign inserted"><span class="token prefix inserted">+</span><span class="token line">     // 老 Fiber 存在, 说明是更新, 这里我们处理同类型更新
</span><span class="token prefix inserted">+</span><span class="token line">     if (alternateFiber &amp;&amp; isSameType(cur, alternateFiber.component)) &#123;
</span><span class="token prefix inserted">+</span><span class="token line">       curFiber.dom = alternateFiber.dom;
</span><span class="token prefix inserted">+</span><span class="token line">       curFiber.effectTag = 'update';
</span><span class="token prefix inserted">+</span><span class="token line">       curFiber.alternateFiber = alternateFiber;
</span><span class="token prefix inserted">+</span><span class="token line">     // 老 Fiber 不存在, 要么是不同类型, 要么是在挂载阶段, 要么是更新出了全新节点
</span><span class="token prefix inserted">+</span><span class="token line">     &#125; else &#123;
</span><span class="token prefix inserted">+</span><span class="token line">       curFiber.effectTag = 'placement';
</span><span class="token prefix inserted">+</span><span class="token line">     &#125;
</span></span>
<span class="token unchanged"><span class="token prefix unchanged"> </span><span class="token line">     if (!prev) fiber.firstChildFiber = curFiber;
</span><span class="token prefix unchanged"> </span><span class="token line">     else prev.siblingFiber = curFiber;
</span></span>

<span class="token inserted-sign inserted"><span class="token prefix inserted">+</span><span class="token line">     // 如果 alternate Fiber 存在, 那么切换 alternate Fiber 使其与 cur 的切换一致
</span><span class="token prefix inserted">+</span><span class="token line">     if (alternateFiber) alternateFiber = alternateFiber?.siblingFiber;
</span></span>
<span class="token unchanged"><span class="token prefix unchanged"> </span><span class="token line">     return curFiber;
</span><span class="token prefix unchanged"> </span><span class="token line">   &#125;, null);
</span><span class="token prefix unchanged"> </span><span class="token line"> &#125;</span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>修改函数调用</p><pre class="line-numbers language-diff" data-language="diff"><code class="language-diff"><span class="token unchanged"><span class="token prefix unchanged"> </span><span class="token line"> function processFunctionComponentFiber(fiber) &#123;
</span><span class="token prefix unchanged"> </span><span class="token line">   const component = fiber.component.nodeName(fiber.component.props);
</span></span><span class="token deleted-sign deleted"><span class="token prefix deleted">-</span><span class="token line">   processChildFiber(fiber, [component]);
</span></span><span class="token inserted-sign inserted"><span class="token prefix inserted">+</span><span class="token line">   reconcileChildren(fiber, [component]);
</span></span><span class="token unchanged"><span class="token prefix unchanged"> </span><span class="token line"> &#125;
</span></span>
<span class="token unchanged"><span class="token prefix unchanged"> </span><span class="token line"> function processHostFiber(fiber) &#123;
</span><span class="token prefix unchanged"> </span><span class="token line">   if (!fiber.dom) &#123;
</span><span class="token prefix unchanged"> </span><span class="token line">     fiber.dom = createNode(fiber.component);
</span><span class="token prefix unchanged"> </span><span class="token line">     patchProps(fiber.dom, fiber.component.props);
</span><span class="token prefix unchanged"> </span><span class="token line">   &#125;
</span></span><span class="token deleted-sign deleted"><span class="token prefix deleted">-</span><span class="token line">   processChildFiber(fiber, fiber.component.props.children);
</span></span><span class="token inserted-sign inserted"><span class="token prefix inserted">+</span><span class="token line">   reconcileChildren(fiber, fiber.component.props.children);
</span></span><span class="token unchanged"><span class="token prefix unchanged"> </span><span class="token line"> &#125;</span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>实现属性更新</strong></p><p>在统一提交时我们只需要更新节点上的 props, 所以重写 patchProps</p><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript"><span class="token keyword">function</span> <span class="token function">removeProps</span><span class="token punctuation">(</span><span class="token parameter">node<span class="token punctuation">,</span> k<span class="token punctuation">,</span> v</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
  <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">isEvent</span><span class="token punctuation">(</span>k<span class="token punctuation">)</span><span class="token punctuation">)</span> node<span class="token punctuation">.</span><span class="token function">removeEventListener</span><span class="token punctuation">(</span><span class="token function">getEventName</span><span class="token punctuation">(</span>k<span class="token punctuation">)</span><span class="token punctuation">,</span> v<span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token keyword">else</span> node<span class="token punctuation">[</span>k<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span>

<span class="token keyword">function</span> <span class="token function">patchProps</span><span class="token punctuation">(</span><span class="token parameter">node<span class="token punctuation">,</span> props<span class="token punctuation">,</span> oldProps <span class="token operator">=</span> <span class="token punctuation">&#123;</span><span class="token punctuation">&#125;</span></span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
  <span class="token comment">// 以默认参数提交老的 props</span>
  <span class="token keyword">const</span> oldKey <span class="token operator">=</span> Object<span class="token punctuation">.</span><span class="token function">keys</span><span class="token punctuation">(</span>oldProps<span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token keyword">const</span> newKey <span class="token operator">=</span> Object<span class="token punctuation">.</span><span class="token function">keys</span><span class="token punctuation">(</span>props<span class="token punctuation">)</span><span class="token punctuation">;</span>

  <span class="token comment">// 对于全新的 key 直接绑定</span>
  newKey
    <span class="token punctuation">.</span><span class="token function">filter</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token parameter">k</span><span class="token punctuation">)</span> <span class="token operator">=></span> k <span class="token operator">!==</span> <span class="token string">'children'</span> <span class="token operator">&amp;&amp;</span> <span class="token operator">!</span>oldKey<span class="token punctuation">.</span><span class="token function">includes</span><span class="token punctuation">(</span>k<span class="token punctuation">)</span><span class="token punctuation">)</span>
    <span class="token punctuation">.</span><span class="token function">forEach</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token parameter">k</span><span class="token punctuation">)</span> <span class="token operator">=></span> <span class="token function">bindProps</span><span class="token punctuation">(</span>node<span class="token punctuation">,</span> k<span class="token punctuation">,</span> props<span class="token punctuation">[</span>k<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

  <span class="token comment">// 部队不存在的 key 直接删除</span>
  oldKey
    <span class="token punctuation">.</span><span class="token function">filter</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token parameter">k</span><span class="token punctuation">)</span> <span class="token operator">=></span> k <span class="token operator">!==</span> <span class="token string">'children'</span> <span class="token operator">&amp;&amp;</span> <span class="token operator">!</span>newKey<span class="token punctuation">.</span><span class="token function">includes</span><span class="token punctuation">(</span>k<span class="token punctuation">)</span><span class="token punctuation">)</span>
    <span class="token punctuation">.</span><span class="token function">forEach</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token parameter">k</span><span class="token punctuation">)</span> <span class="token operator">=></span> <span class="token function">removeProps</span><span class="token punctuation">(</span>node<span class="token punctuation">,</span> k<span class="token punctuation">,</span> oldProps<span class="token punctuation">[</span>k<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

  <span class="token comment">// 对于有变更的 key 移除再新增</span>
  newKey
    <span class="token punctuation">.</span><span class="token function">filter</span><span class="token punctuation">(</span>
      <span class="token punctuation">(</span><span class="token parameter">k</span><span class="token punctuation">)</span> <span class="token operator">=></span> k <span class="token operator">!==</span> <span class="token string">'children'</span> <span class="token operator">&amp;&amp;</span> oldKey<span class="token punctuation">.</span><span class="token function">includes</span><span class="token punctuation">(</span>k<span class="token punctuation">)</span> <span class="token operator">&amp;&amp;</span> oldProps<span class="token punctuation">[</span>k<span class="token punctuation">]</span> <span class="token operator">!==</span> props<span class="token punctuation">[</span>k<span class="token punctuation">]</span>
    <span class="token punctuation">)</span>
    <span class="token punctuation">.</span><span class="token function">forEach</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token parameter">k</span><span class="token punctuation">)</span> <span class="token operator">=></span> <span class="token punctuation">&#123;</span>
      <span class="token function">removeProps</span><span class="token punctuation">(</span>node<span class="token punctuation">,</span> k<span class="token punctuation">,</span> oldProps<span class="token punctuation">[</span>k<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
      <span class="token function">bindProps</span><span class="token punctuation">(</span>node<span class="token punctuation">,</span> k<span class="token punctuation">,</span> props<span class="token punctuation">[</span>k<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">&#125;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>在统一提交时候根据 <code>effectTag</code> 判断是要挂载还是只更新</p><pre class="line-numbers language-diff" data-language="diff"><code class="language-diff"><span class="token unchanged"><span class="token prefix unchanged"> </span><span class="token line"> function applySubmit(fiber) &#123;
</span><span class="token prefix unchanged"> </span><span class="token line">   if (isFunctionComponent(fiber.component)) return switchFiber(fiber);
</span><span class="token prefix unchanged"> </span><span class="token line">   appendDOM(fiber);
</span><span class="token prefix unchanged"> </span><span class="token line">   switchFiber(fiber);
</span><span class="token prefix unchanged"> </span><span class="token line"> &#125;
</span></span>
<span class="token unchanged"><span class="token prefix unchanged"> </span><span class="token line"> function applySubmit(fiber) &#123;
</span><span class="token prefix unchanged"> </span><span class="token line">   if (isFunctionComponent(fiber.component)) return switchFiber(fiber);
</span></span>
<span class="token deleted-sign deleted"><span class="token prefix deleted">-</span><span class="token line">   appendDOM(fiber);
</span></span>
<span class="token inserted-sign inserted"><span class="token prefix inserted">+</span><span class="token line">   // 如果是挂载阶段或者是更新全新节点, DOM
</span><span class="token prefix inserted">+</span><span class="token line">   if (fiber.effectTag === 'placement') &#123;
</span><span class="token prefix inserted">+</span><span class="token line">     appendDOM(fiber);
</span><span class="token prefix inserted">+</span><span class="token line">   // 否则只更新节点上的属性
</span><span class="token prefix inserted">+</span><span class="token line">   &#125; else if (fiber.effectTag === 'update') &#123;
</span><span class="token prefix inserted">+</span><span class="token line">     patchProps(
</span><span class="token prefix inserted">+</span><span class="token line">       fiber.dom,
</span><span class="token prefix inserted">+</span><span class="token line">       fiber.component.props,
</span><span class="token prefix inserted">+</span><span class="token line">       fiber?.alternateFiber?.component?.props
</span><span class="token prefix inserted">+</span><span class="token line">     );
</span><span class="token prefix inserted">+</span><span class="token line">   &#125;
</span></span>
<span class="token unchanged"><span class="token prefix unchanged"> </span><span class="token line">   switchFiber(fiber);
</span><span class="token prefix unchanged"> </span><span class="token line"> &#125;</span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="实现更新-节点移除">实现更新 (节点移除)</h2><p>如果老 Fiber 链中没有被任何 newFiber 的 <code>alternateFiber</code> 指向, 那么这个元素就应该被删除了 (例如图中的 <code>Fiber2</code>)</p><p>当一个元素应该被删除时, 我们会将元素压入 <code>deletions</code> 数组, 在统一提交时统一删除. (创建 <code>deletions</code> 数组而不是在统一提交是查找是因为在新链表上已经找不到待删除的 oldFiber 了)</p><pre class="mermaid">graph LR
    subgraph Fiber
        Fiber1 --> Fiber2 --> Fiber3
    end
    subgraph newFiber
        newFiber1 ----> newFiber3
    end

    newFiber1 -.alternate.-> Fiber1
    newFiber3 -.alternate.-> Fiber3</pre><p><strong>创建 <code>deletion</code> 并在统一提交时删除</strong></p><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript"><span class="token keyword">const</span> deletions <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">;</span> <span class="token comment">// 等待删除元素</span>

<span class="token comment">// 删除元素</span>
<span class="token keyword">function</span> <span class="token function">applyDeletions</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
  <span class="token keyword">while</span> <span class="token punctuation">(</span>deletions<span class="token punctuation">.</span>length<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
    <span class="token keyword">const</span> fiber <span class="token operator">=</span> deletions<span class="token punctuation">.</span><span class="token function">shift</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span><span class="token function">isFunctionComponent</span><span class="token punctuation">(</span>fiber<span class="token punctuation">.</span>component<span class="token punctuation">)</span><span class="token punctuation">)</span> fiber<span class="token punctuation">.</span>dom<span class="token punctuation">.</span><span class="token function">remove</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">else</span> fiber<span class="token punctuation">.</span>childrenFiber<span class="token punctuation">.</span><span class="token function">forEach</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token parameter">d</span><span class="token punctuation">)</span> <span class="token operator">=></span> deletions<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span>d<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">&#125;</span>
<span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>在统一提交时删除</p><pre class="line-numbers language-diff" data-language="diff"><code class="language-diff">function performFiberLoop(idleDeadline) &#123;
<span class="token unchanged"><span class="token prefix unchanged"> </span><span class="token line"> while (idleDeadline.timeRemaining() > 1 &amp;&amp; nextFiber) &#123;
</span><span class="token prefix unchanged"> </span><span class="token line">   performFiber(nextFiber);
</span><span class="token prefix unchanged"> </span><span class="token line"> &#125;
</span></span>
<span class="token unchanged"><span class="token prefix unchanged"> </span><span class="token line"> if (!nextFiber &amp;&amp; wipRootFiber) &#123;
</span></span><span class="token inserted-sign inserted"><span class="token prefix inserted">+</span><span class="token line">   applyDeletions();
</span></span><span class="token unchanged"><span class="token prefix unchanged"> </span><span class="token line">   applySubmit(getNextFiber(wipRootFiber));
</span><span class="token prefix unchanged"> </span><span class="token line">   currentRootFiber = wipRootFiber;
</span><span class="token prefix unchanged"> </span><span class="token line">   wipRootFiber = null;
</span><span class="token prefix unchanged"> </span><span class="token line"> &#125;
</span></span>
<span class="token unchanged"><span class="token prefix unchanged"> </span><span class="token line"> requestIdleCallback(performFiberLoop);
</span></span>&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>建立老 Fiber 到新 Fiber 的映射</strong></p><p>扩充 Fiber 属性</p><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript"><span class="token punctuation">&#123;</span>
  dom<span class="token punctuation">,</span>
  component<span class="token punctuation">,</span>
  parentFiber<span class="token punctuation">,</span>
  firstChildFiber<span class="token punctuation">,</span>
  siblingFiber<span class="token punctuation">,</span>
  alternateFiber<span class="token punctuation">,</span>
  <span class="token literal-property property">effectTag</span><span class="token operator">:</span> <span class="token string">'update'</span> <span class="token operator">|</span> <span class="token string">'placement'</span>
  <span class="token comment">// 新的 Fiber 属性</span>
  <span class="token literal-property property">childrenFiber</span><span class="token operator">:</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token comment">// 记录当前 Fiber 的孩子 Fiber (方便检索当前 Fiber 上那些子 Fiber 没有对应元素)</span>
  newFiber<span class="token punctuation">,</span> <span class="token comment">// 指向当前 Fiber 对应的新 Fiber (如果存在)</span>
<span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>完成这两个属性的构建</p><pre class="line-numbers language-diff" data-language="diff"><code class="language-diff"><span class="token unchanged"><span class="token prefix unchanged"> </span><span class="token line"> function update() &#123;
</span><span class="token prefix unchanged"> </span><span class="token line">   if (!currentRootFiber) return;
</span></span>
<span class="token unchanged"><span class="token prefix unchanged"> </span><span class="token line">   wipRootFiber = &#123;
</span><span class="token prefix unchanged"> </span><span class="token line">     ...currentRootFiber,
</span></span><span class="token inserted-sign inserted"><span class="token prefix inserted">+</span><span class="token line">     childrenFiber: [],
</span></span><span class="token unchanged"><span class="token prefix unchanged"> </span><span class="token line">     alternateFiber: currentRootFiber,
</span><span class="token prefix unchanged"> </span><span class="token line">   &#125;;
</span></span>
<span class="token inserted-sign inserted"><span class="token prefix inserted">+</span><span class="token line">   currentRootFiber.newFiber = wipRootFiber;
</span></span>
<span class="token unchanged"><span class="token prefix unchanged"> </span><span class="token line">   nextFiber = wipRootFiber;
</span><span class="token prefix unchanged"> </span><span class="token line"> &#125;</span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>在 <code>reconcileChildren</code> 的时候实现删除元素收集</p><pre class="line-numbers language-diff" data-language="diff"><code class="language-diff"><span class="token unchanged"><span class="token prefix unchanged"> </span><span class="token line"> function reconcileChildren(fiber, children) &#123;
</span><span class="token prefix unchanged"> </span><span class="token line">   if (fiber.component.nodeName === 'TEXT_ELEMENT') return;
</span></span>
<span class="token unchanged"><span class="token prefix unchanged"> </span><span class="token line">   let alternateFiber = fiber?.alternateFiber?.firstChildFiber;
</span></span>
<span class="token unchanged"><span class="token prefix unchanged"> </span><span class="token line">   children.reduce((prev, cur) => &#123;
</span><span class="token prefix unchanged"> </span><span class="token line">     const curFiber = &#123;
</span><span class="token prefix unchanged"> </span><span class="token line">       dom: null,
</span><span class="token prefix unchanged"> </span><span class="token line">       component: cur,
</span><span class="token prefix unchanged"> </span><span class="token line">       parentFiber: fiber,
</span><span class="token prefix unchanged"> </span><span class="token line">       firstChildFiber: null,
</span><span class="token prefix unchanged"> </span><span class="token line">       siblingFiber: null,
</span><span class="token prefix unchanged"> </span><span class="token line">       effectTag: null,
</span></span><span class="token inserted-sign inserted"><span class="token prefix inserted">+</span><span class="token line">       childrenFiber: [],
</span><span class="token prefix inserted">+</span><span class="token line">       newFiber: null,
</span></span><span class="token unchanged"><span class="token prefix unchanged"> </span><span class="token line">     &#125;;
</span></span>
<span class="token deleted-sign deleted"><span class="token prefix deleted">-</span><span class="token line">     if (alternateFiber &amp;&amp; isSameType(cur, alternateFiber.component)) &#123;
</span></span><span class="token inserted-sign inserted"><span class="token prefix inserted">+</span><span class="token line">     if (alternateFiber) &#123;
</span><span class="token prefix inserted">+</span><span class="token line">       // 相同类型依然执行更新
</span><span class="token prefix inserted">+</span><span class="token line">       if (isSameType(cur, alternateFiber.component)) &#123;
</span></span><span class="token unchanged"><span class="token prefix unchanged"> </span><span class="token line">         curFiber.dom = alternateFiber.dom;
</span><span class="token prefix unchanged"> </span><span class="token line">         curFiber.effectTag = 'update';
</span><span class="token prefix unchanged"> </span><span class="token line">         curFiber.alternateFiber = alternateFiber;
</span></span><span class="token inserted-sign inserted"><span class="token prefix inserted">+</span><span class="token line">         // 新增对 newFiber 的映射
</span><span class="token prefix inserted">+</span><span class="token line">         alternateFiber.newFiber = curFiber;
</span><span class="token prefix inserted">+</span><span class="token line">       &#125;
</span></span><span class="token unchanged"><span class="token prefix unchanged"> </span><span class="token line">     &#125; else &#123;
</span><span class="token prefix unchanged"> </span><span class="token line">       curFiber.effectTag = 'placement';
</span><span class="token prefix unchanged"> </span><span class="token line">     &#125;
</span></span>
<span class="token unchanged"><span class="token prefix unchanged"> </span><span class="token line">     if (!prev) fiber.firstChildFiber = curFiber;
</span><span class="token prefix unchanged"> </span><span class="token line">     else prev.siblingFiber = curFiber;
</span></span>
<span class="token unchanged"><span class="token prefix unchanged"> </span><span class="token line">     if (alternateFiber) alternateFiber = alternateFiber?.siblingFiber;
</span></span>
<span class="token inserted-sign inserted"><span class="token prefix inserted">+</span><span class="token line">     // 收集子元素
</span><span class="token prefix inserted">+</span><span class="token line">     fiber.childrenFiber.push(curFiber);
</span></span>
<span class="token unchanged"><span class="token prefix unchanged"> </span><span class="token line">     return curFiber;
</span><span class="token prefix unchanged"> </span><span class="token line">   &#125;, null);
</span></span>
<span class="token inserted-sign inserted"><span class="token prefix inserted">+</span><span class="token line">   // 如果处于更新模式, 遍历子元素, 找到老 Fiber 的子 Fiber 中没有对应新 Fibber 的加入删除列表
</span><span class="token prefix inserted">+</span><span class="token line">   if (fiber.alternateFiber) &#123;
</span><span class="token prefix inserted">+</span><span class="token line">     fiber.alternateFiber.childrenFiber.forEach(
</span><span class="token prefix inserted">+</span><span class="token line">       (d) => !d.newFiber &amp;&amp; deletions.push(d)
</span><span class="token prefix inserted">+</span><span class="token line">     );
</span><span class="token prefix inserted">+</span><span class="token line">   &#125;
</span></span><span class="token unchanged"><span class="token prefix unchanged"> </span><span class="token line"> &#125;</span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="实现更新-不同类型节点">实现更新 (不同类型节点)</h2><p>不同节点之间无法更新, 实际上是做了删除然后新增的操作</p><pre class="line-numbers language-diff" data-language="diff"><code class="language-diff"><span class="token unchanged"><span class="token prefix unchanged"> </span><span class="token line"> function reconcileChildren(fiber, children) &#123;
</span><span class="token prefix unchanged"> </span><span class="token line">   if (fiber.component.nodeName === 'TEXT_ELEMENT') return;
</span></span>
<span class="token unchanged"><span class="token prefix unchanged"> </span><span class="token line">   let alternateFiber = fiber?.alternateFiber?.firstChildFiber;
</span></span>
<span class="token unchanged"><span class="token prefix unchanged"> </span><span class="token line">   children.reduce((prev, cur) => &#123;
</span><span class="token prefix unchanged"> </span><span class="token line">     const curFiber = &#123;
</span><span class="token prefix unchanged"> </span><span class="token line">       dom: null,
</span><span class="token prefix unchanged"> </span><span class="token line">       component: cur,
</span><span class="token prefix unchanged"> </span><span class="token line">       parentFiber: fiber,
</span><span class="token prefix unchanged"> </span><span class="token line">       firstChildFiber: null,
</span><span class="token prefix unchanged"> </span><span class="token line">       siblingFiber: null,
</span><span class="token prefix unchanged"> </span><span class="token line">       effectTag: null,
</span><span class="token prefix unchanged"> </span><span class="token line">       childrenFiber: [],
</span><span class="token prefix unchanged"> </span><span class="token line">       newFiber: null,
</span><span class="token prefix unchanged"> </span><span class="token line">     &#125;;
</span></span>
<span class="token unchanged"><span class="token prefix unchanged"> </span><span class="token line">     if (alternateFiber) &#123;
</span><span class="token prefix unchanged"> </span><span class="token line">       if (isSameType(cur, alternateFiber.component)) &#123;
</span><span class="token prefix unchanged"> </span><span class="token line">         curFiber.dom = alternateFiber.dom;
</span><span class="token prefix unchanged"> </span><span class="token line">         curFiber.effectTag = 'update';
</span><span class="token prefix unchanged"> </span><span class="token line">         curFiber.alternateFiber = alternateFiber;
</span><span class="token prefix unchanged"> </span><span class="token line">         alternateFiber.newFiber = curFiber;
</span></span><span class="token inserted-sign inserted"><span class="token prefix inserted">+</span><span class="token line">       // 不同类型的更新元素: 删除, 然后将当前 Fiber 标记为新增
</span><span class="token prefix inserted">+</span><span class="token line">       &#125; else &#123;
</span><span class="token prefix inserted">+</span><span class="token line">         deletions.push(alternateFiber);
</span><span class="token prefix inserted">+</span><span class="token line">         curFiber.effectTag = 'placement';
</span><span class="token prefix inserted">+</span><span class="token line">       &#125;
</span></span><span class="token unchanged"><span class="token prefix unchanged"> </span><span class="token line">     &#125; else &#123;
</span><span class="token prefix unchanged"> </span><span class="token line">       curFiber.effectTag = 'placement';
</span><span class="token prefix unchanged"> </span><span class="token line">     &#125;
</span></span>
<span class="token unchanged"><span class="token prefix unchanged"> </span><span class="token line">     if (!prev) fiber.firstChildFiber = curFiber;
</span><span class="token prefix unchanged"> </span><span class="token line">     else prev.siblingFiber = curFiber;
</span></span>
<span class="token unchanged"><span class="token prefix unchanged"> </span><span class="token line">     if (alternateFiber) alternateFiber = alternateFiber?.siblingFiber;
</span></span>
<span class="token unchanged"><span class="token prefix unchanged"> </span><span class="token line">     fiber.childrenFiber.push(curFiber);
</span></span>
<span class="token unchanged"><span class="token prefix unchanged"> </span><span class="token line">     return curFiber;
</span><span class="token prefix unchanged"> </span><span class="token line">   &#125;, null);
</span></span>
<span class="token unchanged"><span class="token prefix unchanged"> </span><span class="token line">   if (fiber.alternateFiber) &#123;
</span><span class="token prefix unchanged"> </span><span class="token line">     fiber.alternateFiber.childrenFiber.forEach(
</span><span class="token prefix unchanged"> </span><span class="token line">       (d) => !d.newFiber &amp;&amp; deletions.push(d)
</span><span class="token prefix unchanged"> </span><span class="token line">     );
</span><span class="token prefix unchanged"> </span><span class="token line">   &#125;
</span><span class="token prefix unchanged"> </span><span class="token line"> &#125;</span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="将更新粒度缩小为组件">将更新粒度缩小为组件</h2><p>之前 update 的使用方法为</p><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript"><span class="token keyword">const</span> <span class="token function">demoFC</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=></span> <span class="token punctuation">&#123;</span>
  <span class="token keyword">const</span> <span class="token function-variable function">handleChange</span> <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=></span> <span class="token punctuation">&#123;</span>
    num <span class="token operator">+=</span> <span class="token number">1</span>
    React<span class="token punctuation">.</span><span class="token function">update</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">&#125;</span>
<span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>此时我们执行 update 会将整个页面刷新一遍. 我们希望实现调用 <code>update</code> 时仅对当前组件做刷新</p><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript"><span class="token keyword">const</span> <span class="token function">demoFC</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=></span> <span class="token punctuation">&#123;</span>
  <span class="token keyword">const</span> update <span class="token operator">=</span> React<span class="token punctuation">.</span><span class="token function">update</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token keyword">const</span> <span class="token function-variable function">handleChange</span> <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=></span> <span class="token punctuation">&#123;</span>
    num <span class="token operator">+=</span> <span class="token number">1</span>
    <span class="token function">update</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">&#125;</span>
<span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>实现思路:</p><ul><li>向函数暴露一个 <code>update</code> 工厂函数, 通过闭包存储当前正在调用的组件对应的 Fiber. 从而实现在调用 <code>update</code> 时找到调用者</li><li>在调用 update 的时候将 <code>currentRootFiber</code> 设置为调用 <code>update()</code> 的组件, 将 <code>wipRootFiber</code> 也同步为这个组件</li><li>由于 <code>currentRootFiber</code> 不再是根组件, 当 currentRootFiber 的后代 Fiber 全部遍历结束后, 我们应该立即停止, 而不是遍历 <code>currentRootFiber</code> 的右兄弟</li></ul><p><strong>实现 <code>update()</code></strong></p><p>我们知道组件函数 (包括 <code>update = React.update()</code>) 会在构造的时候被调用, 构造的时候 <code>nextFiber</code> 恰好是当前组件的 Fiber, 因此直接用闭包保存 <code>nextFiber</code></p><pre class="line-numbers language-diff" data-language="diff"><code class="language-diff"><span class="token unchanged"><span class="token prefix unchanged"> </span><span class="token line"> function update() &#123;
</span></span><span class="token inserted-sign inserted"><span class="token prefix inserted">+</span><span class="token line">   const currentFiber = nextFiber;
</span><span class="token prefix inserted">+</span><span class="token line">   return () => &#123;
</span><span class="token prefix inserted">+</span><span class="token line">     // 新 Fiber 链表的头不再是上次处理的头 Fiber
</span><span class="token prefix inserted">+</span><span class="token line">     currentRootFiber = currentFiber;
</span></span><span class="token unchanged"><span class="token prefix unchanged"> </span><span class="token line">     wipRootFiber = &#123;
</span><span class="token prefix unchanged"> </span><span class="token line">       ...currentRootFiber,
</span><span class="token prefix unchanged"> </span><span class="token line">       alternateFiber: currentRootFiber,
</span><span class="token prefix unchanged"> </span><span class="token line">       childrenFiber: [],
</span><span class="token prefix unchanged"> </span><span class="token line">     &#125;;
</span></span><span class="token inserted-sign inserted"><span class="token prefix inserted">+</span><span class="token line">     nextFiber = wipRootFiber;
</span><span class="token prefix inserted">+</span><span class="token line">   &#125;;
</span></span><span class="token deleted-sign deleted"><span class="token prefix deleted">-</span><span class="token line">   currentRootFiber.newFiber = wipRootFiber;
</span><span class="token prefix deleted">-</span><span class="token line">   nextFiber = wipRootFiber;
</span></span><span class="token unchanged"><span class="token prefix unchanged"> </span><span class="token line"> &#125;</span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>仅允许 Fiber 在 <code>currentRootFiber</code> 内部切换</strong></p><pre class="line-numbers language-diff" data-language="diff"><code class="language-diff"><span class="token unchanged"><span class="token prefix unchanged"> </span><span class="token line"> function getNextFiber(fiber) &#123;
</span><span class="token prefix unchanged"> </span><span class="token line">   if (fiber.firstChildFiber) return fiber.firstChildFiber;
</span><span class="token prefix unchanged"> </span><span class="token line">   if (fiber.siblingFiber) return fiber.siblingFiber;
</span></span>
<span class="token unchanged"><span class="token prefix unchanged"> </span><span class="token line">   let grandFiber = fiber.parentFiber;
</span><span class="token prefix unchanged"> </span><span class="token line">   while (grandFiber) &#123;
</span></span><span class="token inserted-sign inserted"><span class="token prefix inserted">+</span><span class="token line">     if (grandFiber === wipRootFiber) return null;
</span></span><span class="token unchanged"><span class="token prefix unchanged"> </span><span class="token line">     if (grandFiber.siblingFiber) return grandFiber.siblingFiber;
</span><span class="token prefix unchanged"> </span><span class="token line">     grandFiber = grandFiber.parentFiber;
</span><span class="token prefix unchanged"> </span><span class="token line">   &#125;
</span></span>
<span class="token unchanged"><span class="token prefix unchanged"> </span><span class="token line">   return null;
</span><span class="token prefix unchanged"> </span><span class="token line"> &#125;</span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="实现简易-usestate-hook-同步更新">实现简易 <code>useState</code> Hook (同步更新)</h2><p>在实现 <code>useState</code> 之前我们需要通过如下方式手动更新</p><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript"><span class="token keyword">const</span> <span class="token function">demoFC</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=></span> <span class="token punctuation">&#123;</span>
  <span class="token keyword">const</span> update <span class="token operator">=</span> React<span class="token punctuation">.</span><span class="token function">update</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token keyword">const</span> <span class="token function-variable function">handleChange</span> <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=></span> <span class="token punctuation">&#123;</span>
    num <span class="token operator">+=</span> <span class="token number">1</span>
    <span class="token function">update</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">&#125;</span>
<span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>我们希望实现为</p><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript"><span class="token keyword">const</span> <span class="token function">demoFC</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=></span> <span class="token punctuation">&#123;</span>
  <span class="token keyword">const</span> <span class="token punctuation">[</span>num<span class="token punctuation">,</span> setNum<span class="token punctuation">]</span> <span class="token operator">=</span> React<span class="token punctuation">.</span><span class="token function">useState</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token keyword">const</span> <span class="token function-variable function">handleChange</span> <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=></span> <span class="token punctuation">&#123;</span>
    <span class="token function">setNum</span><span class="token punctuation">(</span>num <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">&#125;</span>
<span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>这意味着我们需要实现一个 <code>React.useState</code></p><ul><li>在构造阶段返回初始值与更新回调</li><li>在更新阶段返回持久化的值与回调</li><li>调用回调后更新状态, 调用 <code>update()</code>, 在下一次构造时返回更新后值</li><li><code>React.useState</code> 应该可以在组件中被多次调用, 并且在下次构造的时候根据调用顺序返回值</li></ul><p>简而言之:</p><ul><li>持久化状态是跟随组件存储的</li><li>组件实例之间状态不能共享的 (同时如果页面中有两个相同的组件, 两个组件各自维护状态)</li><li>状态在更新时可以被传递</li><li>一个组件可以有多个状态, 根据调用函数顺序返回不同的值</li></ul><p>这么看组件对应的 Fiber 是一个很好的存储仓库.</p><ul><li>持久化状态是跟随组件存储的 =&gt; 状态对应一个组件对应一个Fiber</li><li>组件实例之间状态不能共享的 =&gt; 同一组件不同实例是不同 Fiber</li><li>状态在更新时可以被传递 =&gt; 在创建新 Fiber 时赋值</li><li>一个组件可以有多个状态, 根据调用函数顺序返回不同的值 =&gt; 在 Fiber 中维护数组, 与构造时 <code>React.useState</code> 计数, 每次调用返回数组中下一个元素</li></ul><p><strong>扩展 Fiber 数据结构</strong></p><p>新 Fiber 结构如下</p><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript"><span class="token punctuation">&#123;</span>
  dom<span class="token punctuation">,</span>
  component<span class="token punctuation">,</span>
  parentFiber<span class="token punctuation">,</span>
  firstChildFiber<span class="token punctuation">,</span>
  siblingFiber<span class="token punctuation">,</span>
  childrenFiber<span class="token punctuation">,</span>
  newFiber<span class="token punctuation">,</span>
  <span class="token comment">// 新增属性</span>
  <span class="token literal-property property">useStateCount</span><span class="token operator">:</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token comment">// 每次构造新 Fiber 的时候清空</span>
  <span class="token literal-property property">useStateStorage</span><span class="token operator">:</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token comment">// 在构造新 Fiber 的时候从老 Fiber 继承</span>
<span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>应用修改</p><pre class="line-numbers language-diff" data-language="diff"><code class="language-diff"><span class="token unchanged"><span class="token prefix unchanged"> </span><span class="token line"> function render(component, container) &#123;
</span><span class="token prefix unchanged"> </span><span class="token line">   wipRootFiber = &#123;
</span><span class="token prefix unchanged"> </span><span class="token line">     dom: container,
</span><span class="token prefix unchanged"> </span><span class="token line">     component,
</span><span class="token prefix unchanged"> </span><span class="token line">     parentFiber: null,
</span><span class="token prefix unchanged"> </span><span class="token line">     firstChildFiber: null,
</span><span class="token prefix unchanged"> </span><span class="token line">     siblingFiber: null,
</span><span class="token prefix unchanged"> </span><span class="token line">     childrenFiber: [],
</span><span class="token prefix unchanged"> </span><span class="token line">     newFiber: null,
</span></span><span class="token inserted-sign inserted"><span class="token prefix inserted">+</span><span class="token line">     useStateCount: 0,
</span><span class="token prefix inserted">+</span><span class="token line">     useStateStorage: [],
</span></span><span class="token unchanged"><span class="token prefix unchanged"> </span><span class="token line">   &#125;;
</span><span class="token prefix unchanged"> </span><span class="token line">   nextFiber = wipRootFiber;
</span><span class="token prefix unchanged"> </span><span class="token line"> &#125;</span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-diff" data-language="diff"><code class="language-diff">function update() &#123;
<span class="token unchanged"><span class="token prefix unchanged"> </span><span class="token line"> const currentFiber = nextFiber;
</span><span class="token prefix unchanged"> </span><span class="token line"> return () => &#123;
</span><span class="token prefix unchanged"> </span><span class="token line">   currentRootFiber = currentFiber;
</span><span class="token prefix unchanged"> </span><span class="token line">   wipRootFiber = &#123;
</span></span><span class="token inserted-sign inserted"><span class="token prefix inserted">+</span><span class="token line">     // 解构时继承数据
</span></span><span class="token unchanged"><span class="token prefix unchanged"> </span><span class="token line">     ...currentRootFiber,
</span><span class="token prefix unchanged"> </span><span class="token line">     alternateFiber: currentRootFiber,
</span><span class="token prefix unchanged"> </span><span class="token line">     childrenFiber: [],
</span></span><span class="token inserted-sign inserted"><span class="token prefix inserted">+</span><span class="token line">     useStateCount: 0, // 重置计数
</span></span><span class="token unchanged"><span class="token prefix unchanged"> </span><span class="token line">   &#125;;
</span><span class="token prefix unchanged"> </span><span class="token line">   nextFiber = wipRootFiber;
</span><span class="token prefix unchanged"> </span><span class="token line"> &#125;;
</span></span>&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-diff" data-language="diff"><code class="language-diff"><span class="token unchanged"><span class="token prefix unchanged"> </span><span class="token line"> function reconcileChildren(fiber, children) &#123;
</span><span class="token prefix unchanged"> </span><span class="token line">   if (fiber.component.nodeName === 'TEXT_ELEMENT') return;
</span></span>
<span class="token unchanged"><span class="token prefix unchanged"> </span><span class="token line">   let alternateFiber = fiber?.alternateFiber?.firstChildFiber;
</span></span>
<span class="token unchanged"><span class="token prefix unchanged"> </span><span class="token line">   children.reduce((prev, cur) => &#123;
</span><span class="token prefix unchanged"> </span><span class="token line">     const curFiber = &#123;
</span><span class="token prefix unchanged"> </span><span class="token line">       dom: null,
</span><span class="token prefix unchanged"> </span><span class="token line">       component: cur,
</span><span class="token prefix unchanged"> </span><span class="token line">       parentFiber: fiber,
</span><span class="token prefix unchanged"> </span><span class="token line">       firstChildFiber: null,
</span><span class="token prefix unchanged"> </span><span class="token line">       siblingFiber: null,
</span><span class="token prefix unchanged"> </span><span class="token line">       effectTag: null,
</span><span class="token prefix unchanged"> </span><span class="token line">       childrenFiber: [],
</span><span class="token prefix unchanged"> </span><span class="token line">       newFiber: null,
</span></span><span class="token inserted-sign inserted"><span class="token prefix inserted">+</span><span class="token line">       useStateCount: 0,
</span><span class="token prefix inserted">+</span><span class="token line">       useStateStorage: [],
</span></span><span class="token unchanged"><span class="token prefix unchanged"> </span><span class="token line">     &#125;;
</span></span>
<span class="token unchanged"><span class="token prefix unchanged"> </span><span class="token line">     if (alternateFiber) &#123;
</span><span class="token prefix unchanged"> </span><span class="token line">       if (isSameType(cur, alternateFiber.component)) &#123;
</span><span class="token prefix unchanged"> </span><span class="token line">         curFiber.dom = alternateFiber.dom;
</span><span class="token prefix unchanged"> </span><span class="token line">         curFiber.effectTag = 'update';
</span><span class="token prefix unchanged"> </span><span class="token line">         curFiber.alternateFiber = alternateFiber;
</span></span><span class="token inserted-sign inserted"><span class="token prefix inserted">+</span><span class="token line">         // 状态传递
</span><span class="token prefix inserted">+</span><span class="token line">         curFiber.useStateStorage = alternateFiber.useStateStorage;
</span></span><span class="token unchanged"><span class="token prefix unchanged"> </span><span class="token line">         alternateFiber.newFiber = curFiber;
</span><span class="token prefix unchanged"> </span><span class="token line">       &#125; else &#123;
</span><span class="token prefix unchanged"> </span><span class="token line">         deletions.push(alternateFiber);
</span><span class="token prefix unchanged"> </span><span class="token line">         curFiber.effectTag = 'placement';
</span><span class="token prefix unchanged"> </span><span class="token line">       &#125;
</span><span class="token prefix unchanged"> </span><span class="token line">     &#125; else &#123;
</span><span class="token prefix unchanged"> </span><span class="token line">       curFiber.effectTag = 'placement';
</span><span class="token prefix unchanged"> </span><span class="token line">     &#125;
</span></span>
<span class="token unchanged"><span class="token prefix unchanged"> </span><span class="token line">     // ...
</span><span class="token prefix unchanged"> </span><span class="token line">   &#125;, null);
</span></span>
<span class="token unchanged"><span class="token prefix unchanged"> </span><span class="token line">   // ...
</span><span class="token prefix unchanged"> </span><span class="token line"> &#125;</span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>实现 <code>React.useState</code></strong></p><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript"><span class="token keyword">function</span> <span class="token function">useState</span><span class="token punctuation">(</span><span class="token parameter">value</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
  <span class="token comment">// 获取针对当前组件的 update</span>
  <span class="token keyword">const</span> updateComponent <span class="token operator">=</span> <span class="token function">update</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token comment">// 缓存当前 Fiber</span>
  <span class="token keyword">const</span> currentFiber <span class="token operator">=</span> nextFiber<span class="token punctuation">;</span>

  <span class="token comment">// 记录是第几次调用 useState</span>
  <span class="token keyword">const</span> index <span class="token operator">=</span> currentFiber<span class="token punctuation">.</span>useStateCount<span class="token operator">++</span><span class="token punctuation">;</span>
  <span class="token comment">// 如果没有这个 index 说明是初次调用, 直接将传入的初始值记录下来</span>
  <span class="token keyword">if</span> <span class="token punctuation">(</span>currentFiber<span class="token punctuation">.</span>useStateStorage<span class="token punctuation">.</span>length <span class="token operator">&lt;=</span> index<span class="token punctuation">)</span>
    currentFiber<span class="token punctuation">.</span>useStateStorage<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span>value<span class="token punctuation">)</span><span class="token punctuation">;</span>

  <span class="token comment">// 返回持久化的值, 更新函数</span>
  <span class="token keyword">return</span> <span class="token punctuation">[</span>
    currentFiber<span class="token punctuation">.</span>useStateStorage<span class="token punctuation">[</span>index<span class="token punctuation">]</span><span class="token punctuation">,</span>
    <span class="token punctuation">(</span><span class="token parameter">f</span><span class="token punctuation">)</span> <span class="token operator">=></span> <span class="token punctuation">&#123;</span>
      <span class="token comment">// 对 setState 的参数做类型合并</span>
      <span class="token keyword">const</span> newValue <span class="token operator">=</span> f <span class="token keyword">instanceof</span> <span class="token class-name">Function</span> <span class="token operator">?</span> <span class="token function">f</span><span class="token punctuation">(</span>value<span class="token punctuation">)</span> <span class="token operator">:</span> f<span class="token punctuation">;</span>
      <span class="token comment">// 前后结果相同跳过</span>
      <span class="token keyword">if</span> <span class="token punctuation">(</span>newValue <span class="token operator">===</span> value<span class="token punctuation">)</span> <span class="token keyword">return</span><span class="token punctuation">;</span>
      <span class="token comment">// 更新持久化的值</span>
      currentFiber<span class="token punctuation">.</span>useStateStorage<span class="token punctuation">[</span>index<span class="token punctuation">]</span> <span class="token operator">=</span> newValue<span class="token punctuation">;</span>
      <span class="token comment">// 重新渲染</span>
      <span class="token function">updateComponent</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">&#125;</span><span class="token punctuation">,</span>
  <span class="token punctuation">]</span><span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="实现-usestate-hook-异步更新">实现 <code>useState</code> Hook (异步更新)</h2><p>如果代码中连续调用多次 <code>useState</code> 我们就会进行多次计算, 此时可以做如下优化:</p><p>将 state 作为对象 <code>&#123;value, queue: []&#125;</code> 存储, 所有的 <code>setState</code> 会被压入 queue, 请求更新, 再更新时再计算新数据</p><pre class="line-numbers language-diff" data-language="diff"><code class="language-diff"><span class="token unchanged"><span class="token prefix unchanged"> </span><span class="token line"> function useState(value) &#123;
</span><span class="token prefix unchanged"> </span><span class="token line">   const updateComponent = update();
</span><span class="token prefix unchanged"> </span><span class="token line">   const currentFiber = nextFiber;
</span><span class="token prefix unchanged"> </span><span class="token line">   const index = currentFiber.useStateCount++;
</span><span class="token prefix unchanged"> </span><span class="token line">   if (currentFiber.useStateStorage.length &lt;= index) &#123;
</span></span><span class="token deleted-sign deleted"><span class="token prefix deleted">-</span><span class="token line">     currentFiber.useStateStorage.push(value);
</span></span><span class="token inserted-sign inserted"><span class="token prefix inserted">+</span><span class="token line">     currentFiber.useStateStorage.push(&#123;
</span><span class="token prefix inserted">+</span><span class="token line">       value,
</span><span class="token prefix inserted">+</span><span class="token line">       queue: [],
</span><span class="token prefix inserted">+</span><span class="token line">     &#125;);
</span></span><span class="token unchanged"><span class="token prefix unchanged"> </span><span class="token line">   &#125;
</span></span>
<span class="token inserted-sign inserted"><span class="token prefix inserted">+</span><span class="token line">   const hook = currentFiber.useStateStorage[index]; // 获取需要这次的 state
</span><span class="token prefix inserted">+</span><span class="token line">   hook.queue.forEach((f) => (hook.value = f(hook.value))); // 执行压入的变更
</span><span class="token prefix inserted">+</span><span class="token line">   hook.queue = []; // 清空待变更队列
</span></span>
<span class="token unchanged"><span class="token prefix unchanged"> </span><span class="token line">   const hook = currentFiber.useStateStorage[index];
</span><span class="token prefix unchanged"> </span><span class="token line">   hook.queue.forEach((f) => (hook.value = f(hook.value)));
</span><span class="token prefix unchanged"> </span><span class="token line">   hook.queue = [];
</span></span>
<span class="token deleted-sign deleted"><span class="token prefix deleted">-</span><span class="token line">   return [
</span><span class="token prefix deleted">-</span><span class="token line">     currentFiber.useStateStorage[index],
</span><span class="token prefix deleted">-</span><span class="token line">     (f) => &#123;
</span><span class="token prefix deleted">-</span><span class="token line">       const newValue = f instanceof Function ? f(value) : f;
</span><span class="token prefix deleted">-</span><span class="token line">       if (newValue === value) return;
</span><span class="token prefix deleted">-</span><span class="token line">       currentFiber.useStateStorage[index] = newValue;
</span><span class="token prefix deleted">-</span><span class="token line">       updateComponent();
</span><span class="token prefix deleted">-</span><span class="token line">     &#125;,
</span><span class="token prefix deleted">-</span><span class="token line">   ];
</span></span>
<span class="token inserted-sign inserted"><span class="token prefix inserted">+</span><span class="token line">   const setState = (f) => &#123;
</span><span class="token prefix inserted">+</span><span class="token line">     const action = f instanceof Function ? f : () => f;
</span><span class="token prefix inserted">+</span><span class="token line">     // 如果值没有变化就跳过
</span><span class="token prefix inserted">+</span><span class="token line">     const eagerValue = action(hook.value);
</span><span class="token prefix inserted">+</span><span class="token line">     if (hook.value === eagerValue) return;
</span><span class="token prefix inserted">+</span><span class="token line">     hook.queue.push(action);
</span><span class="token prefix inserted">+</span><span class="token line">     updateComponent();
</span><span class="token prefix inserted">+</span><span class="token line">   &#125;;
</span></span>
<span class="token inserted-sign inserted"><span class="token prefix inserted">+</span><span class="token line">   return [currentFiber.useStateStorage[index].value, setState];
</span></span><span class="token unchanged"><span class="token prefix unchanged"> </span><span class="token line"> &#125;</span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="实现简易-useeffect-hook-同步回调">实现简易 <code>useEffect</code> Hook (同步回调)</h2><p>需要实现 <code>useEffect(cb, deps)</code></p><ul><li>在初始化阶段无论 <code>deps</code> 是什么都调用 <code>cb</code></li><li>在更新阶段只有 <code>deps</code> 变化才调用 <code>cb</code></li></ul><p>效仿 useState 的思路实现:</p><p><strong>扩充 Fiber</strong></p><pre class="line-numbers language-diff" data-language="diff"><code class="language-diff"><span class="token unchanged"><span class="token prefix unchanged"> </span><span class="token line"> function update() &#123;
</span><span class="token prefix unchanged"> </span><span class="token line">   const currentFiber = nextFiber;
</span><span class="token prefix unchanged"> </span><span class="token line">   return () => &#123;
</span><span class="token prefix unchanged"> </span><span class="token line">     currentRootFiber = currentFiber;
</span><span class="token prefix unchanged"> </span><span class="token line">     wipRootFiber = &#123;
</span><span class="token prefix unchanged"> </span><span class="token line">       ...currentRootFiber,
</span><span class="token prefix unchanged"> </span><span class="token line">       alternateFiber: currentRootFiber,
</span><span class="token prefix unchanged"> </span><span class="token line">       childrenFiber: [],
</span><span class="token prefix unchanged"> </span><span class="token line">       useStateCount: 0,
</span></span><span class="token inserted-sign inserted"><span class="token prefix inserted">+</span><span class="token line">       useEffectCount: 0,
</span></span><span class="token unchanged"><span class="token prefix unchanged"> </span><span class="token line">     &#125;;
</span><span class="token prefix unchanged"> </span><span class="token line">     nextFiber = wipRootFiber;
</span><span class="token prefix unchanged"> </span><span class="token line">   &#125;;
</span><span class="token prefix unchanged"> </span><span class="token line"> &#125;</span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-diff" data-language="diff"><code class="language-diff"><span class="token unchanged"><span class="token prefix unchanged"> </span><span class="token line"> function render(component, container) &#123;
</span><span class="token prefix unchanged"> </span><span class="token line">   wipRootFiber = &#123;
</span><span class="token prefix unchanged"> </span><span class="token line">     dom: container,
</span><span class="token prefix unchanged"> </span><span class="token line">     component,
</span><span class="token prefix unchanged"> </span><span class="token line">     parentFiber: null,
</span><span class="token prefix unchanged"> </span><span class="token line">     firstChildFiber: null,
</span><span class="token prefix unchanged"> </span><span class="token line">     siblingFiber: null,
</span><span class="token prefix unchanged"> </span><span class="token line">     childrenFiber: [],
</span><span class="token prefix unchanged"> </span><span class="token line">     newFiber: null,
</span><span class="token prefix unchanged"> </span><span class="token line">     useStateCount: 0,
</span><span class="token prefix unchanged"> </span><span class="token line">     useStateStorage: [],
</span></span><span class="token inserted-sign inserted"><span class="token prefix inserted">+</span><span class="token line">     useEffectCount: 0,
</span><span class="token prefix inserted">+</span><span class="token line">     useEffectStorage: [],
</span></span><span class="token unchanged"><span class="token prefix unchanged"> </span><span class="token line">   &#125;;
</span><span class="token prefix unchanged"> </span><span class="token line">   nextFiber = wipRootFiber;
</span><span class="token prefix unchanged"> </span><span class="token line"> &#125;</span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-diff" data-language="diff"><code class="language-diff"><span class="token unchanged"><span class="token prefix unchanged"> </span><span class="token line"> function reconcileChildren(fiber, children) &#123;
</span><span class="token prefix unchanged"> </span><span class="token line">   if (fiber.component.nodeName === 'TEXT_ELEMENT') return;
</span></span>
<span class="token unchanged"><span class="token prefix unchanged"> </span><span class="token line">   let alternateFiber = fiber?.alternateFiber?.firstChildFiber;
</span></span>
<span class="token unchanged"><span class="token prefix unchanged"> </span><span class="token line">   children.reduce((prev, cur) => &#123;
</span><span class="token prefix unchanged"> </span><span class="token line">     const curFiber = &#123;
</span><span class="token prefix unchanged"> </span><span class="token line">       dom: null,
</span><span class="token prefix unchanged"> </span><span class="token line">       component: cur,
</span><span class="token prefix unchanged"> </span><span class="token line">       parentFiber: fiber,
</span><span class="token prefix unchanged"> </span><span class="token line">       firstChildFiber: null,
</span><span class="token prefix unchanged"> </span><span class="token line">       siblingFiber: null,
</span><span class="token prefix unchanged"> </span><span class="token line">       effectTag: null,
</span><span class="token prefix unchanged"> </span><span class="token line">       childrenFiber: [],
</span><span class="token prefix unchanged"> </span><span class="token line">       newFiber: null,
</span><span class="token prefix unchanged"> </span><span class="token line">       useStateCount: 0,
</span><span class="token prefix unchanged"> </span><span class="token line">       useStateStorage: [],
</span></span><span class="token inserted-sign inserted"><span class="token prefix inserted">+</span><span class="token line">       useEffectCount: 0,
</span><span class="token prefix inserted">+</span><span class="token line">       useEffectStorage: [],
</span></span><span class="token unchanged"><span class="token prefix unchanged"> </span><span class="token line">     &#125;;
</span></span>
<span class="token unchanged"><span class="token prefix unchanged"> </span><span class="token line">     if (alternateFiber) &#123;
</span><span class="token prefix unchanged"> </span><span class="token line">       if (isSameType(cur, alternateFiber.component)) &#123;
</span><span class="token prefix unchanged"> </span><span class="token line">         curFiber.dom = alternateFiber.dom;
</span><span class="token prefix unchanged"> </span><span class="token line">         curFiber.effectTag = 'update';
</span><span class="token prefix unchanged"> </span><span class="token line">         curFiber.alternateFiber = alternateFiber;
</span><span class="token prefix unchanged"> </span><span class="token line">         curFiber.useStateStorage = alternateFiber.useStateStorage;
</span></span><span class="token inserted-sign inserted"><span class="token prefix inserted">+</span><span class="token line">         curFiber.useEffectStorage = alternateFiber.useEffectStorage;
</span></span><span class="token unchanged"><span class="token prefix unchanged"> </span><span class="token line">         alternateFiber.newFiber = curFiber;
</span><span class="token prefix unchanged"> </span><span class="token line">       &#125; else &#123;
</span><span class="token prefix unchanged"> </span><span class="token line">         deletions.push(alternateFiber);
</span><span class="token prefix unchanged"> </span><span class="token line">         curFiber.effectTag = 'placement';
</span><span class="token prefix unchanged"> </span><span class="token line">       &#125;
</span><span class="token prefix unchanged"> </span><span class="token line">     &#125; else &#123;
</span><span class="token prefix unchanged"> </span><span class="token line">       curFiber.effectTag = 'placement';
</span><span class="token prefix unchanged"> </span><span class="token line">     &#125;
</span></span>
<span class="token unchanged"><span class="token prefix unchanged"> </span><span class="token line">     // ...
</span><span class="token prefix unchanged"> </span><span class="token line">   &#125;, null);
</span></span>
<span class="token unchanged"><span class="token prefix unchanged"> </span><span class="token line">   // ...
</span><span class="token prefix unchanged"> </span><span class="token line"> &#125;</span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>实现 <code>useEffect()</code></strong></p><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript"><span class="token keyword">function</span> <span class="token function">useEffect</span><span class="token punctuation">(</span><span class="token parameter">cb<span class="token punctuation">,</span> dep</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
  <span class="token keyword">const</span> currentFiber <span class="token operator">=</span> nextFiber<span class="token punctuation">;</span>
  <span class="token keyword">const</span> effectIndex <span class="token operator">=</span> currentFiber<span class="token punctuation">.</span>useEffectCount<span class="token operator">++</span><span class="token punctuation">;</span>

  <span class="token comment">// 初始化阶段, 无论是否传入 dep 列表, 都执行</span>
  <span class="token keyword">if</span> <span class="token punctuation">(</span>currentFiber<span class="token punctuation">.</span>useEffectStorage<span class="token punctuation">.</span>length <span class="token operator">&lt;=</span> effectIndex<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
    currentFiber<span class="token punctuation">.</span>useEffectStorage<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span><span class="token punctuation">&#123;</span> cb<span class="token punctuation">,</span> dep <span class="token punctuation">&#125;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token function">cb</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">return</span><span class="token punctuation">;</span>
  <span class="token punctuation">&#125;</span>

  <span class="token comment">// 非初始化阶段, 只有 deps 变化才执行, 同时更新 deps</span>
  <span class="token keyword">const</span> hook <span class="token operator">=</span> currentFiber<span class="token punctuation">.</span>useEffectStorage<span class="token punctuation">[</span>effectIndex<span class="token punctuation">]</span><span class="token punctuation">;</span>
  <span class="token keyword">if</span> <span class="token punctuation">(</span>
    dep<span class="token punctuation">.</span>length <span class="token operator">!==</span> hook<span class="token punctuation">.</span>dep<span class="token punctuation">.</span>length <span class="token operator">||</span>
    dep<span class="token punctuation">.</span><span class="token function">some</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token parameter">item<span class="token punctuation">,</span> index</span><span class="token punctuation">)</span> <span class="token operator">=></span> item <span class="token operator">!==</span> hook<span class="token punctuation">.</span>dep<span class="token punctuation">[</span>index<span class="token punctuation">]</span><span class="token punctuation">)</span>
  <span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
    hook<span class="token punctuation">.</span>dep <span class="token operator">=</span> dep<span class="token punctuation">;</span>
    <span class="token function">cb</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">&#125;</span>
<span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="实现-useeffect-hook-异步回调">实现 <code>useEffect</code> Hook (异步回调)</h2><p>实际的 <code>useEffect</code> 还具有如下特性</p><ul><li>回调并不是在 <code>React.useEffect()</code> 时执行, 而是在统一提交后执行 (否则拿不到 DOM)</li><li>我们需要收集 useEffect 中回调的返回函数 (<code>cleanup</code> 函数), 并在下次执行回调的时候先执行上次返回的 <code>cleanup</code> 函数</li></ul><p>实现第一点只需要维护一个全局队列记录需要执行的回调. 实现第二点需要在 hook 中维护一个 <code>cleanup</code> 参数</p><p><strong>维护全局回调 Hook 数组</strong></p><pre class="line-numbers language-diff" data-language="diff"><code class="language-diff"><span class="token inserted-sign inserted"><span class="token prefix inserted">+</span><span class="token line"> // 需要执行的 Hook 数组
</span><span class="token prefix inserted">+</span><span class="token line"> let useEffectQueue = [];
</span></span><span class="token unchanged"><span class="token prefix unchanged"> </span><span class="token line"> function useEffect(cb, dep = []) &#123;
</span><span class="token prefix unchanged"> </span><span class="token line">   const currentFiber = nextFiber;
</span><span class="token prefix unchanged"> </span><span class="token line">   const effectIndex = currentFiber.useEffectCount++;
</span></span>
<span class="token unchanged"><span class="token prefix unchanged"> </span><span class="token line">   if (currentFiber.useEffectStorage.length &lt;= effectIndex) &#123;
</span></span><span class="token deleted-sign deleted"><span class="token prefix deleted">-</span><span class="token line">     currentFiber.useEffectStorage.push(&#123; cb, dep &#125;);
</span><span class="token prefix deleted">-</span><span class="token line">     cb();
</span></span><span class="token inserted-sign inserted"><span class="token prefix inserted">+</span><span class="token line">     // 首次执行无需执行 cleanup, 设为空
</span><span class="token prefix inserted">+</span><span class="token line">     const hook = &#123; cb, dep, cleanUp: undefined &#125;;
</span><span class="token prefix inserted">+</span><span class="token line">     currentFiber.useEffectStorage.push(hook);
</span><span class="token prefix inserted">+</span><span class="token line">     useEffectQueue.push(hook);
</span></span><span class="token unchanged"><span class="token prefix unchanged"> </span><span class="token line">     return;
</span><span class="token prefix unchanged"> </span><span class="token line">   &#125;
</span></span>
<span class="token unchanged"><span class="token prefix unchanged"> </span><span class="token line">   const hook = currentFiber.useEffectStorage[effectIndex];
</span><span class="token prefix unchanged"> </span><span class="token line">   if (
</span><span class="token prefix unchanged"> </span><span class="token line">     dep.length !== hook.dep.length ||
</span><span class="token prefix unchanged"> </span><span class="token line">     dep.some((item, index) => item !== hook.dep[index])
</span><span class="token prefix unchanged"> </span><span class="token line">   ) &#123;
</span><span class="token prefix unchanged"> </span><span class="token line">     hook.dep = dep;
</span></span><span class="token deleted-sign deleted"><span class="token prefix deleted">-</span><span class="token line">     cb();
</span></span><span class="token inserted-sign inserted"><span class="token prefix inserted">+</span><span class="token line">     // 更新时执行
</span><span class="token prefix inserted">+</span><span class="token line">     useEffectQueue.push(hook);
</span></span><span class="token unchanged"><span class="token prefix unchanged"> </span><span class="token line">   &#125;
</span><span class="token prefix unchanged"> </span><span class="token line"> &#125;</span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>在统一提交时调用回调</strong></p><p>执行全部的 Hooks</p><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript"><span class="token keyword">function</span> <span class="token function">applyEffect</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
  useEffectQueue<span class="token punctuation">.</span><span class="token function">forEach</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token parameter">hook</span><span class="token punctuation">)</span> <span class="token operator">=></span> <span class="token punctuation">&#123;</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>hook<span class="token punctuation">.</span>cleanUp<span class="token punctuation">)</span> hook<span class="token punctuation">.</span><span class="token function">cleanUp</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    hook<span class="token punctuation">.</span>cleanUp <span class="token operator">=</span> hook<span class="token punctuation">.</span><span class="token function">cb</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">&#125;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  useEffectQueue <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-diff" data-language="diff"><code class="language-diff">function performFiberLoop(idleDeadline) &#123;
<span class="token unchanged"><span class="token prefix unchanged"> </span><span class="token line"> // ...
</span><span class="token prefix unchanged"> </span><span class="token line"> if (!nextFiber &amp;&amp; wipRootFiber) &#123;
</span><span class="token prefix unchanged"> </span><span class="token line">   applyDeletions();
</span><span class="token prefix unchanged"> </span><span class="token line">   applySubmit(getNextFiber(wipRootFiber));
</span></span><span class="token inserted-sign inserted"><span class="token prefix inserted">+</span><span class="token line">   applyEffect();
</span></span><span class="token unchanged"><span class="token prefix unchanged"> </span><span class="token line">   currentRootFiber = wipRootFiber;
</span><span class="token prefix unchanged"> </span><span class="token line">   wipRootFiber = null;
</span><span class="token prefix unchanged"> </span><span class="token line"> &#125;
</span><span class="token prefix unchanged"> </span><span class="token line"> // ...
</span></span>&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></div><footer class="post-footer"><p class="post-end-coffee">-------- 本文结束 <i class="fa-solid fa-mug-hot"></i> 感谢阅读 --------</p><div class="popular-posts-header">相关文章</div><ul class="popular-posts"><li class="popular-posts-item"><div class="popular-posts-title"><a href="/article/Vue23基础/" rel="bookmark">Vue2/3入门笔记</a></div></li><li class="popular-posts-item"><div class="popular-posts-title"><a href="/article/理解Vue/" rel="bookmark">理解Vue</a></div></li><li class="popular-posts-item"><div class="popular-posts-title"><a href="/article/2022寒假字节跳动前端训练营笔记/" rel="bookmark">2022寒假字节跳动前端训练营笔记</a></div></li><li class="popular-posts-item"><div class="popular-posts-title"><a href="/article/Ajax与Axios的使用与关键源码笔记/" rel="bookmark">Ajax与Axios的使用与关键源码笔记</a></div></li><li class="popular-posts-item"><div class="popular-posts-title"><a href="/article/BootStrap笔记/" rel="bookmark">BootStrap 笔记</a></div></li></ul><script>let post_body = document.querySelector('.post-body');
  let theme_switch = document.getElementById('theme_switch');
  const theme = {};
  Object.defineProperty(theme, 'value', {
    set(v){
      post_body.setAttribute('theme', v);
      localStorage.setItem('md_theme', v);
      theme_switch.value = v;
    }
  })
  theme.value = localStorage.getItem('md_theme') || 'sneh';
  theme_switch.addEventListener('change',e=>theme.value = e.target.value)
  document.getElementById('theme_switch_wapper').classList.remove('hidden');</script><div class="reward-container"><div></div><button>赞赏</button><div class="post-reward"><div><img src="/images/wechatpay.png" alt="Liu Kairui 微信"> <span>微信</span></div><div><img src="/images/alipay.png" alt="Liu Kairui 支付宝"> <span>支付宝</span></div></div></div><div class="post-copyright"><ul><li class="post-copyright-author"><strong>本文作者： </strong>Liu Kairui</li><li class="post-copyright-link"><strong>本文链接：</strong> <a href="https://blog.liukairui.me/article/React%E6%B8%B2%E6%9F%93%E4%B8%8E%E6%9B%B4%E6%96%B0%E7%9A%84%E5%9F%BA%E6%9C%AC%E5%8E%9F%E7%90%86%E4%B8%8E%E5%AE%9E%E7%8E%B0/" title="React渲染与更新的基本原理与实现">https://blog.liukairui.me/article/React渲染与更新的基本原理与实现/</a></li><li class="post-copyright-license"><strong>版权声明： </strong>本博客所有文章除特别声明外，均采用 <span class="exturl" data-url="aHR0cHM6Ly9jcmVhdGl2ZWNvbW1vbnMub3JnL2xpY2Vuc2VzL2J5LW5jLXNhLzQuMC9kZWVkLnpo"><i class="fab fa-fw fa-creative-commons"></i>BY-NC-SA</span> 许可协议。转载请注明出处！</li></ul></div><div class="post-tags"><a href="/tags/%E5%89%8D%E7%AB%AF/" rel="tag"><i class="fa fa-tag"></i> 前端</a> <a href="/tags/%E7%AC%94%E8%AE%B0/" rel="tag"><i class="fa fa-tag"></i> 笔记</a> <a href="/tags/%E5%89%8D%E7%AB%AF%E6%A1%86%E6%9E%B6/" rel="tag"><i class="fa fa-tag"></i> 前端框架</a> <a href="/tags/React/" rel="tag"><i class="fa fa-tag"></i> React</a></div><div class="post-nav"><div class="post-nav-item"><a href="/article/ff_monthly/2023-08%E5%89%8D%E7%AB%AF%E6%96%B0%E6%B4%BB%E6%B1%87%E6%80%BB/" rel="prev" title="2023-08前端新活汇总"><i class="fa fa-chevron-left"></i> 2023-08前端新活汇总</a></div><div class="post-nav-item"><a href="/article/%E5%9F%BA%E4%BA%8EPeer.js%E7%9A%84WebRTC%E8%A7%86%E9%A2%91%E4%BC%9A%E8%AE%AE%E5%AE%9E%E7%8E%B0%E9%9A%BE%E7%82%B9/" rel="next" title="基于 Peer.js 的 WebRTC 视频会议实现难点">基于 Peer.js 的 WebRTC 视频会议实现难点 <i class="fa fa-chevron-right"></i></a></div></div></footer></article></div><div class="comments" id="valine-comments"></div></div></main><footer class="footer"><div class="footer-inner"><div class="copyright">&copy; 2019 – <span itemprop="copyrightYear">2024</span> <span class="with-love"><i class="fa fa-heart"></i> </span><span class="author" itemprop="copyrightHolder">Liu Kairui</span></div><div class="wordcount"><span class="post-meta-item"><span class="post-meta-item-icon"><i class="fa fa-chart-line"></i> </span><span>总字数：</span> <span title="总字数">1.9m</span></span></div><div class="busuanzi-count"><span class="post-meta-item" id="busuanzi_container_site_uv"><span class="post-meta-item-icon"><i class="fa fa-user"></i> </span><span class="site-uv" title="总访客量"><span id="busuanzi_value_site_uv"></span> </span></span><span class="post-meta-item" id="busuanzi_container_site_pv"><span class="post-meta-item-icon"><i class="fa fa-eye"></i> </span><span class="site-pv" title="总访问量"><span id="busuanzi_value_site_pv"></span></span></span></div><div class="powered-by">由 <span class="exturl" data-url="aHR0cHM6Ly9oZXhvLmlv">Hexo</span> & <span class="exturl" data-url="aHR0cHM6Ly90aGVtZS1uZXh0LmpzLm9yZy9taXN0Lw==">NexT.Mist</span> 强力驱动</div><div class="addthis_inline_share_toolbox"><script src="//s7.addthis.com/js/300/addthis_widget.js#pubid=ra-630c5bd30a606ba8" async></script></div><div id="time_and_count"></div><script src="https://cdn.jsdelivr.net/npm/moment@2.22.2/moment.min.js"></script><script src="https://cdn.jsdelivr.net/npm/moment-precise-range-plugin@1.3.0/moment-precise-range.min.js"></script><script>function timer() {
    var ages = moment.preciseDiff(moment(),moment(20201101,"YYYYMMDD"));
    ages = ages.replace(/years?/, "年");
    ages = ages.replace(/months?/, "月");
    ages = ages.replace(/days?/, "天");
    ages = ages.replace(/hours?/, "小时");
    ages = ages.replace(/minutes?/, "分");
    ages = ages.replace(/seconds?/, "秒");
    ages = ages.replace(/\d+/g, '<span class="daysCnt" style="color: #1890ff">$&</span>');
    div.innerHTML = `小站已悄悄运行了 ${ages}`;
    div.className="workDays";
  }
  let div = document.createElement("div");
  let time_and_count = document.getElementById("time_and_count");
  time_and_count.appendChild(div);
  timer();
  setInterval("timer()",1000)</script><script>let footer = document.querySelector('.footer-inner')

let wordCount = document.querySelector('.wordcount')
wordCount.innerHTML = wordCount.innerText.replace('：',': ').replace('m','M')
if(wordCount){
  time_and_count.appendChild(wordCount);
}

let busaunzi = document.querySelector('.busuanzi-count')
if(busaunzi){
  footer.appendChild(busaunzi);
}

let powerby = document.querySelector('.powered-by')
if(powerby){
  footer.appendChild(powerby);
}</script></div></footer><script src="https://cdnjs.cloudflare.com/ajax/libs/animejs/3.2.1/anime.min.js" integrity="sha256-XL2inqUJaslATFnHdJOi9GfQ60on8Wx1C2H8DYiN1xY=" crossorigin="anonymous"></script><script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.6.1/jquery.min.js" integrity="sha256-o88AwQnZB+VDvE9tvIXrMQaPlFFSUTR+nldQm1LuPXQ=" crossorigin="anonymous"></script><script src="https://cdnjs.cloudflare.com/ajax/libs/fancybox/3.5.7/jquery.fancybox.min.js" integrity="sha256-yt2kYMy0w8AbtF89WXb2P1rfjcP/HTHLT7097U8Y5b8=" crossorigin="anonymous"></script><script src="https://cdnjs.cloudflare.com/ajax/libs/pangu/4.0.7/pangu.min.js" integrity="sha256-j+yj56cdEY2CwkVtGyz18fNybFGpMGJ8JxG3GSyO2+I=" crossorigin="anonymous"></script><script src="/js/comments.js"></script><script src="/js/utils.js"></script><script src="/js/motion.js"></script><script src="/js/schemes/muse.js"></script><script src="/js/next-boot.js"></script><script src="https://cdnjs.cloudflare.com/ajax/libs/algoliasearch/4.14.2/algoliasearch-lite.umd.js" integrity="sha256-dImjLPUsG/6p3+i7gVKBiDM8EemJAhQ0VvkRK2pVsQY=" crossorigin="anonymous"></script><script src="https://cdnjs.cloudflare.com/ajax/libs/instantsearch.js/4.46.3/instantsearch.production.min.js" integrity="sha256-TDBtvQ4sIGgJS5bk8VOKto+yvrblCB/JxE/9odR5u+M=" crossorigin="anonymous"></script><script src="/js/third-party/search/algolia-search.js"></script><script class="next-config" data-name="pdf" type="application/json">{"object_url":{"url":"https://cdnjs.cloudflare.com/ajax/libs/pdfobject/2.2.8/pdfobject.min.js","integrity":"sha256-tu9j5pBilBQrWSDePOOajCUdz6hWsid/lBNzK4KgEPM="},"url":"/lib/pdf/web/viewer"}</script><script src="/js/third-party/tags/pdf.js"></script><script class="next-config" data-name="mermaid" type="application/json">{"enable":true,"theme":"forest","js":{"url":"https://cdnjs.cloudflare.com/ajax/libs/mermaid/9.1.7/mermaid.min.js","integrity":"sha256-G58AID1YoX5YaEtWfXSI0VLrZ6N4kvNvwg0BI8zUFxE="}}</script><script src="/js/third-party/tags/mermaid.js"></script><script src="/js/third-party/fancybox.js"></script><script src="/js/third-party/pace.js"></script><script async src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><script class="next-config" data-name="leancloud_visitors" type="application/json">{"enable":true,"app_id":"ABKlVtS4cyaWYEwunPyK3sXt-9Nh9j0Va","app_key":"xxGXdTTEGEVifs2TLB35844I","server_url":"https://abklvts4.lc-cn-e1-shared.com","security":false}</script><script src="/js/third-party/statistics/lean-analytics.js"></script><script class="next-config" data-name="enableMath" type="application/json">true</script><script class="next-config" data-name="mathjax" type="application/json">{"enable":true,"tags":"none","js":{"url":"https://cdnjs.cloudflare.com/ajax/libs/mathjax/3.2.2/es5/tex-mml-chtml.js","integrity":"sha256-MASABpB4tYktI2Oitl4t+78w/lyA+D7b/s9GEP0JOGI="}}</script><script src="/js/third-party/math/mathjax.js"></script><script src="https://cdnjs.cloudflare.com/ajax/libs/quicklink/2.3.0/quicklink.umd.js" integrity="sha256-yvJQOINiH9fWemHn0vCA5lsHWJaHs6/ZmO+1Ft04SvM=" crossorigin="anonymous"></script><script class="next-config" data-name="quicklink" type="application/json">{"enable":true,"home":false,"archive":false,"delay":true,"timeout":3000,"priority":true,"url":"https://blog.liukairui.me/article/React%E6%B8%B2%E6%9F%93%E4%B8%8E%E6%9B%B4%E6%96%B0%E7%9A%84%E5%9F%BA%E6%9C%AC%E5%8E%9F%E7%90%86%E4%B8%8E%E5%AE%9E%E7%8E%B0/"}</script><script src="/js/third-party/quicklink.js"></script><script src="https://unpkg.com/darkmode-js@1.5.7/lib/darkmode-js.min.js"></script><script>var options = {
  bottom: '71px',
  right: 'unset',
  left: '30px',
  time: '0s',
  mixColor: 'transparent',
  backgroundColor: 'transparent',
  buttonColorDark: '#222',
  buttonColorLight: '#222',
  saveInCookies: true,
  label: '',
  autoMatchOsTheme: true
}
const darkmode = new Darkmode(options);
window.darkmode = darkmode;
darkmode.showWidget();</script><script>NexT.utils.loadComments('#valine-comments', () => {
  NexT.utils.getScript('https://cdn.jsdelivr.net/npm/valine@1.4.14/dist/Valine.min.js', () => {
    new Valine(Object.assign({"enable":true,"appId":"ABKlVtS4cyaWYEwunPyK3sXt-9Nh9j0Va","appKey":"xxGXdTTEGEVifs2TLB35844I","serverURLs":"https://abklvts4.lc-cn-e1-shared.com","placeholder":"请开始你的表演","avatar":"identicon","meta":["nick","mail","link"],"pageSize":10,"lang":"zh-CN","visitor":false,"comment_count":true,"recordIP":true,"enableQQ":true,"requiredFields":[]}, {
      el: '#valine-comments',
      path: "/article/React%E6%B8%B2%E6%9F%93%E4%B8%8E%E6%9B%B4%E6%96%B0%E7%9A%84%E5%9F%BA%E6%9C%AC%E5%8E%9F%E7%90%86%E4%B8%8E%E5%AE%9E%E7%8E%B0/",
      serverURLs: "https://abklvts4.lc-cn-e1-shared.com"
    }));
  }, window.Valine);
});</script><script src="/live2dw/lib/L2Dwidget.min.js?094cbace49a39548bed64abff5988b05"></script><script>L2Dwidget.init({pluginRootPath:"live2dw/",pluginJsPath:"lib/",pluginModelPath:"assets/",tagMode:!1,log:!1,model:{jsonPath:"/live2dw/assets/hijiki.model.json"},display:{position:"right",width:150,height:300},mobile:{show:!1},react:{opacity:.7}})</script></body></html>