<!DOCTYPE html><html lang="zh-CN"><head><meta charset="UTF-8"><meta name="viewport" content="width=device-width"><meta name="theme-color" content="#222"><meta name="generator" content="Hexo 6.3.0"><link rel="preconnect" href="https://fonts.googleapis.com" crossorigin><link rel="preconnect" href="https://cdnjs.cloudflare.com" crossorigin><link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon.png"><link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32.png"><link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16.png"><link rel="mask-icon" href="/images/logo.svg" color="#222"><link rel="manifest" href="/images/manifest.json"><link rel="stylesheet" href="/css/main.css"><link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Lato:300,300italic,400,400italic,700,700italic%7CPT+Sans:300,300italic,400,400italic,700,700italic%7CFira+Code:300,300italic,400,400italic,700,700italic&display=swap&subset=latin,latin-ext"><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.2.0/css/all.min.css" integrity="sha256-AbA177XfpSnFEvgpYu1jMygiLabzPCJCRIBtR5jGc0k=" crossorigin="anonymous"><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/animate.css/3.1.1/animate.min.css" integrity="sha256-PR7ttpcvz8qrF57fur/yAx1qXMFJeJFiA6pSzWi0OIE=" crossorigin="anonymous"><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/fancybox/3.5.7/jquery.fancybox.min.css" integrity="sha256-Vzbj7sDDS/woiFS3uNKo8eIuni59rjyNGtXfstRzStA=" crossorigin="anonymous"><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/pace/1.2.4/themes/greem/pace-theme-minimal.css"><script src="https://cdnjs.cloudflare.com/ajax/libs/pace/1.2.4/pace.min.js" integrity="sha256-gqd7YTjg/BtfqWSwsJOvndl0Bxc8gFImLEkXQT8+qj0=" crossorigin="anonymous"></script><script class="next-config" data-name="main" type="application/json">{"hostname":"blog.liukairui.me","root":"/","images":"/images","scheme":"Mist","darkmode":false,"version":"8.13.0","exturl":true,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"width":320},"copycode":{"enable":true,"style":"flat"},"bookmark":{"enable":false,"color":"#222","save":"auto"},"mediumzoom":false,"lazyload":false,"pangu":true,"comments":{"style":"tabs","active":"valine","storage":true,"lazyload":false,"nav":null,"activeClass":"valine"},"stickytabs":false,"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"fadeInDown","post_body":"fadeInDown","coll_header":"fadeInLeft","sidebar":"fadeInUp"}},"prism":false,"i18n":{"placeholder":"搜索...","empty":"没有找到任何搜索结果：${query}","hits_time":"找到 ${hits} 个搜索结果（用时 ${time} 毫秒）","hits":"找到 ${hits} 个搜索结果"},"algolia":{"appID":"GPJGYFJZH3","apiKey":"594eec10fca5caccffae82e82d066310","indexName":"hexo","hits":{"per_page":10}}}</script><script src="/js/config.js"></script><meta name="description" content="尝试理解 Vue 的设计思想与实现, 参考自: mini-vue, Vue.js 设计与实现"><meta property="og:type" content="article"><meta property="og:title" content="理解Vue"><meta property="og:url" content="https://blog.liukairui.me/article/%E7%90%86%E8%A7%A3Vue/"><meta property="og:site_name" content="LiuKairui&#39;s Blog"><meta property="og:description" content="尝试理解 Vue 的设计思想与实现, 参考自: mini-vue, Vue.js 设计与实现"><meta property="og:locale" content="zh_CN"><meta property="article:published_time" content="2022-08-15T16:00:00.000Z"><meta property="article:modified_time" content="2022-10-09T18:40:22.373Z"><meta property="article:author" content="Liu Kairui"><meta property="article:tag" content="前端"><meta property="article:tag" content="笔记"><meta property="article:tag" content="前端框架"><meta property="article:tag" content="Vue"><meta name="twitter:card" content="summary"><link rel="canonical" href="https://blog.liukairui.me/article/%E7%90%86%E8%A7%A3Vue/"><script class="next-config" data-name="page" type="application/json">{"sidebar":"","isHome":false,"isPost":true,"lang":"zh-CN","comments":true,"permalink":"https://blog.liukairui.me/article/%E7%90%86%E8%A7%A3Vue/","path":"article/理解Vue/","title":"理解Vue"}</script><script class="next-config" data-name="calendar" type="application/json">""</script><title>理解Vue | LiuKairui's Blog</title><script>var titleTime,OriginTitile=document.title;document.addEventListener("visibilitychange",function(){document.hidden?(document.title="我们活着是为了什么? | "+OriginTitile,clearTimeout(titleTime)):(document.title="整点薯条 | "+OriginTitile,titleTime=setTimeout(function(){document.title=OriginTitile},2e3))})</script><noscript><link rel="stylesheet" href="/css/noscript.css"></noscript><link rel="alternate" href="/atom.xml" title="LiuKairui's Blog" type="application/atom+xml"><style>.darkmode--activated{--body-bg-color:#282828;--content-bg-color:#333;--card-bg-color:#555;--text-color:#ccc;--blockquote-color:#bbb;--link-color:#ccc;--link-hover-color:#eee;--brand-color:#ddd;--brand-hover-color:#ddd;--table-row-odd-bg-color:#282828;--table-row-hover-bg-color:#363636;--menu-item-bg-color:#555;--btn-default-bg:#222;--btn-default-color:#ccc;--btn-default-border-color:#555;--btn-default-hover-bg:#666;--btn-default-hover-color:#ccc;--btn-default-hover-border-color:#666;--highlight-background:#282b2e;--highlight-foreground:#a9b7c6;--highlight-gutter-background:#34393d;--highlight-gutter-foreground:#9ca9b6}.darkmode--activated img{opacity:.75}.darkmode--activated img:hover{opacity:.9}.darkmode--activated code{color:#69dbdc;background:0 0}button.darkmode-toggle{z-index:9999}.darkmode-ignore,img{display:flex!important}.beian img{display:inline-block!important}</style></head><body itemscope itemtype="http://schema.org/WebPage" class="use-motion"><div class="headband"></div><main class="main"><header class="header" itemscope itemtype="http://schema.org/WPHeader"><div class="header-inner"><div class="site-brand-container"><div class="site-nav-toggle"><div class="toggle" aria-label="切换导航栏" role="button"><span class="toggle-line"></span> <span class="toggle-line"></span> <span class="toggle-line"></span></div></div><div class="site-meta"><a href="/" class="brand" rel="start"><i class="logo-line"></i><p class="site-title">LiuKairui's Blog</p><i class="logo-line"></i></a><p class="site-subtitle" itemprop="description">整点薯条</p></div><div class="site-nav-right"><div class="toggle popup-trigger"><i class="fa fa-search fa-fw fa-lg"></i></div></div></div><nav class="site-nav"><ul class="main-menu menu"><li class="menu-item menu-item-home"><a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a></li><li class="menu-item menu-item-categories"><a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类</a></li><li class="menu-item menu-item-tags"><a href="/tags/" rel="section"><i class="fas fa-hashtag fa-fw"></i>标签</a></li><li class="menu-item menu-item-收藏夹"><a href="/favorites/" rel="section"><i class="fab fa-gratipay fa-fw"></i>收藏夹</a></li><li class="menu-item menu-item-留言板"><a href="/messageBoard/" rel="section"><i class="fab fa-facebook-messenger fa-fw"></i>留言板</a></li><li class="menu-item menu-item-项目"><a href="/projects/" rel="section"><i class="fa fa-satellite fa-fw"></i>项目</a></li><li class="menu-item menu-item-about"><a href="/about/" rel="section"><i class="fa fa-user fa-fw"></i>关于</a></li><li class="menu-item menu-item-search"><a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>搜索</a></li></ul></nav><div class="search-pop-overlay"><div class="popup search-popup"><div class="search-header"><span class="search-icon"><i class="fa fa-search"></i></span><div class="search-input-container"></div><span class="popup-btn-close" role="button"><i class="fa fa-times-circle"></i></span></div><div class="search-result-container"><div class="algolia-stats"><hr></div><div class="algolia-hits"></div><div class="algolia-pagination"></div></div></div></div><script async src="/js/wobblewindow.js"></script><script async>window.addEventListener("load",function(){768<window.innerWidth&&($("body>main>header").wobbleWindow({radius:50,movementTop:!1,movementLeft:!1,movementRight:!1,debug:!1}),$("body>footer").wobbleWindow({radius:50,movementBottom:!1,movementLeft:!1,movementRight:!1,debug:!1}))})</script></div><div class="toggle sidebar-toggle" role="button"><span class="toggle-line"></span> <span class="toggle-line"></span> <span class="toggle-line"></span></div><aside class="sidebar"><div class="sidebar-inner sidebar-nav-active sidebar-toc-active"><ul class="sidebar-nav"><li class="sidebar-nav-toc">文章目录</li><li class="sidebar-nav-overview">站点概览</li></ul><div class="sidebar-panel-container"><div class="post-toc-wrap sidebar-panel"><div class="post-toc animated"><ol class="nav"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%80%BB%E8%A7%88"><span class="nav-text">总览</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#vue3-%E7%9A%84%E5%9F%BA%E6%9C%AC%E7%BB%93%E6%9E%84"><span class="nav-text">Vue3 的基本结构</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#reactivity-%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%B5%81%E7%A8%8B"><span class="nav-text">Reactivity 的基本流程</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#runtime-core-%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%B5%81%E7%A8%8B"><span class="nav-text">Runtime-core 的基本流程</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%AE%9E%E7%8E%B0-reactivity"><span class="nav-text">实现 Reactivity</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA"><span class="nav-text">环境搭建</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%9E%84%E5%BB%BA%E5%9F%BA%E6%9C%AC-effect-%E4%B8%8E-reactive"><span class="nav-text">构建基本 effect 与 reactive</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%9E%84%E5%BB%BA-effect-%E7%9A%84-scheduler-%E9%80%89%E9%A1%B9-watch"><span class="nav-text">构建 effect 的 scheduler 选项 (watch)</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%9E%84%E5%BB%BA-effect-%E7%9A%84-stop-%E4%B8%8E-onstop-%E9%80%89%E9%A1%B9"><span class="nav-text">构建 effect 的 stop 与 onStop 选项</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%9E%84%E5%BB%BA-proxy-%E7%9A%84-readonly"><span class="nav-text">构建 Proxy 的 Readonly</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%9E%84%E5%BB%BA%E5%B7%A5%E5%85%B7%E5%87%BD%E6%95%B0-isreadonly-isreactive-isproxy"><span class="nav-text">构建工具函数 isReadonly, isReactive, isProxy</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%AE%9E%E7%8E%B0-reactive-readonly-%E5%B5%8C%E5%A5%97"><span class="nav-text">实现 reactive &#x2F; readonly 嵌套</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%9E%84%E5%BB%BA-shadowreadonly"><span class="nav-text">构建 shadowReadonly</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%9E%84%E5%BB%BA-ref"><span class="nav-text">构建 ref</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%9E%84%E5%BB%BA%E5%B7%A5%E5%85%B7%E5%87%BD%E6%95%B0-isref-unref-proxyrefs"><span class="nav-text">构建工具函数 isRef &amp; unRef &amp; proxyRefs</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%AE%9E%E7%8E%B0-computed"><span class="nav-text">实现 computed</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%80%BB%E7%BB%93"><span class="nav-text">总结</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%AE%9E%E7%8E%B0-runtime-core"><span class="nav-text">实现 runtime-core</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%90%AD%E5%BB%BA%E7%8E%AF%E5%A2%83"><span class="nav-text">搭建环境</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%9E%84%E9%80%A0%E6%B5%8B%E8%AF%95%E7%94%A8%E4%BE%8B"><span class="nav-text">构造测试用例</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%9E%84%E9%80%A0%E4%B8%BB%E6%B5%81%E7%A8%8B"><span class="nav-text">构造主流程</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%AE%9E%E7%8E%B0%E7%BB%84%E4%BB%B6%E5%AE%9E%E4%BE%8B-proxy"><span class="nav-text">实现组件实例 Proxy</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%AE%9E%E7%8E%B0-shapeflags"><span class="nav-text">实现 shapeFlags</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%AE%9E%E7%8E%B0%E4%BA%8B%E4%BB%B6%E6%B3%A8%E5%86%8C"><span class="nav-text">实现事件注册</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%AE%9E%E7%8E%B0-props"><span class="nav-text">实现 props</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%AE%9E%E7%8E%B0-emits"><span class="nav-text">实现 Emits</span></a></li></ol></li></ol></div></div><div class="site-overview-wrap sidebar-panel"><div class="site-author site-overview-item animated" itemprop="author" itemscope itemtype="http://schema.org/Person"><img class="site-author-image" itemprop="image" alt="Liu Kairui" src="/images/avatar.jpg"><p class="site-author-name" itemprop="name">Liu Kairui</p><div class="site-description" itemprop="description">LiuKairui's Personal Website</div></div><div class="site-state-wrap site-overview-item animated"><nav class="site-state"><div class="site-state-item site-state-posts"><a href="/archives/"><span class="site-state-item-count">48</span> <span class="site-state-item-name">日志</span></a></div><div class="site-state-item site-state-categories"><a href="/categories/"><span class="site-state-item-count">26</span> <span class="site-state-item-name">分类</span></a></div><div class="site-state-item site-state-tags"><a href="/tags/"><span class="site-state-item-count">60</span> <span class="site-state-item-name">标签</span></a></div></nav></div><div class="links-of-author site-overview-item animated"><span class="links-of-author-item"><span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL0thaXJ1aUxpdQ==" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;KairuiLiu"><i class="fab fa-github fa-fw"></i>GitHub</span> </span><span class="links-of-author-item"><span class="exturl" data-url="bWFpbHRvOm1lQGxpdWthaXJ1aS5tZQ==" title="E-Mail → mailto:me@liukairui.me"><i class="fa fa-envelope fa-fw"></i>E-Mail</span> </span><span class="links-of-author-item"><span class="exturl" data-url="aHR0cHM6Ly9xbS5xcS5jb20vY2dpLWJpbi9xbS9xcj9rPW9hZjNUb09sTjE3aHI1c0hWOThiVDhxeHNOWUdhdzVMJm5vdmVyaWZ5PTA=" title="QQ → https:&#x2F;&#x2F;qm.qq.com&#x2F;cgi-bin&#x2F;qm&#x2F;qr?k&#x3D;oaf3ToOlN17hr5sHV98bT8qxsNYGaw5L&amp;noverify&#x3D;0"><i class="fab fa-qq fa-fw"></i>QQ</span> </span><span class="links-of-author-item"><a href="/atom.xml" title="RSS → &#x2F;atom.xml"><i class="fa fa-rss fa-fw"></i>RSS</a> </span><span class="links-of-author-item"><span class="exturl" data-url="aHR0cHM6Ly9saXVrYWlydWkuYmxvZy5jc2RuLm5ldA==" title="CSDN → https:&#x2F;&#x2F;liukairui.blog.csdn.net"><i class="fab fa-cuttlefish fa-fw"></i>CSDN</span> </span><span class="links-of-author-item"><span class="exturl" data-url="aHR0cDovL2xpdWthaXJ1aS5jYw==" title="国内站点 → http:&#x2F;&#x2F;liukairui.cc"><i class="fa fa-globe fa-fw"></i>国内站点</span></span></div><div class="cc-license site-overview-item animated" itemprop="license"><span class="exturl cc-opacity" data-url="aHR0cHM6Ly9jcmVhdGl2ZWNvbW1vbnMub3JnL2xpY2Vuc2VzL2J5LW5jLXNhLzQuMC9kZWVkLnpo"><img src="https://cdnjs.cloudflare.com/ajax/libs/creativecommons-vocabulary/2020.11.3/assets/license_badges/small/by_nc_sa.svg" alt="Creative Commons"></span></div></div></div></div></aside><div class="sidebar-dimmer"></div></header><div class="back-to-top" role="button" aria-label="返回顶部"><i class="fa fa-arrow-up"></i> <span>0%</span></div><div class="reading-progress-bar"></div><noscript><div class="noscript-warning">Theme NexT works best with JavaScript enabled</div></noscript><div class="main-inner post posts-expand"><div class="post-block"><article itemscope itemtype="http://schema.org/Article" class="post-content" lang="zh-CN"><link itemprop="mainEntityOfPage" href="https://blog.liukairui.me/article/%E7%90%86%E8%A7%A3Vue/"><span hidden itemprop="author" itemscope itemtype="http://schema.org/Person"><meta itemprop="image" content="/images/avatar.jpg"><meta itemprop="name" content="Liu Kairui"></span><span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization"><meta itemprop="name" content="LiuKairui's Blog"><meta itemprop="description" content="LiuKairui's Personal Website"></span><span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork"><meta itemprop="name" content="理解Vue | LiuKairui's Blog"><meta itemprop="description" content="尝试理解 Vue 的设计思想与实现, 参考自: mini-vue, Vue.js 设计与实现"></span><header class="post-header"><h1 class="post-title" itemprop="name headline">理解Vue</h1><div class="post-meta-container"><div class="post-meta"><span class="post-meta-item"><span class="post-meta-item-icon"><i class="far fa-calendar"></i> </span><span class="post-meta-item-text">发表于</span> <time title="创建时间：2022-08-16 00:00:00" itemprop="dateCreated datePublished" datetime="2022-08-16T00:00:00+08:00">2022-08-16</time> </span><span class="post-meta-item"><span class="post-meta-item-icon"><i class="far fa-folder"></i> </span><span class="post-meta-item-text">分类于</span> <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/%E5%89%8D%E7%AB%AF/" itemprop="url" rel="index"><span itemprop="name">前端</span></a> </span>， <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/%E5%89%8D%E7%AB%AF/%E5%89%8D%E7%AB%AF%E6%A1%86%E6%9E%B6/" itemprop="url" rel="index"><span itemprop="name">前端框架</span></a> </span></span><span id="/article/%E7%90%86%E8%A7%A3Vue/" class="post-meta-item leancloud_visitors" data-flag-title="理解Vue" title="阅读次数"><span class="post-meta-item-icon"><i class="far fa-eye"></i> </span><span class="post-meta-item-text">阅读次数：</span> <span class="leancloud-visitors-count"></span> </span><span class="post-meta-item" title="阅读次数" id="busuanzi_container_page_pv"><span class="post-meta-item-icon"><i class="far fa-eye"></i> </span><span class="post-meta-item-text">阅读次数：</span> <span id="busuanzi_value_page_pv"></span> </span><span class="post-meta-item"><span class="post-meta-item-icon"><i class="far fa-comment"></i> </span><span class="post-meta-item-text">Valine：</span> <a title="valine" href="/article/%E7%90%86%E8%A7%A3Vue/#valine-comments" itemprop="discussionUrl"><span class="post-comments-count valine-comment-count" data-xid="/article/%E7%90%86%E8%A7%A3Vue/" itemprop="commentCount"></span> </a></span><span class="post-meta-item theme_switch_wapper hidden" id="theme_switch_wapper"><span class="post-meta-item-icon"><i class="fa-brands fa-markdown"></i></span> <span class="post-meta-item-text">主题： </span><select name="theme_switch" id="theme_switch"><option>sneh</option><option>mo</option><option>with</option><option>next</option></select> </span><span class="post-meta-item" title="本文字数"><span class="post-meta-item-icon"><i class="far fa-file-word"></i> </span><span class="post-meta-item-text">本文字数：</span> <span>45k</span></span></div><div class="post-description">尝试理解 Vue 的设计思想与实现, 参考自: mini-vue, Vue.js 设计与实现</div></div></header><div class="post-body" itemprop="articleBody"><h2 id="总览">总览</h2><h3 id="vue3-的基本结构">Vue3 的基本结构</h3><p>采用 Monorepo 模式(多组件放在一个 Repo 中), 在 <code>/packages/</code> 中存储所有的模块.</p><p><strong>模块分为几类:</strong></p><ul><li>编译时(<code>/package/compiler-*</code>)<ul><li><code>compiler-core</code>: 与平台无关的编译器核心</li><li><code>compiler-dom</code>: 基于 <code>compiler-core</code> 解析 <code>&lt;template&gt;</code> 标签并编译为 render 函数</li><li><code>compiler-sfc</code>: 基于 <code>compiler-dom</code> 与 <code>compiler-core</code> 解析 SFC (单文件组件, 通俗理解就是 <code>.vue</code> 文件) 编译为浏览器可执行的 JavaScript</li><li><code>compiler-ssr</code>: 服务端渲染的编译模块</li></ul></li><li>运行时(<code>/package/runtime-*</code>)<ul><li><code>reactivity</code>: 实现响应式</li><li><code>runtime-core</code>: 基于 <code>reactivity</code> 实现运行时核心</li><li><code>runtime-dom</code>: 基于 <code>runtime-core</code> 实现针对浏览器的运行时. 包括DOM API, 属性, 事件处理等</li></ul></li><li>其他<ul><li><code>template-explorer</code>: 用于调试编译器输出的开发工具</li><li><code>shared</code>: 多个包之间共享的内容</li><li><code>vue</code>: 完整版本,包括运行时和编译器</li></ul></li></ul><p><strong>依赖关系</strong></p><pre class="line-numbers language-none"><code class="language-none">                                 +---------------------+
                                 |                     |
                                 |  @vue&#x2F;compiler-sfc  |
                                 |                     |
                                 +-----+--------+------+
                                       |        |
                                       v        v
                   +---------------------+    +----------------------+
                   |                     |    |                      |
     +------------&gt;|  @vue&#x2F;compiler-dom  +---&gt;|  @vue&#x2F;compiler-core  |
     |             |                     |    |                      |
+----+----+        +---------------------+    +----------------------+
|         |
|   vue   |
|         |
+----+----+        +---------------------+    +----------------------+    +-------------------+
     |             |                     |    |                      |    |                   |
     +------------&gt;|  @vue&#x2F;runtime-dom   +---&gt;|  @vue&#x2F;runtime-core   +---&gt;|  @vue&#x2F;reactivity  |
                   |                     |    |                      |    |                   |
                   +---------------------+    +----------------------+    +-------------------+<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>学习路线</strong></p><p>根据模块依赖关系, 路线为: <code>reactivity</code> -&gt; <code>runtime-core</code> -&gt; <code>runtime-dom</code> -&gt; <code>compiler</code>. 重点是 <code>runtime-*</code></p><p><strong>代码分析步骤</strong>:</p><ol type="1"><li>查看单元测试(位于<code>packages/**/__tests__/</code>)</li><li>根据单元测试了解模块实现的功能</li><li>跟着单元测试的了解模块功能, 了解模块功能时: 先看导出(模块是什么), 再看模块被谁导入(为什么被需要), 最后看导出部分对应的实现(怎么样实现)</li></ol><p><strong>参考 repo</strong></p><ul><li><span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL2N1aXhpYW9ydWkvbWluaS12dWU=">cuixiaorui/mini-vue<i class="fa fa-external-link-alt"></i></span>: 用来学习</li><li><span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL3Z1ZWpzL2NvcmU=">vuejs/core<i class="fa fa-external-link-alt"></i></span>: 用来验证</li></ul><h3 id="reactivity-的基本流程">Reactivity 的基本流程</h3><p><code>Reactivity</code> 模块是运行时的最底层, 负责实现响应式, 位于: <code>mini-vue/packages/reactivity</code></p><p><strong><code>reactive</code> 的基本流程</strong></p><p><code>reactive</code> 是 <code>Reactivity</code> 的基础. 负责实现对象的响应式, 并向上提供调用时方法. 基本思想就是借助 ES6 的 <code>Proxy</code> 自定义 <code>get &amp; set</code></p><ol type="1"><li><p>转到 <code>mini-vue/../__tests__/reactive.spec.ts</code>, 发现测试的主要目的是看 <code>reactive</code> 构造方法.</p></li><li><p>转到 <code>mini-vue/../src/reactive.ts</code>, 发现定义了 <code>reactive</code>, <code>readonly</code> 等方法, 这些方法都交由 <code>createReactiveObject</code> 处理.</p><p>观察 <code>createReactiveObject</code>, 可以得到三个调用参数意义:</p><ul><li><p><code>target</code>: 要被代理的值</p></li><li><p><code>proxyMap</code>: 不同类型的工厂函数有不同的全局 <code>proxyMap</code>, 这意味着该变量可能会存储所有代理的某类型变量. 根据</p><pre class="line-numbers language-typescript" data-language="typescript"><code class="language-typescript">const existingProxy &#x3D; proxyMap.get(target);
if (existingProxy) &#123;
    return existingProxy;
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>可以验证想法, 其在 <code>createReactiveObject</code> 的目的就是持久化 <code>Proxy</code> 防止重复创建代理</p></li><li><p><code>baseHandlers</code>: 根据</p><pre class="line-numbers language-typescript" data-language="typescript"><code class="language-typescript">const proxy &#x3D; new Proxy(target, baseHandlers);<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>得出该方法就是 Proxy(<span class="exturl" data-url="aHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvemgtQ04vZG9jcy9XZWIvSmF2YVNjcmlwdC9SZWZlcmVuY2UvR2xvYmFsX09iamVjdHMvUHJveHk=">MDN<i class="fa fa-external-link-alt"></i></span>) 的 <code>get &amp; set</code> 对象. 不同类型的 Proxy 有不同的 <code>baseHandlers</code></p></li></ul></li><li><p>转到 <code>mini-vue/../src/baseHandlers.ts</code> 发现模块主要是提供不同的 <code>get &amp; set</code> 而这些都是由两个 <code>create</code> 函数实现的, 尝试理解</p><ul><li><p><code>createGetter</code> 应该返回一个 <code>handler.get</code>(<span class="exturl" data-url="aHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvemgtQ04vZG9jcy9XZWIvSmF2YVNjcmlwdC9SZWZlcmVuY2UvR2xvYmFsX09iamVjdHMvUHJveHkvUHJveHkvZ2V0">MDN<i class="fa fa-external-link-alt"></i></span>) 实现. 可以看到这个函数上有一堆类型判断的方法, 然后做了两步</p><ul><li>通过 <code>Reflect.get</code>(<span class="exturl" data-url="aHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvemgtQ04vZG9jcy9XZWIvSmF2YVNjcmlwdC9SZWZlcmVuY2UvR2xvYmFsX09iamVjdHMvUmVmbGVjdC9nZXQ=">MDN<i class="fa fa-external-link-alt"></i></span>) 获取属性</li><li>通过 <code>track</code> 进行<strong>依赖收集</strong>, 这部分后面再看</li></ul><p>最后返回获取结果. 整个 <code>get</code> 感觉和原生方法相比就是多了个类型判断和 <code>track</code>, 大部分的响应式都是依赖这个 <code>track</code> 实现的</p></li><li><p><code>createSetter</code> 更加简单, 看起来就是在实现 <code>handler.set</code>(<span class="exturl" data-url="aHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvemgtQ04vZG9jcy9XZWIvSmF2YVNjcmlwdC9SZWZlcmVuY2UvR2xvYmFsX09iamVjdHMvUHJveHkvUHJveHkvc2V0">MDN<i class="fa fa-external-link-alt"></i></span>) 的基础上多了个 <code>trigger</code></p></li></ul><p>到目前位置这个只有 <code>track</code> 和 <code>trigger</code> 是不清楚的, 这两个函数在 <code>effect</code> 等部分做依赖收集的, 可以先不管. 其他部分就是原生功能调用与权限管理</p></li></ol><p><strong><code>effect</code> 的基本流程</strong></p><p>如果让我实现 <code>effect</code> 我会怎么实现呢? 我先想到的是利用编译原理等魔法对代码做静态分析, 找到所用响应式对象, 在响应式对象的 <code>set</code> 上挂上函数. 但是, JavaScript 是个动态语言, 这完全没法挂啊! 只能在运行时动态解析.</p><p>Vue 的实现就比较流畅. 既然我 <code>effect</code> 要立即执行一遍函数, 那为啥不在执行前后做下 Flag, 一旦 Proxy 的 <code>get</code> 被调用, 让 <code>get</code> 检查一下是不是在 <code>effect</code> 执行阶段, 若是就把函数注册到这个响应式对象上😎</p><ol type="1"><li><p>转到 <code>mini-vue/../__tests__/reactive.spec.ts</code> 看到 <code>effect</code> 的主要功能是立即执行函数并在响应式数据发生改变时, 去执行 <code>effect</code> 注册的函数</p></li><li><p>转到 <code>mini-vue/../src/effect.ts</code> 看 <code>effect</code> 函数的实现. 看到这里有熟悉的 <code>effect</code>, <code>track</code>, <code>trigger</code></p><ol type="1"><li><p><code>effect</code> 函数将传入函数包装为 <code>ReactiveEffect</code> 对象, 合并配置, 执行 <code>run</code> 函数, 构造 <code>runner</code> 并返回(用于后期调用)</p></li><li><p><code>ReactiveEffect</code> 类</p><ul><li><code>active</code>: 根据 <code>run</code>, <code>stop</code> 函数和测试文件中的 <code>it("stop")</code> 断言可以推出其是用来开关 <code>effect</code> 功能的</li><li><code>deps</code>: 根据 <code>track</code> 与 <code>trigger</code> 对其调用可以判断其是用来记录函数对应依赖的</li><li><code>run</code>: 对 <code>effect</code> 注册函数的包装, 在执行函数前后打入 <code>shouldTrack</code> 标记, 并将 <code>activeEffect</code> 标记为要执行的 <code>ReactiveEffect</code> 好让 <code>get</code> 知道哪个 <code>effect</code> 在跑</li></ul></li><li><p><code>track</code> 函数: 在 <code>reactive</code> 的 <code>get</code> 中调用</p><pre class="line-numbers language-typescript" data-language="typescript"><code class="language-typescript">track(target, &quot;get&quot;, key);<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><code>track</code> 发现自己处于 <code>effect</code> 阶段时会先检查自己所在对象有没有创建 <code>attribute</code> - <code>effect</code> 函数heap 的 <code>map</code>, 如果每就创建, 然后看 <code>map</code> 上有没有记录当前属性, 如果没有, 就建立依赖的 <code>set</code> 并交由 <code>trackEffects</code> 加入并在 <code>ReactiveEffect</code> 上也做记录.</p></li><li><p><code>trigger</code> 函数: 在 <code>reactive</code> 的 <code>set</code> 中调用</p><p>先找到对应 <code>attribute</code> 的 <code>effect</code> 依赖, 去重, 根据配置延迟或立即支持 <code>effect</code></p></li></ol></li></ol><p><strong>总结</strong></p><ul><li><code>reactive</code> 的流程: 传入对象, 持久化, 绑定 <code>baseHandlers</code> 做权限管理与依赖收集</li><li><code>effect</code> 的流程: 将传入函数包装为对象, 立即执行函数并做好标记, 在执行时收集依赖. 每当 <code>reactive</code> 被调用时就 <code>tigger</code> 收集的 <code>effect</code>, 并二次收集依赖</li></ul><p><strong>问题</strong></p><ul><li><p>所有的依赖收集都是基于 <code>get</code>, 这样的 <code>effect</code> 存在问题</p><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript"><span class="token function">it</span><span class="token punctuation">(</span><span class="token string">'should observe basic properties'</span><span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=></span> <span class="token punctuation">&#123;</span>
  <span class="token keyword">let</span> dummy<span class="token punctuation">,</span> flag <span class="token operator">=</span> <span class="token boolean">false</span><span class="token punctuation">;</span>
  <span class="token keyword">const</span> counter <span class="token operator">=</span> <span class="token function">reactive</span><span class="token punctuation">(</span><span class="token punctuation">&#123;</span> <span class="token literal-property property">num</span><span class="token operator">:</span> <span class="token number">0</span> <span class="token punctuation">&#125;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token function">effect</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=></span> <span class="token punctuation">&#123;</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>flag<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
      dummy <span class="token operator">=</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span>
    <span class="token punctuation">&#125;</span> <span class="token keyword">else</span> <span class="token punctuation">&#123;</span>
      dummy <span class="token operator">=</span> counter<span class="token punctuation">.</span>num<span class="token punctuation">;</span>
    <span class="token punctuation">&#125;</span>
  <span class="token punctuation">&#125;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

  <span class="token function">expect</span><span class="token punctuation">(</span>dummy<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">toBe</span><span class="token punctuation">(</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  flag <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">;</span>
  counter<span class="token punctuation">.</span>num <span class="token operator">=</span> <span class="token number">2</span><span class="token punctuation">;</span>
  <span class="token function">expect</span><span class="token punctuation">(</span>dummy<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">toBe</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// Except 2, Received -1</span>
<span class="token punctuation">&#125;</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>不只是 <code>mini-vue</code>, <code>vue/core</code> 的单元测试也存在这个问题. 但是在 <code>Vue</code> 代码中并不会出现无法追踪依赖的问题, 看来还有一些隐藏的优化没有找到</p></li></ul><h3 id="runtime-core-的基本流程">Runtime-core 的基本流程</h3><p><code>runtime-core</code> 依赖 <code>Reactivity</code> 为 runtime 提供服务. 可以通过观察 Vue 文件的运行观察 <code>runtime-core</code> 的基本流程</p><p><strong>文件基本结构</strong></p><ol type="1"><li><p>转到 <code>mini-vue/packages/vue/example/helloWorld/</code> 的文件夹了解 vue 的基本工作流程</p></li><li><p>转到 <code>mini-vue/../helloWorld/index.html</code>, 只有个 <code>div#root</code> 和 <code>script</code></p></li><li><p>转到 <code>mini-vue/.../helloWorld/main.js</code></p><pre class="line-numbers language-typescript" data-language="typescript"><code class="language-typescript">import &#123; createApp &#125; from &#39;..&#x2F;..&#x2F;dist&#x2F;mini-vue.esm-bundler.js&#39;;
import App from &#39;.&#x2F;App.js&#39;;

const rootContainer &#x3D; document.querySelector(&#39;#root&#39;);
createApp(App).mount(rootContainer);<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>引入了创建根组件的 <code>createApp</code> 与根组件 <code>App</code>, 查找了 html 文件中声明的挂载点, 然后通过 <code>createApp(App)</code> 打包根组件再将打包后结果挂载</p></li><li><p>转到 <code>mini-vue/../helloWorld/App.js</code> 发现定义了两个 vue2 风格的组件对象</p><pre class="line-numbers language-typescript" data-language="typescript"><code class="language-typescript">&#123;
  name: &#39;App&#39;, &#x2F;&#x2F; 组件名
  setup() &#123;&#125;, &#x2F;&#x2F; setup 方法

  render() &#123; &#x2F;&#x2F; 渲染方法
    return h(&#39;div&#39;, &#123; tId: 1 &#125;, [h(&#39;p&#39;, &#123;&#125;, &#39;主页&#39;), h(HelloWorld)]);
  &#125;,
&#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li><p>前面有提到: <code>compiler-dom</code> 将 <code>&lt;template&gt;</code> 标签解析并编译为 render 函数. 在这里为了不追踪 <code>compiler-dom</code> 的行为, 我们直接将 <code>render</code> 给出</p></li><li><p><code>h</code> 为渲染函数, 参数分别是: 组件的 <code>ElementType</code>, 配置, 子组件数组, 可以看到, 这里第一个子组件是一个 <code>&lt;p&gt;</code> 第二个是一个组件</p></li><li><p>可以在对象中使用 <code>render</code>, 也可以让 <code>setup</code> 返回 <code>render</code> 方法, 即</p><pre class="line-numbers language-typescript" data-language="typescript"><code class="language-typescript">&#123;
  name: &#39;App&#39;,
  setup() &#123;
    return function() &#123;
      return h(&#39;div&#39;, &#123; tId: 1 &#125;, [h(&#39;p&#39;, &#123;&#125;, &#39;主页&#39;), h(HelloWorld)]);
    &#125;
  &#125;,
&#125;;.<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li></ul></li><li><p><code>createApp</code> 调用关系比较复杂, 直接使用 dev-tools 观察执行过程. 打开一个 http 服务器并转到 dev-tools下, 找到 <code>createApp.js</code> 并打下断点</p></li><li><p><code>createApp</code> 方法接受根组件配置对象 <code>App</code> 直接包了个对象, 有</p><ul><li><code>_componment = App</code></li><li><code>mount</code> 方法, 看语义, 这个方法接收挂载点, 将根组件创建为 <code>VNode</code> 并挂载到挂载点(<code>main.js</code> 中的 <code>rootContainer</code>), 执行完后 <code>main.js</code> 就结束了</li></ul><p>我们需要继续分析的就是 <code>VNode</code> 的创建过程与 <code>render</code> 的挂载过程</p></li></ol><p><strong>组件初始化过程</strong></p><ol type="1"><li><p>单步进入 <code>createVNode</code> 发现其声明了个 <code>vnode</code>.</p><p>将传入对象(<code>rootComponent / App</code>) 作为 <code>vnode.type</code></p><p>在 <code>vnode</code> 上合并对象并配置 <code>shapeFlag</code> 用于标记类型</p><p>之后调用 <code>normalizeChildren</code> 并返回对象</p><ul><li>进入 <code>normalizeChildren</code> 看起来是作了 <code>slot</code> 特判</li></ul></li><li><p>单步进入 <code>render</code>, 其接收了处理后的 <code>vnode</code> 与挂载点 <code>rootContainer</code> 然后将参数直接交给 <code>patch</code>, 可以猜到 <code>patch</code> 会是一个很通用的函数</p><ul><li><p>单步进入 <code>patch</code>, 其接收 <code>n1 = null</code>, <code>n2 = vnode</code>, <code>container</code>.</p><p>解构出了<code>n2</code> 的 <code>type = App</code> 与 <code>shapeFlag</code>,</p><p>通过预定义的 <code>Symbol</code> 判断对象类型, 进入 <code>default</code>,</p><p>通过位运算判断 <code>shapeFlag</code> 类型, 被识别为组件 (而不是像 <code>h('p', &#123;&#125;, '主页')</code> 一样的 Element) 执行 <code>processComponent</code></p><ul><li><p>单步进入 <code>processComponent</code>,</p><p>函数做了一个判断: 如果没有 <code>n1</code> 就认为 <code>n2</code> 还没有被挂载就挂载 <code>n2</code> 否则更新 <code>n2</code></p><ul><li><p>单步进入 <code>mountComponent</code>, 其接收了 <code>vnode</code> 与挂载点</p><p>将 <code>vnode</code> 转换为实例 <code>instance</code>, 执行 <code>setupComponent</code> 处理 <code>instance</code></p><ul><li><p>单步进入 <code>setupComponent</code> 发现其只是处理了 <code>prop</code> 与 <code>slot</code> 然后交给 <code>setupStatefulComponent</code> 继续配置</p><ul><li><p>单步进入 <code>setupStatefulComponent</code>, 其接收 <code>instance</code></p><p>将 <code>instance.ctx</code> 配置了 <code>PublicInstanceProxyHandlers</code> 代理(后面分析)</p><p>提取 <code>Component = APP</code>, <code>setup = APP.setup</code></p><p>如果 <code>setup</code> 不存在就直接 <code>finishComponentSetup</code></p><p>否则用 <code>setCurrentInstance</code> 打标记, 为 <code>setup</code> 传入参数并获取执行结果, 执行 <code>handleSetupResult</code> 处理结果</p><ul><li><p>单步进入 <code>handleSetupResult</code> 该函数对 <code>setup</code> 结果执行判断</p><p>如果是 <code>function</code> 说明是导出了 <code>render</code> 函数, 将 <code>render</code> 赋值到 <code>instance.render</code> 上</p><p>否则导出的对象存入 <code>isntance.setupState</code></p><p>最后执行 <code>finishComponentSetup</code> 与无 <code>setup</code> 的情况汇合</p></li><li><p>单步进入 <code>finishComponentSetup</code> 其接收 <code>instance</code></p><p>若 <code>instance</code> 上没有 <code>render</code> 就尝试从 <code>template</code> 编译结果上获取并存入 <code>instrance.render</code></p></li></ul></li></ul></li><li><p>单步进入 <code>setupRenderEffect</code> 发现其定义绑定了一个 <code>componentUpdateFn</code> 函数</p><ul><li><p>打断点并进入 <code>componentUpdateFn</code> 函数</p><p>如果组件没有被挂载, 获取子节点, 获取 <code>instance</code> 的 Proxy, 构建子节点 <code>subTree</code> 并递归 <code>patch</code>, 当 <code>patch</code> 到 Element 时调用 <code>processElement</code> 挂载节点</p><p>否则更新节点(后面分析)</p></li></ul></li></ul></li></ul></li></ul></li></ul></li></ol><p><strong>组件更新过程</strong></p><p>为组件创建响应式并将 <code>reavtive</code> 导出到全局</p><pre class="line-numbers language-typescript" data-language="typescript"><code class="language-typescript">&#123;
  name: &#39;HelloWorld&#39;,
  setup() &#123;
    const count &#x3D; ref(10);
    window.count &#x3D; count;
    return &#123; count &#125;;
  &#125;,
  render() &#123;
    return h(&#39;div&#39;, &#123; tId: &#39;helloWorld&#39; &#125;, &#96;hello world: count: $&#123;this.count&#125;&#96;);
  &#125;,
&#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>在 dev-tools 中修改 <code>count.value</code> 根据输出来自 <code>effect.ts</code> 进入文件并为 <code>run</code> 函数打上断点, 再次修改值, 发现 <code>run</code> 函数实际上就是执行了当时的 <code>componentUpdateFn</code>, 为 <code>componentUpdateFn</code> 中已挂载的判断部分打上断点</p><ol type="1"><li><p>在断点处查看调用栈, 确定函数就是因为 <code>ref</code> 修改而引发的</p></li><li><p>在执行修改前先判断有没有 <code>nextTrick</code> 需要执行</p></li><li><p>获取新节点的 <code>vnode</code></p></li><li><p>将老节点子树复制到新节点</p></li><li><p>触发生命周期函数</p></li><li><p><code>patch</code> 新节点</p><p>单步进入 <code>patch</code>, 接受老节点 <code>n1</code> 新节点 <code>n2</code> 这次更新的是一个 Element 于是进入 <code>ShapeFlags.ELEMENT</code>, 进入 <code>processElement</code></p><ul><li>单步进入 <code>processElement</code>, 这次老节点已经挂载, 直接走更新程序<ul><li>单步进入 <code>updateElement</code> 该函数分别对比了 <code>props</code> 与 子节点并更新</li></ul></li></ul></li><li><p>触发生命周期函数</p></li></ol><p><strong>总结</strong></p><pre class="mermaid">graph TB

init((初始化组件)) --> createAPp[将App交给createApp, 将App包装为vnode] --- norm1[将vnode应用normalizeChildren配置, 交给render渲染]  --> renderdispatch[render直接交给patch] --> check[patch检查类型] --为组件--> processComponent[交给processComponent判断状态] --为新节点--> mountComponent[执行mountComponent挂载vnode: 构造instance, 运行 setup, 获取 render] --> effect[注册render的effect] --> run[执行effect, 检测是否挂载]  --没有--> patch2(递归patch子节点)

update((reactive更新)) -.-> run[执行effect, 检测是否挂载] -.-挂载了-.-> newvnode[构造新vnode, diff检查, 复制属性] -.-> patch2 ==> check

check ==为Element==> mountDir(直接修改DOM)</pre><h2 id="实现-reactivity">实现 Reactivity</h2><h3 id="环境搭建">环境搭建</h3><ul><li><p>目录结构</p><p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">.
├── jest.config.js
├── package.json
├── packages
│   └── reactivity
│       ├── index.ts # 入口文件
│       └── __tests__ # 测试文件
│           └── index.spec.ts
├── README-EN.md
├── README.md
└── tsconfig.json # tsc --init<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></p></li><li><p>依赖: <code>typescript</code> / <code>@types/node</code> / <code>jest</code> / <code>ts-jest</code> / <code>@types/jest</code></p></li></ul><h3 id="构建基本-effect-与-reactive">构建基本 <code>effect</code> 与 <code>reactive</code></h3><p><strong>TDD</strong></p><p>TDD(Test-Driven Development), 是敏捷开发中的一项核心实践和技术, 也是一种设计方法论. TDD的原理是在开发功能代码之前, 先编写单元测试用例代码, 测试代码确定需要编写什么产品代码. TDD虽是敏捷方法的核心实践.</p><p><strong>构建基本的 <code>reactive</code></strong></p><p><strong>需求</strong>: 最简单的 <code>reactive</code>, 输入对象并输出对象的代理. 代理对象修改时原对象同步修改</p><ol type="1"><li>测试<pre class="line-numbers language-typescript" data-language="typescript"><code class="language-typescript">it(&#39;Should different&#39;, () &#x3D;&gt; &#123;
  const origin &#x3D; &#123; foo: 1 &#125;;
  const observed &#x3D; reactive(origin); &#x2F;&#x2F; 输入对象并返回代理对象
  expect(observed).not.toBe(origin); &#x2F;&#x2F; observed 和原来的不是一个对象
  observed.foo &#x3D; 3;
  expect(observed.foo).toBe(3); &#x2F;&#x2F; 两者同步修改
  expect(origin.foo).toBe(3);
&#125;);<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li><li>实现 只需要为对象配置一个普通代理<pre class="line-numbers language-typescript" data-language="typescript"><code class="language-typescript">export function reactive(origin) &#123;
  &#x2F;&#x2F; 就是给一个对象, 返回一个 new Proxy
  return new Proxy(origin, &#123;
    &#x2F;&#x2F; 语法见 https:&#x2F;&#x2F;developer.mozilla.org&#x2F;zh-CN&#x2F;docs&#x2F;Web&#x2F;JavaScript&#x2F;Reference&#x2F;Global_Objects&#x2F;Proxy&#x2F;Proxy&#x2F;get
    get(target, key, receiver) &#123;
      return Reflect.get(target, key, receiver);
    &#125;,
    &#x2F;&#x2F; 语法见 https:&#x2F;&#x2F;developer.mozilla.org&#x2F;zh-CN&#x2F;docs&#x2F;Web&#x2F;JavaScript&#x2F;Reference&#x2F;Global_Objects&#x2F;Proxy&#x2F;Proxy&#x2F;set
    set(target, key, value, receiver) &#123;
      return Reflect.set(target, key, value, receiver);
    &#125;,
  &#125;);
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>唯一的难点就是 <code>Proxy</code> 语法</li><li>重构: 无</li></ol><p><strong>构建基本的 <code>effect</code></strong></p><p><strong>需求</strong>: 1. 输入函数, 执行函数, 当函数中被 <code>[GET]</code> 的响应式对象发生变化时重新执行函数 2. 返回一个函数 <code>runner</code>, 当执行 <code>runner</code> 时执行 <code>effect</code> 传入的函数</p><p><strong>需求分析</strong>: 1. 为什么是函数中被 <code>[GET]</code> 的响应式对象变化时重新执行函数, <code>[SET]</code> 不行吗? 不行, 响应式对象被 <code>[SET]</code> 后如果执行了函数, 响应式对象会被重新 <code>[SET]</code>, 那么上一次 <code>[SET]</code> 就没用了. 同时如果函数中其他变量不变只有响应式对象被 <code>[SET]</code> 此时执行函数并不会使得函数中变量值发生变化(毕竟变化的响应式变量没有被 <code>[GET]</code>), 不会产生 sideEffect. 2. 执行流程: 开始执行函数 -&gt; <code>[GET]</code> 响应式对象 -&gt; 结束执行函数 -&gt; 当响应式对象被 <code>[SET]</code> -&gt; 执行函数 可以发现只需要让响应式对象知道当自己变化时哪些 <code>effect</code> 需要执行就可以了, 至于 <code>effect</code> 知不知道响应式对象是谁那无所谓. 可以在函数执行期间执行依赖收集, 为 <code>[GET]</code> 的响应式对象注册 Effect Function, 在响应式对象修改时执行其注册的 Effect Function.</p><p> </p><ol type="1"><li>测试:<pre class="line-numbers language-typescript" data-language="typescript"><code class="language-typescript">describe(&#39;Effect test&#39;, () &#x3D;&gt; &#123;
  it(&#39;Should sync&#39;, () &#x3D;&gt; &#123;
    const origin &#x3D; &#123; foo: 1 &#125;;
    const observed &#x3D; reactive(origin);
    let bar;
    const runner &#x3D; effect(() &#x3D;&gt; &#123;
      bar &#x3D; observed.foo;
    &#125;);
    expect(observed.foo).toBe(1); &#x2F;&#x2F; origin -&gt; observed
    expect(bar).toBe(1); &#x2F;&#x2F; 立即执行 fn
    observed.foo &#x3D; 2; &#x2F;&#x2F; 修改有 [GET] 的响应式对象
    expect(observed.foo).toBe(2); &#x2F;&#x2F; 响应式对象变化
    expect(origin.foo).toBe(2); &#x2F;&#x2F; 原对象变化
    expect(bar).toBe(2); &#x2F;&#x2F; 执行函数
  &#125;);

  it(&#39;Should return runner&#39;, () &#x3D;&gt; &#123;
    const origin &#x3D; &#123; foo: 1 &#125;;
    const observed &#x3D; reactive(origin);
    console.info &#x3D; jest.fn(); &#x2F;&#x2F; 劫持 console.info
    let bar;
    const runner &#x3D; effect(() &#x3D;&gt; &#123;
      console.info(&#39;I RUN&#39;);
      bar &#x3D; observed.foo;
    &#125;);
    expect(console.info).toBeCalledTimes(1); &#x2F;&#x2F; 立即执行 fn, console.info 被调用 1 次
    observed.foo &#x3D; 2;
    expect(console.info).toBeCalledTimes(2); &#x2F;&#x2F; 响应式对象发生变化执行 fn, console.info 被调用 2 次
    runner(); &#x2F;&#x2F; 手动调用 runner, console.info 被调用 3 次
    expect(console.info).toBeCalledTimes(3);
  &#125;);
&#125;);<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li><li>实现 利用 <code>targetMap</code> 实现响应式对象 -&gt; Key -&gt; Effective Function 的映射. 导出 <code>track</code> 与 <code>trigger</code> 用于收集与触发依赖<pre class="line-numbers language-typescript" data-language="typescript"><code class="language-typescript">&#x2F;&#x2F; target: Object &#x3D;&gt; keyMap:(string&#x3D;&gt;Set)
&#x2F;&#x2F; keyMap: string &#x3D;&gt; Set
const targetMap: Map&lt;any, Map&lt;string, Set&lt;EffectReactive&gt;&gt;&gt; &#x3D; new Map();
let activeEffectFn: any &#x3D; undefined;

class EffectReactive &#123;
  runner: (...args: any[]) &#x3D;&gt; any;

  constructor(public fn) &#123;
    this.runner &#x3D; this.run.bind(this);
    activeEffectFn &#x3D; this; &#x2F;&#x2F; 全局注册当前正在收集依赖的 Effect
    this.run(); &#x2F;&#x2F; 执行函数
    activeEffectFn &#x3D; undefined; &#x2F;&#x2F; 取消注册
  &#125;

  run() &#123;
    this.fn();
  &#125;
&#125;

export function effect(fn) &#123;
  &#x2F;&#x2F; 考虑到 effect 上动作很多, 我们将其抽离为 EffectFunction 函数
  return new EffectReactive(fn).runner;
&#125;

&#x2F;&#x2F; 依赖收集函数, 由 &#96;[GET]&#96; 触发, 该函数检查是否有 active 的 Effect, 有就收集依赖
export function track(target, key) &#123;
  if (!activeEffect) return;
  if (!targetMap.has(target)) targetMap.set(target, new Map());
  const keyMap &#x3D; targetMap.get(target)!;
  if (!keyMap.has(key)) keyMap.set(key, new Set());
  const dependenceEffect &#x3D; keyMap.get(key)!;
  dependenceEffect.add(activeEffect);
&#125;

&#x2F;&#x2F; 触发函数, 当响应式对象被 &#96;[SET]&#96; 时尝试触发其收集的所有 Effect
export function trigger(target, key) &#123;
  const keyMap &#x3D; targetMap.get(target)!;
  if (!keyMap) return;
  const depSet &#x3D; keyMap.get(key)!;
  if (!depSet) return;
  [...depSet].forEach((d) &#x3D;&gt; d.run());
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>在 <code>Proxy</code> 上同步修改<pre class="line-numbers language-diff" data-language="diff"><code class="language-diff">export function reactive(origin) &#123;
  return new Proxy(origin, &#123;
    get(target, key, receiver) &#123;
+     track(target, key);
      return Reflect.get(target, key, receiver);
    &#125;,
    set(target, key, value, receiver) &#123;
+     &#x2F;&#x2F; 这两行顺序反了就寄了
      const res &#x3D; Reflect.set(target, key, value, receiver);
+     trigger(target, key);
      return res;
    &#125;,
  &#125;);
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li><li>重构: 上面这个代码有点问题, 我们只在构造 EffectFunction 时收集了依赖, 但是并不能收集全<pre class="line-numbers language-typescript" data-language="typescript"><code class="language-typescript">it(&#39;dym track&#39;, () &#x3D;&gt; &#123;
  const origin1 &#x3D; &#123; foo: 1 &#125;;
  const observe1 &#x3D; reactive(origin1);
  const origin2 &#x3D; &#123; foo: 100 &#125;;
  const observe2 &#x3D; reactive(origin2);
  let cnt &#x3D; 0,
    ob &#x3D; 0;
  effect(() &#x3D;&gt; &#123;
    if (cnt &#x3D;&#x3D; 0) &#123;
      ob &#x3D; observe1.foo;
    &#125; else &#123;
      ob &#x3D; observe2.foo;
    &#125;
    cnt++;
  &#125;);
  expect(ob).toBe(1);
  observe1.foo &#x3D; 2;
  expect(ob).toBe(100);
  observe2.foo &#x3D; 200;
  expect(ob).toBe(200);
&#125;);<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>这个测试就无法通过, 因为 <code>observe2</code> 理论上应该在 <code>observe1.set</code> 调用 <code>run</code> 的时候收集依赖, 所以应该修改构造函数和 <code>run</code> 为<pre class="line-numbers language-typescript" data-language="typescript"><code class="language-typescript">constructor(public fn, options: any) &#123;
  &#x2F;&#x2F; ...
  this.run();
&#125;

run() &#123;
  activeEffect &#x3D; this;
  const res &#x3D; this.fn();
  activeEffect &#x3D; undefined;
  return res;
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>我们知道, 所有的依赖收集都是通过 fn 中对 reactive 的 <code>[GET]</code> 实现的, 我可以保证只要执行 <code>fn</code> 在其前后都加入了依赖收集的 flag 就可以. 调用 <code>fn</code> 只可能发生在</li><li>构造函数</li><li>手动执行 <code>runner</code></li><li>reactive 执行 <code>[SET]</code> 触发 trigger</li></ol><p>这三部分要执行的都是 <code>run</code> 我们可以保证只要执行 <code>run</code> 就触发依赖收集</p><h3 id="构建-effect-的-scheduler-选项-watch">构建 <code>effect</code> 的 <code>scheduler</code> 选项 (<code>watch</code>)</h3><p><strong>需求</strong>: 为 <code>effect</code> 传入第二个参数, 参数是一个对象, 其中包含 <code>scheduler</code> 函数, 当构造 Effect 时执行传入的第一个函数参数, 当响应式函数变化时执行 <code>scheduler</code> 函数. 这与 Vue 3 的 <code>watch</code> 类似</p><p><strong>需求分析</strong>: 在构造 Effect 的时候传入配置并在触发的时候判断是否有 <code>scheduler</code> 函数</p><ol type="1"><li>测试</li></ol><p><pre class="line-numbers language-typescript" data-language="typescript"><code class="language-typescript">it(&#39;Shound run scheduler&#39;, () &#x3D;&gt; &#123;
  const origin &#x3D; &#123; foo: 1 &#125;;
  const observed &#x3D; reactive(origin);
  let bar;
  effect(
    () &#x3D;&gt; &#123;
      bar &#x3D; observed.foo;
    &#125;,
    &#123; &#x2F;&#x2F; 传入配置
      scheduler() &#123;
        bar &#x3D; -observed.foo;
      &#125;,
    &#125;
  );
  expect(bar).toBe(1); &#x2F;&#x2F; 第一次运行 fn 函数
  observed.foo &#x3D; 2;
  expect(bar).toBe(-2); &#x2F;&#x2F; 第二次运行 scheduler 函数
&#125;);<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></p><ol start="2" type="1"><li>实现</li></ol><ul><li>修改 effect 函数, 加入配置项<pre class="line-numbers language-typescript" data-language="typescript"><code class="language-typescript">export function effect(fn, options &#x3D; &#123;&#125;) &#123;
  return new EffectReactive(fn, options).runner;
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre></li><li>修改 EffectReactive 的构造函数加载配置项<pre class="line-numbers language-typescript" data-language="typescript"><code class="language-typescript">class EffectReactive &#123;
  runner: (...args: any[]) &#x3D;&gt; any;
  scheduler: (...args: any[]) &#x3D;&gt; any | undefined;

  constructor(public fn, options: any) &#123;
    this.scheduler &#x3D; options.scheduler;
    &#x2F;&#x2F; ...
  &#125;

  &#x2F;&#x2F; ...
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li><li>修改触发函数<pre class="line-numbers language-typescript" data-language="typescript"><code class="language-typescript">export function trigger(target, key) &#123;
  &#x2F;&#x2F; ...
  [...depSet].forEach((d) &#x3D;&gt; (d.scheduler ? d.scheduler() : d.run()));
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre></li><li>重构: 无</li></ul><p><strong>什么时候尝试抽离函数 / 对象</strong></p><ol type="1"><li>函数上有很多动作</li><li>函数作用范围广, 语义差</li></ol><h3 id="构建-effect-的-stop-与-onstop-选项">构建 <code>effect</code> 的 <code>stop</code> 与 <code>onStop</code> 选项</h3><p><strong>需求</strong>: 1. 定义一个外部函数 <code>stop</code>. 传入 <code>runner</code> 让 <code>runner</code> 不再被响应式对象 trigger 2. <code>effect</code> 中加入 <code>onStop</code> 配置, 在 <code>stop</code> 时调用</p><p><strong>需求分析</strong>: 只需要将 EffectFunction 从响应式对象的依赖表中删除即可. 但是我们之前就没记录有哪些响应式对象将 EffectFunction 作为依赖..., 所以需要开一个 Set 记录这些响应式对象. 同时, 我们不需要记录依赖的对象是什么, 只需要记录 KeyMap 对应的 Set.</p><ol type="1"><li>测试<pre class="line-numbers language-typescript" data-language="typescript"><code class="language-typescript">it(&#39;Should stop trigger&#39;, () &#x3D;&gt; &#123;
  const origin &#x3D; &#123; foo: 1 &#125;;
  const observed &#x3D; reactive(origin);
  let bar;
  const runner &#x3D; effect(
    () &#x3D;&gt; &#123;
      bar &#x3D; observed.foo; &#x2F;&#x2F; 立即执行
    &#125;,
    &#123;
      onStop() &#123;
        if (bar &gt; 0) bar &#x3D; 0; &#x2F;&#x2F; 如果首次调用置 0
        bar--;
      &#125;,
    &#125;
  );
  expect(bar).toBe(1); &#x2F;&#x2F; 立即执行
  stop(runner);
  expect(bar).toBe(-1); &#x2F;&#x2F; 停止后第一次执行为 -1
  observed.foo &#x3D; 2;
  expect(bar).toBe(-1); &#x2F;&#x2F; reactive 变化也不调用 fn
  stop(runner)
  expect(bar).toBe(-1); &#x2F;&#x2F; 反复 stop 不反复执行 onStop
&#125;);<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li><li>实现 修正 EffectReactive<pre class="line-numbers language-typescript" data-language="typescript"><code class="language-typescript">class EffectReactive &#123;
  runner: &#123; &#x2F;&#x2F; effect 只返回 runner, stop 函数需要根据 runner 找到 EffectReactive, 所以要在函数上加一个属性记录一下
    (...args: any[]): any;
    effect?: EffectReactive;
  &#125;;
  onStop: (...args: any[]) &#x3D;&gt; any | undefined; &#x2F;&#x2F; stop 回调
  deps: Set&lt;Set&lt;EffectReactive&gt;&gt;; &#x2F;&#x2F; 收集了这个函数依赖的变量的依赖表集合
  active: boolean; &#x2F;&#x2F; EffectReactive 是否运行 (stop 时置 0)
  &#x2F;&#x2F; ...

  constructor(public fn, options: any) &#123;
    this.runner &#x3D; this.run.bind(this);
    this.runner.effect &#x3D; this;
    this.onStop &#x3D; options.onStop;
    this.deps &#x3D; new Set();
    this.active &#x3D; true;
    &#x2F;&#x2F; ...
  &#125;

  run() &#123;
    &#x2F;&#x2F; 如果用户手动执行 runner 那么只执行 fn, 不追踪依赖, 放置依赖追踪给已经解除依赖的元素再绑定上依赖
    if (!this.active) return this.fn();
    activeEffect &#x3D; this;
    const res &#x3D; this.fn();
    activeEffect &#x3D; undefined;
    return res;
  &#125;
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>修正依赖收集函数<pre class="line-numbers language-typescript" data-language="typescript"><code class="language-typescript">export function track(target, key) &#123;
  &#x2F;&#x2F;
  dependenceEffect.add(activeEffect);
  &#x2F;&#x2F; 为当前正在依赖收集的 effect 的依赖上加入这个 key 的依赖表
  activeEffect.deps.add(dependenceEffect);
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>实现 <code>stop</code> 函数<pre class="line-numbers language-typescript" data-language="typescript"><code class="language-typescript">export function stop(runner) &#123;
  &#x2F;&#x2F; 不反复执行
  if (!runner.effect.active) return;
  runner.effect.active &#x3D; false;
  &#x2F;&#x2F; 找到所有收集过 effect 的变量, 将 effect 从依赖表中删除
  [...runner.effect.deps].forEach((d) &#x3D;&gt; d.delete(runner.effect));
  &#x2F;&#x2F; 执行 onStop
  runner.effect.onStop &amp;&amp; runner.effect.onStop();
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li><li>重构: 无</li></ol><h3 id="构建-proxy-的-readonly">构建 <code>Proxy</code> 的 <code>Readonly</code></h3><p><strong>需求</strong>: <code>readonly</code> 与 <code>reactive</code> 类似, 不过不支持 <code>set</code></p><p><strong>需求分析</strong>: 一个元素不支持 <code>set</code> 也就不可能触发依赖, 所以也没有必要做依赖收集. 所以只需要精简一下 <code>reactive</code>. 可以发现, 不同权限的变量只是在构造的时候采用不同的 <code>[GET]</code> 与 <code>[SET]</code> 策略. 可以将 <code>[GET]</code> 与 <code>[SET]</code> 抽离出来</p><ol type="1"><li>测试<pre class="line-numbers language-typescript" data-language="typescript"><code class="language-typescript">it(&#39;Happy path&#39;, () &#x3D;&gt; &#123;
  const origin &#x3D; &#123; foo: 1 &#125;;
  const observed &#x3D; readonly(origin);
  console.warn &#x3D; jest.fn();
  expect(observed.foo).toBe(1); &#x2F;&#x2F; 将原始对象包装为只读对象
  expect(console.warn).not.toHaveBeenCalled(); &#x2F;&#x2F; 最开始不报错
  observed.foo &#x3D; 2; &#x2F;&#x2F; 修改, 静默失效, 报 warning
  expect(console.warn).toBeCalledTimes(1); &#x2F;&#x2F; warning 被调用一次
  expect(observed.foo).toBe(1); &#x2F;&#x2F; readOnly 静默失效
&#125;);<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li><li>实现 抽离 <code>[GET]</code> 与 <code>[SET]</code><pre class="line-numbers language-typescript" data-language="typescript"><code class="language-typescript">&#x2F;&#x2F; reactive 的 [GET]
function get(target, key, receiver) &#123;
  track(target, key);
  return Reflect.get(target, key, receiver);
&#125;

&#x2F;&#x2F; reactive 的 [SET]
function set(target, key, value, receiver) &#123;
  const res &#x3D; Reflect.set(target, key, value, receiver);
  trigger(target, key);
  return res;
&#125;

function getReadonly(target, key, receiver) &#123;
  return Reflect.get(target, key, receiver);
&#125;

function setReadonly(target, key, value, receiver) &#123;
  console.warn(&#39;Can not set readonly&#39;);
  &#x2F;&#x2F; 要返回一下设置结果, 如果返回 false 会抛出异常, 而我们只希望静默失效
  return true;
&#125;

export const proxyConfig &#x3D; &#123;
  get,
  set,
&#125;;

export const proxyReadonlyConfig &#x3D; &#123;
  get: getReadonly,
  set: setReadonly,
&#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>抽离对象创建函数<pre class="line-numbers language-typescript" data-language="typescript"><code class="language-typescript">function createReactiveObject(origin, readonly &#x3D; false) &#123;
  if (readonly) return new Proxy(origin, proxyReadonlyConfig);
  return new Proxy(origin, proxyConfig);
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>重写 <code>reactive</code> 构建 <code>readonly</code><pre class="line-numbers language-typescript" data-language="typescript"><code class="language-typescript">export function reactive(origin) &#123;
  return createReactiveObject(origin);
&#125;

export function readonly(origin) &#123;
  return createReactiveObject(origin, true);
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li><li>重构: 上面的就是重构后的代码</li></ol><h3 id="构建工具函数-isreadonly-isreactive-isproxy">构建工具函数 <code>isReadonly</code>, <code>isReactive</code>, <code>isProxy</code></h3><p><strong>需求</strong>: 构建工具函数, <code>isReadonly</code>, <code>isReactive</code>, <code>isProxy</code>(前两个函数二选一).</p><p><strong>需求分析</strong>: 只需要在 <code>[GET]</code> 上特判即可</p><ol type="1"><li>测试<pre class="line-numbers language-typescript" data-language="typescript"><code class="language-typescript">it(&#39;isReadonly test&#39;, () &#x3D;&gt; &#123;
  const origin &#x3D; &#123; foo: 1 &#125;;
  const observed &#x3D; readonly(origin);
  expect(isReadonly(observed)).toBe(true);
  expect(isReactive(observed)).toBe(false);
&#125;);

it(&#39;isReactive test&#39;, () &#x3D;&gt; &#123;
  const origin &#x3D; &#123; foo: 1 &#125;;
  const observed &#x3D; reactive(origin);
  expect(isReadonly(observed)).toBe(false);
  expect(isReactive(observed)).toBe(true);
&#125;);

it(&#39;isProxy test&#39;, () &#x3D;&gt; &#123;
  const origin &#x3D; &#123; foo: 1 &#125;;
  const observed &#x3D; readonly(origin);
  expect(isProxy(observed)).toBe(true);
&#125;);<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li><li>实现 构造个枚举<pre class="line-numbers language-typescript" data-language="typescript"><code class="language-typescript">export const enum ReactiveFlag &#123;
  IS_REACTIVE &#x3D; &#39;__v_isReactive&#39;,
  IS_READONLY &#x3D; &#39;__v_isReadonly&#39;,
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>实现函数<pre class="line-numbers language-typescript" data-language="typescript"><code class="language-typescript">export function isReactive(value) &#123;
  &#x2F;&#x2F; 要转一下 Boolean 因为非 reactive 对象会返回 undefined
  return !!value[ReactiveFlag.IS_REACTIVE];
&#125;

export function isReadonly(value) &#123;
  return !!value[ReactiveFlag.IS_READONLY];
&#125;

export function isProxy(value) &#123;
  return isReactive(value) || isReadonly(value);
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>修改 <code>[GET]</code><pre class="line-numbers language-typescript" data-language="typescript"><code class="language-typescript">const reactiveFlags &#x3D; &#123;
  [ReactiveFlag.IS_REACTIVE]: true,
  [ReactiveFlag.IS_READONLY]: false,
&#125;;

const readonlyFlags &#x3D; &#123;
  [ReactiveFlag.IS_REACTIVE]: false,
  [ReactiveFlag.IS_READONLY]: true,
&#125;;

function get(target, key, receiver) &#123;
  if (Object.keys(reactiveFlags).find(d&#x3D;&gt;d&#x3D;&#x3D;&#x3D;key)) return reactiveFlags[key];
  &#x2F;&#x2F; ...
&#125;

function getReadonly(target, key, receiver) &#123;
  if (Object.keys(readonlyFlags).find(d&#x3D;&gt;d&#x3D;&#x3D;&#x3D;key)) return readonlyFlags[key];
  &#x2F;&#x2F; ...
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li><li>重构: 无</li></ol><h3 id="实现-reactive-readonly-嵌套">实现 <code>reactive</code> / <code>readonly</code> 嵌套</h3><p><strong>需求:</strong> 若 <code>reactive</code> / <code>readonly</code> 内部 value 为对象, 那么该对象也应该是 <code>reactive</code> / <code>readonly</code></p><p><strong>需求分析:</strong> 我最开始的想法是在构造 <code>reactive</code> 的时候遍历所有属性, 然后为这些属性配置 <code>reactive</code>. 然而, 这无法将动态添加的对象转为 <code>reactive</code>. 考虑需求, 我们希望让内层对象支持 reactive, 实际上是希望让内层对象也支持依赖收集等 <code>reactive</code> 功能, 而这些功能都是在对象被 <code>[GET]</code> 的时候被激活的. 也就是说我们最晚可以在首次访问属性的将内层对象转换为 <code>reactive</code>.</p><ol type="1"><li>测试(只写了 <code>reactive</code> 的)<pre class="line-numbers language-typescript" data-language="typescript"><code class="language-typescript">it(&#39;Should nested track&#39;, () &#x3D;&gt; &#123;
  const origin &#x3D; &#123;
    foo: &#123; a: 1 &#125;,
    bar: [&#123; b: 2 &#125;],
  &#125;;
  const observe &#x3D; reactive(origin);
  expect(isReactive(observe)).toBe(true);
  expect(isReactive(observe.foo)).toBe(true);
  expect(isReactive(observe.bar)).toBe(true);
  expect(isReactive(observe.bar[0])).toBe(true);
&#125;);<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li><li>实现 只需要在 <code>[GET]</code> 的时候判断属性是否是对象, 如果是对象那么返回包装后的 <code>reactive</code></li></ol><p><pre class="line-numbers language-typescript" data-language="typescript"><code class="language-typescript">function get(target, key, receiver) &#123;
  if (Object.keys(reactiveFlags).find((d) &#x3D;&gt; d &#x3D;&#x3D;&#x3D; key))
    return reactiveFlags[key];
  const res &#x3D; Reflect.get(target, key, receiver); &#x2F;&#x2F; 获取结果
  if (isObject(res)) return reactive(res); &#x2F;&#x2F; 如果结果是对象, 将其包装为 reactive
  track(target, key);
  return res;
&#125;

function getReadonly(target, key, receiver) &#123;
  if (Object.keys(readonlyFlags).find((d) &#x3D;&gt; d &#x3D;&#x3D;&#x3D; key))
    return readonlyFlags[key];
  const res &#x3D; Reflect.get(target, key, receiver); &#x2F;&#x2F; 获取结果
  if (isObject(res)) return readonly(res); &#x2F;&#x2F; 如果结果是对象, 将其包装为 readonly
  return res;
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>在 <code>packages/share/index.ts</code> 中构造工具函数判断输入是否是对象<pre class="line-numbers language-typescript" data-language="typescript"><code class="language-typescript">export function isObject(v) &#123;
  return v !&#x3D;&#x3D; null &amp;&amp; typeof v &#x3D;&#x3D;&#x3D; &#39;object&#39;;
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>3. 改进: 我们并没有实现内层 reactive 的持久化, 也就是说每次 reactive 的结果是不同的... 实现内层对象持久化<pre class="line-numbers language-typescript" data-language="typescript"><code class="language-typescript">const reactiveMap &#x3D; new Map();
const readonlyMap &#x3D; new Map();

export function reactive(origin) &#123;
  if (!reactiveMap.has(origin))
    reactiveMap.set(origin, createReactiveObject(origin));
  return reactiveMap.get(origin)!;
&#125;

export function readonly(origin) &#123;
  if (!readonlyMap.has(origin))
    readonlyMap.set(origin, createReactiveObject(origin, true));
  return readonlyMap.get(origin)!;
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></p><p><strong>注意</strong></p><ol type="1"><li><strong>JS是动态语言, 不要尝试做静态代码分析</strong>: 我们在实现功能的时候应该考虑什么时候完成工作不晚, 不遗漏而不是相静态语言一样想什么时候可以操作数据</li><li><strong>实现功能时想想这个功能希望我们对外表现为什么样子</strong>: 思考是什么而不是怎么做, 比如内层 reactive 的第一版代码并没有实现将对象转为 reactive 并附着在对象上, 而是考虑如果一个内层对象是 reactive, 那么我们应该在 <code>[GET]</code> 的时候表现的与原始对象不同. 这就启发我们只需要在 <code>[GET]</code> 的时候处理数据就可以而不需要在构造对象的时候实现这一功能.</li></ol><h3 id="构建-shadowreadonly">构建 <code>shadowReadonly</code></h3><p><strong>需求:</strong> <code>shadowReadonly</code> 就是只对对象外层实现 readonly, 内部对象不管, 不 Proxy</p><p><strong>需求分析:</strong> 实际上就是不支持嵌套的 readonly</p><ol type="1"><li>测试<pre class="line-numbers language-typescript" data-language="typescript"><code class="language-typescript">it(&#39;Happy path&#39;, () &#x3D;&gt; &#123;
  const origin &#x3D; &#123; foo: &#123; bar: 2 &#125; &#125;;
  const observed &#x3D; shadowReadonly(origin);
  console.warn &#x3D; jest.fn();
  expect(console.warn).not.toHaveBeenCalled();
  observed.foo &#x3D; 0; &#x2F;&#x2F; 外层禁止修改
  expect(console.warn).toBeCalledTimes(1);
  expect(observed.foo.bar).toBe(2);
  observed.foo.bar &#x3D; 0; &#x2F;&#x2F; 内部不管
  expect(observed.foo.bar).toBe(0);
  expect(console.warn).toBeCalledTimes(1);
  expect(isProxy(observed.foo)).toBe(false);
&#125;);<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li><li>实现<pre class="line-numbers language-typescript" data-language="typescript"><code class="language-typescript">function getShadowReadonly(target, key, receiver) &#123;
  if (Object.keys(readonlyFlags).find((d) &#x3D;&gt; d &#x3D;&#x3D;&#x3D; key))
    return readonlyFlags[key];
  &#x2F;&#x2F; 其实就是不支持嵌套追踪的 readonly. shadowReadonly 的元素一定是非 reactive 对象, 所以直接返回
  return Reflect.get(target, key, receiver);
&#125;

export const proxyShadowReadonlyConfig &#x3D; &#123;
  get: getShadowReadonly,
  set: setReadonly,
&#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>实现 shadowReadonly<pre class="line-numbers language-typescript" data-language="typescript"><code class="language-typescript">const shadowReadonlyMap &#x3D; new Map();

function createReactiveObject(origin, readonly &#x3D; false, shadow &#x3D; false) &#123;
  if (shadow &amp;&amp; readonly) return new Proxy(origin, proxyShadowReadonlyConfig);
  if (readonly) return new Proxy(origin, proxyReadonlyConfig);
  return new Proxy(origin, proxyConfig);
&#125;

export function shadowReadonly(origin) &#123;
  if (!shadowReadonlyMap.has(origin))
    shadowReadonlyMap.set(origin, createReactiveObject(origin, true, true));
  return shadowReadonlyMap.get(origin)!;
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li><li>重构</li></ol><h3 id="构建-ref">构建 <code>ref</code></h3><p><strong>需求</strong>: 实现 <code>ref</code> - 如果 <code>ref(value)</code> 输入的是不是对象, 那么可以 - 通过 <code>.value</code> 访问值 - 通过 <code>.value</code> 更新值, 如果赋值时新值与旧值一样则什么都不做 - 支持类似 <code>reactive</code> 的依赖收集与触发 - 如果 <code>ref(value)</code> 输入的是对象, 那么可以 - 在上面的基础上对要求对象支持 <code>reactive</code></p><p><strong>需求分析</strong>:</p><ul><li>我最开始想到的是 <code>ref = (value) =&gt; reactive(&#123;value&#125;)</code> 但是如果只是这么简单实现, 那么 <code>ref</code> 的非 <code>value</code> 属性也将变为 <code>reactive</code>. 同时可以预见这样实现的 <code>ref</code> 性能不及标准 <code>ref</code>.</li><li><code>ref</code> 的特点是<strong>外层有且只有</strong> <code>value</code> 一个 <code>key</code>, 这意味我们在实现时<ul><li>不用使用全局 <code>targetMap</code> (只有一个depSet)</li><li>不用像 <code>reactive</code> 一样实现一个 Proxy, 可以只实现一个 <code>[GET]</code> &amp; <code>[SET]</code>.</li></ul></li><li>考虑到 <code>ref</code> 的<strong>输入可能是对象或非对象</strong><ul><li>我们能不使用全局的 <code>targetMap</code>, 否则两个值相同的 <code>ref</code> 会被判定为同一个 <code>keyMap</code></li><li>若输入为对象, 在对比赋值时新值与旧值一样不能简单的比较 <code>_value === newValue</code>. 若输入为对象, 那么 <code>reactive(obj) !== obj</code>. 我们还需要保存输入的原始值</li></ul></li></ul><ol type="1"><li><p>测试 <code>ref</code> 非对象时<pre class="line-numbers language-typescript" data-language="typescript"><code class="language-typescript">it(&#39;should be reactive&#39;, () &#x3D;&gt; &#123;
  const a &#x3D; ref(1);
  let dummy;
  let calls &#x3D; 0;
  effect(() &#x3D;&gt; &#123;
    calls++;
    dummy &#x3D; a.value;
  &#125;);
  expect(calls).toBe(1); &#x2F;&#x2F; 构造 EffectFunction 执行一次
  expect(dummy).toBe(1);
  a.value &#x3D; 2; &#x2F;&#x2F; ref 也支持依赖收集与触发
  expect(calls).toBe(2);
  expect(dummy).toBe(2);
  a.value &#x3D; 2; &#x2F;&#x2F; 同值不触发
  expect(calls).toBe(2);
  expect(dummy).toBe(2);
&#125;);<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><code>ref</code> 对象时要把内层对象变为 <code>reactive</code>, 对象也可以变为非对象<pre class="line-numbers language-typescript" data-language="typescript"><code class="language-typescript">it(&#39;should convert to reactive&#39;, () &#x3D;&gt; &#123;
  const origin &#x3D; &#123; foo: 1 &#125;;
  const a &#x3D; ref(origin);
  let dummy;
  let calls &#x3D; 0;
  effect(() &#x3D;&gt; &#123;
    calls++;
    dummy &#x3D; a.value.foo ? a.value.foo : a.value;
  &#125;);
  expect(calls).toBe(1); &#x2F;&#x2F; 构造 EffectFunction 执行一次
  expect(dummy).toBe(1);
  a.value.foo &#x3D; 2; &#x2F;&#x2F; ref 也支持依赖收集与触发
  expect(calls).toBe(2);
  expect(dummy).toBe(2);
  a.value &#x3D; origin; &#x2F;&#x2F; 同值不触发
  expect(calls).toBe(2);
  expect(dummy).toBe(2);
  a.value &#x3D; &#123; foo: 1 &#125;; &#x2F;&#x2F; 同值不触发
  expect(calls).toBe(3);
  expect(dummy).toBe(1);
  a.value &#x3D; 5; &#x2F;&#x2F; 变为非对象
  expect(calls).toBe(4);
  expect(dummy).toBe(5);
&#125;);<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></p></li><li><p>实现</p></li></ol><p><pre class="line-numbers language-typescript" data-language="typescript"><code class="language-typescript">&#x2F;&#x2F; 与 reactive 直接返回一个 Proxy 不同, 我们只有 value 一个属性, 所以要手动构建一个对象
class RefImpl &#123;
  &#x2F;&#x2F; 这里我们不使用全局的 targetMap 原因是
  &#x2F;&#x2F;   - 我们这里的 Key 可以不是对象, 两个值相同的 ref 会被判定为同一个 key
  &#x2F;&#x2F;   - 只存在一个 Key: value, 所以没有必要使用两个 Map, 只需要一个 Set 就可以存储所有的 EffectReactive
  private deps: Set&lt;EffectReactive&gt;;
  private _value;
  private rawValue;
  constructor(value) &#123;
    this.deps &#x3D; new Set();
    this._value &#x3D; isObject(value) ? reactive(value) : value;
    this.rawValue &#x3D; value;
  &#125;

  &#x2F;&#x2F; 只需要 value 的 [SET] [GET] 就可以实现
  get value() &#123;
    trackEffect(this.deps); &#x2F;&#x2F; 依赖追踪
    return this._value;
  &#125;

  set value(newValue) &#123;
    &#x2F;&#x2F; 重复赋值不触发, 考虑两种情况
    &#x2F;&#x2F;   - this._value 不是 Object, 直接比较
    &#x2F;&#x2F;   - this._value 是 Object, 此时 this._value 是一个 reactive, reactive(obj) !&#x3D;&#x3D; obj, 必须使用原始值比较
    if (this.rawValue &#x3D;&#x3D;&#x3D; newValue) return;
    this.rawValue &#x3D; newValue;
    this._value &#x3D; isObject(newValue) ? reactive(newValue) : newValue;
    triggerEffect(this.deps); &#x2F;&#x2F; 触发依赖
  &#125;
&#125;

export function ref(value) &#123;
  return new RefImpl(value);
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>在这里, <code>trackEffect</code> 与 <code>triggerEffect</code> 相当于不需要查 <code>Set</code> 的 <code>track</code> 与 <code>trigger</code>(因为只有一个 <code>Set</code>). 我们可以将原来的 <code>track</code> 与 <code>trigger</code> 拆开</p><p><pre class="line-numbers language-typescript" data-language="typescript"><code class="language-typescript">export function track(target, key) &#123;
  if (!activeEffect) return;
  if (!targetMap.has(target)) targetMap.set(target, new Map());
  const keyMap &#x3D; targetMap.get(target)!;
  if (!keyMap.has(key)) keyMap.set(key, new Set());
  &#x2F;&#x2F; 抽成一个函数
  trackEffect(keyMap.get(key)!);
&#125;

export function trackEffect(dependenceEffect) &#123;
  &#x2F;&#x2F; 本来只需要在 track 上判断 activeEffect 但是这个函数可能被 track 或者 RefImpl 调用, 所以还需要在判断一次
  if (!activeEffect) return;
  dependenceEffect.add(activeEffect);
  activeEffect.deps.add(dependenceEffect);
&#125;

export function trigger(target, key) &#123;
  const keyMap &#x3D; targetMap.get(target)!;
  if (!keyMap) return;
  const depSet &#x3D; keyMap.get(key)!;
  if (!depSet) return;
  &#x2F;&#x2F; 抽成一个函数
  triggerEffect(depSet);
&#125;

export function triggerEffect(depSet) &#123;
  [...depSet].forEach((d) &#x3D;&gt; (d.scheduler ? d.scheduler() : d.run()));
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></p><h3 id="构建工具函数-isref-unref-proxyrefs">构建工具函数 <code>isRef</code> &amp; <code>unRef</code> &amp; <code>proxyRefs</code></h3><p><strong>需求</strong>: - <code>isRef</code>: 判断输入是不是 <code>ref</code> - <code>unRef</code>: 返回 <code>ref</code> 的 <code>value</code> - <code>proxyRefs</code>: 模拟 Vue3 的 setup 函数, 通过该函数返回的对象中的 <code>ref</code> 在模板字符串中无需 <code>.value</code> 即可访问与赋值. 简单来说就是输入对象, 在访问对象中浅层 <code>ref</code> 的 <code>Key</code> 时无需 <code>.value</code> 即可访问</p><p><strong>需求分析</strong>: - <code>isRef</code>: 加一个 flag 即可 - <code>unRef</code>: 判断是不是 <code>ref</code>, 是就返回 <code>ref.value</code> - <code>proxyRefs</code>: 构造一个代理, 在读写是判断读写目标是不是 <code>ref</code> 如果是就返回 <code>ref.value</code>. 同时, 在 <code>[SET]</code> 时, 如果新旧值都是 <code>ref</code> 那么直接替换掉旧 <code>ref</code></p><ol type="1"><li><p>测试<pre class="line-numbers language-typescript" data-language="typescript"><code class="language-typescript">it(&#39;isRef&#39;, () &#x3D;&gt; &#123;
  const origin1 &#x3D; 1;
  const origin2 &#x3D; &#123; foo: 1 &#125;;
  const observed1 &#x3D; ref(origin1);
  const observed2 &#x3D; ref(origin2);
  expect(isRef(origin1)).toBe(false);
  expect(isRef(origin2)).toBe(false);
  expect(isRef(observed1)).toBe(true);
  expect(isRef(observed2)).toBe(true);
&#125;);

it(&#39;unRef&#39;, () &#x3D;&gt; &#123;
  const origin1 &#x3D; 1;
  const origin2 &#x3D; &#123; foo: 1 &#125;;
  const observed1 &#x3D; ref(origin1);
  const observed2 &#x3D; ref(origin2);
  expect(unRef(observed1)).toBe(origin1);
  expect(unRef(observed2)).not.toBe(origin2);
  expect(unRef(observed2)).toStrictEqual(origin2);
  expect(unRef(observed2)).toBe(reactive(origin2));
&#125;);

it(&#39;proxyRefs&#39;, () &#x3D;&gt; &#123;
  const user &#x3D; &#123;
    sampleRef: ref(10),
    sampleStr: &#39;demo&#39;,
  &#125;;
  const proxyUser &#x3D; proxyRefs(user);
  expect(user.sampleRef.value).toBe(10);
  expect(proxyUser.sampleRef).toBe(10);
  expect(proxyUser.sampleStr).toBe(&#39;demo&#39;);

  (proxyUser as any).sampleRef &#x3D; 20;
  expect(proxyUser.sampleRef).toBe(20);
  expect(user.sampleRef.value).toBe(20);

  proxyUser.sampleRef &#x3D; ref(10);
  expect(proxyUser.sampleRef).toBe(10);
  expect(user.sampleRef.value).toBe(10);
&#125;);<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></p></li><li><p>实现</p></li></ol><p>打flag<pre class="line-numbers language-typescript" data-language="typescript"><code class="language-typescript">class RefImpl &#123;
  public __v_isRef &#x3D; true;
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>实现 <code>isRef</code> 与 <code>unRef</code><pre class="line-numbers language-typescript" data-language="typescript"><code class="language-typescript">export function unRef(ref) &#123;
  return isRef(ref) ? ref.value : ref;
&#125;

export function isRef(value) &#123;
  return !!value?.__v_isRef;
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>实现 <code>proxyRef</code><pre class="line-numbers language-typescript" data-language="typescript"><code class="language-typescript">export function proxyRefs(origin) &#123;
  return new Proxy(origin, proxyProxyRefConfig);
&#125;

function getProxyRef(target, key, receiver) &#123;
  &#x2F;&#x2F; 不用这么麻烦
  &#x2F;&#x2F; if (isRef(target[key])) return target[key].value;
  &#x2F;&#x2F; return target[key];
  return unRef(target[key]);
&#125;

function setProxyRef(target, key, value, receiver) &#123;
  &#x2F;&#x2F; 只特判 ref &lt;- 普通值
  if (isRef(target[key]) &amp;&amp; !isRef(value)) return (target[key].value &#x3D; value);
  return Reflect.set(target, key, value, receiver);
&#125;

export const proxyProxyRefConfig &#x3D; &#123;
  get: getProxyRef,
  set: setProxyRef,
&#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>3. 重构: 无</p><h3 id="实现-computed">实现 <code>computed</code></h3><p><strong>需求:</strong> 1. 输入一个函数, 返回一个对象, 可以通过 <code>.value</code> 获取函数返回值, 当函数内部 <code>reactive</code> 变化时, 返回值也要变化. 2. 支持 Lazy, 即: 1. 在 <code>computed</code> 内部 <code>reactive</code> 变化时不触发 <code>computed</code> 传入函数 2. 在 <code>[GET]</code> 时才触发 <code>computed</code> 传入函数 3. 若内部 <code>reactive</code> 不变, 重复触发 <code>[GET]</code> 不重复触发传入函数 3. 返回值也是一个 <code>reactive</code> 对象, 即 <code>.value</code> 变化时要触发依赖</p><p><strong>需求分析:</strong></p><ol type="1"><li>测试<pre class="line-numbers language-typescript" data-language="typescript"><code class="language-typescript">it(&#39;should reactive&#39;, () &#x3D;&gt; &#123;
  let cnt &#x3D; 0;
  const observed &#x3D; reactive(&#123; foo: 1 &#125;);
  const bar &#x3D; computed(() &#x3D;&gt; &#123;
    cnt++;
    return observed.foo + 1;
  &#125;);
  expect(cnt).toBe(0); &#x2F;&#x2F; Lazy
  expect(bar.value).toBe(2);
  expect(cnt).toBe(1);
  observed.foo &#x3D; 2;
  expect(cnt).toBe(1); &#x2F;&#x2F; Lazy
  expect(bar.value).toBe(3);
  expect(cnt).toBe(2);
  expect(bar.value).toBe(3);
  expect(bar.value).toBe(3); &#x2F;&#x2F; Lazy
  expect(cnt).toBe(2);
&#125;);

&#x2F;&#x2F; 返回值也可以收集依赖
it(&#39;should trigger effect&#39;, () &#x3D;&gt; &#123;
  const value &#x3D; reactive(&#123;&#125;);
  const cValue &#x3D; computed(() &#x3D;&gt; value.foo);
  let dummy;
  effect(() &#x3D;&gt; &#123;
    dummy &#x3D; cValue.value;
  &#125;);
  expect(dummy).toBe(undefined);
  value.foo &#x3D; 1;
  expect(dummy).toBe(1);
&#125;);<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li><li>实现</li></ol><ul><li>构造一个 <code>old</code>, 当内部 reactive 变化时修改, 如果内部不变就直接使用原 <code>_value</code></li><li>类似构造 <code>ref</code> 的 <code>dep</code> 收集 <code>.value</code> 的依赖</li><li>我们希望在第一次 <code>[GET]</code> 的时候收集依赖, 这可以使用 <code>EffectReactive</code> 实现, 但是为了实现 Lazy 我们又不希望每次内部 <code>reactive</code> 变化都触发依赖. 我们可以采用 <code>scheduler</code> 解决, 每次内部 <code>reactive</code> 变化时候打下标记(<code>old</code>), 并通知 <code>computed</code> 要触发依赖了. 如果 <code>computed</code> 没有依赖那这次就 Lazy 过去了, 如果有那在触发依赖时其他函数会调用计算属性的 <code>[GET]</code> 此时完成刷新</li></ul><p><pre class="line-numbers language-typescript" data-language="typescript"><code class="language-typescript">import &#123;
  effect,
  EffectReactive,
  trackEffect,
  triggerEffect,
&#125; from &#39;.&#x2F;effect&#39;;

class ComputedImpl &#123;
  old: boolean;
  fst: boolean;
  _value: any;
  dep: Set&lt;EffectReactive&gt;;
  effect!: EffectReactive;

  constructor(public fn) &#123;
    this.old &#x3D; false;
    this.fst &#x3D; true;
    this.dep &#x3D; new Set();
  &#125;

  get value() &#123;
    trackEffect(this.dep);
    &#x2F;&#x2F; 为啥人家的代码没 fst 呢? 因为人家的 EffectReactive 每在构造函数的时候 run. 人家可以在构造函数里面注册这个 effect
    if (this.fst) &#123;
      this.fst &#x3D; false;
      this.effect &#x3D; new EffectReactive(() &#x3D;&gt; (this._value &#x3D; this.fn()), &#123;
        scheduler: () &#x3D;&gt; &#123;
          this.old &#x3D; true;
          triggerEffect(this.dep);
        &#125;,
      &#125;);
    &#125;
    if (this.old) &#123;
      this.old &#x3D; false;
      this._value &#x3D; this.effect.runner();
      triggerEffect(this.dep);
    &#125;
    return this._value;
  &#125;

  set value(_) &#123;
    console.warn(&#39;Can not set computed value&#39;);
  &#125;
&#125;

export function computed(origin) &#123;
  return new ComputedImpl(origin);
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>- 重构: 考虑修改 <code>EffectReactive</code> 构造函数</p><h3 id="总结">总结</h3><ul><li>实现 <code>Reactivity</code> 的核心就是一个 <code>Proxy</code>. 通过修改 <code>[GET]</code> &amp; <code>[SET]</code> 实现不同权限</li><li>时刻谨记 JavaScript 是动态语言, 对象上的属性随时在变化, 不要想在某一个对对象上的属性做特殊处理, 很容易遗漏, 我们可以想想什么时候外部需要我们特殊处理的特性, 在出口处"围追堵截"</li><li>注意我们应该在什么时候抽象函数<ul><li>语义上可以抽象时候</li><li>功能重复时</li></ul></li><li>当函数功能部分重叠时要敢于拆分函数</li><li><code>ref</code> 相当于是一个整体功能弱化的 <code>reactive</code>, 所以我们没有使用全局 <code>targetMap</code></li><li><code>computed</code> 的实现比较巧妙, 运用了一个 effect 的配置项, 我们在实现工具函数的时候也可以想想是否可以通过配置项将两个功能类似的类合并成一个类.</li></ul><h2 id="实现-runtime-core">实现 runtime-core</h2><h3 id="搭建环境">搭建环境</h3><p>runtime-core 直接参与页面构建, 我们需要利用打包工具打包代码. 在打包网页时一般使用 webpack, 而在打包模块时一般使用 rollup.js. 安装 rollup 及其 TypeScript 依赖</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">pnpm i -D rollup @rollup&#x2F;plugin-typescript tslib rollup-plugin-sourcemaps
#         ^ 本体  ^ typescript 支持          ^ TS 支持依赖<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>配置 rollup</p><ul><li>创建 <code>/package/index.ts</code> 作为整个项目的出口</li><li>创建 rollup 配置文件 <code>/package/rollup.config.js</code><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript"><span class="token keyword">import</span> typescript <span class="token keyword">from</span> <span class="token string">'@rollup/plugin-typescript'</span><span class="token punctuation">;</span>
<span class="token keyword">import</span> sourceMaps <span class="token keyword">from</span> <span class="token string">'rollup-plugin-sourcemaps'</span><span class="token punctuation">;</span>

<span class="token keyword">export</span> <span class="token keyword">default</span> <span class="token punctuation">&#123;</span>
  <span class="token literal-property property">input</span><span class="token operator">:</span> <span class="token string">'./packages/index.ts'</span><span class="token punctuation">,</span> <span class="token comment">// 入口文件</span>
  <span class="token literal-property property">output</span><span class="token operator">:</span> <span class="token punctuation">[</span>
    <span class="token comment">// 2种输出格式</span>
    <span class="token punctuation">&#123;</span>
      <span class="token literal-property property">format</span><span class="token operator">:</span> <span class="token string">'cjs'</span><span class="token punctuation">,</span> <span class="token comment">// 输出格式</span>
      <span class="token literal-property property">file</span><span class="token operator">:</span> <span class="token string">'./lib/micro-vue.cjs.js'</span><span class="token punctuation">,</span> <span class="token comment">// 输出路径</span>
      <span class="token literal-property property">sourcemap</span><span class="token operator">:</span> <span class="token boolean">true</span><span class="token punctuation">,</span>
    <span class="token punctuation">&#125;</span><span class="token punctuation">,</span>
    <span class="token punctuation">&#123;</span>
      <span class="token literal-property property">format</span><span class="token operator">:</span> <span class="token string">'es'</span><span class="token punctuation">,</span>
      <span class="token literal-property property">file</span><span class="token operator">:</span> <span class="token string">'./lib/micro-vue.esm.js'</span><span class="token punctuation">,</span>
      <span class="token literal-property property">sourcemap</span><span class="token operator">:</span> <span class="token boolean">true</span><span class="token punctuation">,</span>
    <span class="token punctuation">&#125;</span><span class="token punctuation">,</span>
  <span class="token punctuation">]</span><span class="token punctuation">,</span>
  <span class="token literal-property property">plugins</span><span class="token operator">:</span> <span class="token punctuation">[</span><span class="token function">typescript</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token function">sourceMaps</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">]</span><span class="token punctuation">,</span>
<span class="token punctuation">&#125;</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li><li>执行 <code>rollup -c ./rollup.config.js</code> 打包</li><li>根据提示将 <code>tsconfig.json</code> 中 <code>"module": "commonjs"</code> 改为 <code>"module": "ESNext"</code></li><li>在 <code>package.json</code> 中注册包的入口文件, <code>main</code> 对应 commonjs 包, <code>module</code> 对应 ESM 包<pre class="line-numbers language-json" data-language="json"><code class="language-json">&quot;main&quot;: &quot;lib&#x2F;micro-vue.cjs.js&quot;,
&quot;module&quot;: &quot;lib&#x2F;micro-vue.esm.js&quot;,<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre></li></ul><h3 id="构造测试用例">构造测试用例</h3><p>我们构造一个简单的 Vue demo 并尝试构建 vue-runtime 主流程使其可以将我们的 demo 渲染出来, Vue 项目一般包含如下文件</p><ul><li><code>index.html</code>: 至少包含一个挂载点</li><li><code>index.js</code>: 引入根组件, 将根组件挂载到挂载点</li><li><code>App.vue</code>: 定义根组件</li></ul><p>SFC 需要 vue-loader 编译才能实现. 而 vue-loader 的作用是将 SFC 处理为 <code>render</code> 函数, 在此我们只能先将 <code>App.vue</code> 处理为 vue-loader 编译后函数. 定义</p><ul><li><code>index.html</code>: 只构造一个挂载点并引入 JS<pre class="line-numbers language-markup" data-language="markup"><code class="language-markup"><span class="token doctype"><span class="token punctuation">&lt;!</span><span class="token doctype-tag">DOCTYPE</span> <span class="token name">html</span><span class="token punctuation">></span></span>
<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>html</span> <span class="token attr-name">lang</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>en<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>
  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>head</span><span class="token punctuation">></span></span>
    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>meta</span> <span class="token attr-name">charset</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>UTF-8<span class="token punctuation">"</span></span> <span class="token punctuation">/></span></span>
    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>meta</span> <span class="token attr-name">http-equiv</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>X-UA-Compatible<span class="token punctuation">"</span></span> <span class="token attr-name">content</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>IE=edge<span class="token punctuation">"</span></span> <span class="token punctuation">/></span></span>
    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>meta</span> <span class="token attr-name">name</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>viewport<span class="token punctuation">"</span></span> <span class="token attr-name">content</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>width=device-width, initial-scale=1.0<span class="token punctuation">"</span></span> <span class="token punctuation">/></span></span>
    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>title</span><span class="token punctuation">></span></span>micro-vue runtime-core<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>title</span><span class="token punctuation">></span></span>
  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>head</span><span class="token punctuation">></span></span>
  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>body</span><span class="token punctuation">></span></span>
    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>div</span> <span class="token attr-name">id</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>app<span class="token punctuation">"</span></span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>div</span><span class="token punctuation">></span></span>
    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>script</span> <span class="token attr-name">src</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>./index.js<span class="token punctuation">"</span></span> <span class="token attr-name">type</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>model<span class="token punctuation">"</span></span><span class="token punctuation">></span></span><span class="token script"></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>script</span><span class="token punctuation">></span></span>
  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>body</span><span class="token punctuation">></span></span>
<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>html</span><span class="token punctuation">></span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li><li><code>index.js</code>: 先不管有没有这些函数, 平时咋写就咋写<pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript"><span class="token keyword">import</span> <span class="token punctuation">&#123;</span> createApp <span class="token punctuation">&#125;</span> <span class="token keyword">from</span> <span class="token string">'../../lib/micro-vue.esm'</span><span class="token punctuation">;</span>
<span class="token keyword">import</span> App <span class="token keyword">from</span> <span class="token string">'./App'</span><span class="token punctuation">;</span>

<span class="token function">createApp</span><span class="token punctuation">(</span>App<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">mount</span><span class="token punctuation">(</span><span class="token string">'#app'</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre></li><li><code>App.js</code>:<pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript"><span class="token keyword">import</span> <span class="token punctuation">&#123;</span> h <span class="token punctuation">&#125;</span> <span class="token keyword">from</span> <span class="token string">'../../lib/micro-vue.esm.js'</span><span class="token punctuation">;</span>

<span class="token keyword">export</span> <span class="token keyword">default</span> <span class="token punctuation">&#123;</span>
  <span class="token function">setup</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span><span class="token punctuation">&#125;</span><span class="token punctuation">,</span>
  <span class="token function">render</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
    <span class="token keyword">return</span> <span class="token function">h</span><span class="token punctuation">(</span><span class="token string">'div'</span><span class="token punctuation">,</span> <span class="token punctuation">&#123;</span> <span class="token keyword">class</span><span class="token operator">:</span> <span class="token string">'title'</span> <span class="token punctuation">&#125;</span><span class="token punctuation">,</span> <span class="token punctuation">[</span>
      <span class="token function">h</span><span class="token punctuation">(</span><span class="token string">'span'</span><span class="token punctuation">,</span> <span class="token punctuation">&#123;</span><span class="token punctuation">&#125;</span><span class="token punctuation">,</span> <span class="token string">"111"</span><span class="token punctuation">)</span><span class="token punctuation">,</span>
      <span class="token function">h</span><span class="token punctuation">(</span><span class="token string">'span'</span><span class="token punctuation">,</span> <span class="token punctuation">&#123;</span><span class="token punctuation">&#125;</span><span class="token punctuation">,</span> <span class="token string">"222"</span><span class="token punctuation">)</span><span class="token punctuation">,</span>
    <span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">&#125;</span><span class="token punctuation">,</span>
<span class="token punctuation">&#125;</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li></ul><p><code>App.js</code> 默认导出了一个配置对象, 该对象应该包含 SFC 中导出的 <code>setup</code> 与 vue-loader 编译得到的 <code>render</code> 函数. 其中</p><ul><li><code>setup</code> 函数的返回值可以是对象, 也可以是渲染函数</li><li>在解析 SFC 文件时, 如果用户手动通过 <code>setup</code> 返回了渲染函数那么 vue-loader 就不编译模板, 如果没有返回则编译模板并构造渲染函数 <code>render</code>. <code>render</code> 函数描述了<strong>这个组件里面</strong>应该如何渲染</li><li><code>render</code> 中的 <code>h</code> 用于表述一个组件/元素, 语法为: <code>h(type, attr, children)</code>.<ul><li><code>type</code>: 描述元素或组件类型, 如果希望将目标渲染为 Element 那么 <code>type</code> 为标签名, 如果希望渲染为组件那么 <code>type</code> 为 组件配置对象</li><li><code>attr</code>: 描述元素或组件上的属性(例如: <code>class</code>)</li><li><code>children</code>:<ul><li>如果待渲染的是一个元素, 如果这个元素下面没有子元素或者子组件, 那么 <code>children</code> 为元素的 <code>innerText</code>, 如果下面还有子组件或子元素, 那么 <code>children</code> 应该是一个 <code>h</code> 函数返回值数组</li><li><strong>如果待渲染的是一个组件, <code>children</code> 属性将传入插槽而不是子元素, 这一点与模板设计是类似的</strong><pre class="line-numbers language-markup" data-language="markup"><code class="language-markup"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>template</span><span class="token punctuation">></span></span>
  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>div</span><span class="token punctuation">></span></span>
    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>span</span><span class="token punctuation">></span></span>111<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>span</span><span class="token punctuation">></span></span>
    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>span</span><span class="token punctuation">></span></span>222<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>span</span><span class="token punctuation">></span></span>
  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>div</span><span class="token punctuation">></span></span>
<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>template</span><span class="token punctuation">></span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>的 <code>h</code> 函数<pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript"><span class="token function">h</span><span class="token punctuation">(</span><span class="token string">'div'</span><span class="token punctuation">,</span> <span class="token punctuation">&#123;</span><span class="token punctuation">&#125;</span><span class="token punctuation">,</span> <span class="token punctuation">[</span><span class="token function">h</span><span class="token punctuation">(</span><span class="token string">'span'</span><span class="token punctuation">,</span> <span class="token punctuation">&#123;</span><span class="token punctuation">&#125;</span><span class="token punctuation">,</span> <span class="token string">'111'</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token function">h</span><span class="token punctuation">(</span><span class="token string">'span'</span><span class="token punctuation">,</span> <span class="token punctuation">&#123;</span><span class="token punctuation">&#125;</span><span class="token punctuation">,</span> <span class="token string">'222'</span><span class="token punctuation">)</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>对于组件<pre class="line-numbers language-markup" data-language="markup"><code class="language-markup"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>template</span><span class="token punctuation">></span></span>
  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>Comp</span><span class="token punctuation">></span></span>
    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>span</span><span class="token punctuation">></span></span>111<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>span</span><span class="token punctuation">></span></span>
    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>span</span><span class="token punctuation">></span></span>222<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>span</span><span class="token punctuation">></span></span>
  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>Comp</span><span class="token punctuation">></span></span>
<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>template</span><span class="token punctuation">></span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>的 <code>h</code> 函数<pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript"><span class="token function">h</span><span class="token punctuation">(</span>Comp<span class="token punctuation">,</span> <span class="token punctuation">&#123;</span><span class="token punctuation">&#125;</span><span class="token punctuation">,</span> <span class="token punctuation">[</span><span class="token function">h</span><span class="token punctuation">(</span><span class="token string">'span'</span><span class="token punctuation">,</span> <span class="token punctuation">&#123;</span><span class="token punctuation">&#125;</span><span class="token punctuation">,</span> <span class="token string">'111'</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token function">h</span><span class="token punctuation">(</span><span class="token string">'span'</span><span class="token punctuation">,</span> <span class="token punctuation">&#123;</span><span class="token punctuation">&#125;</span><span class="token punctuation">,</span> <span class="token string">'222'</span><span class="token punctuation">)</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>设计上是统一的.</li></ul></li></ul></li></ul><p>上面这个例子描述了这样一个组件:</p><ul><li><p>首先默认导出的是一个组件配置对象</p></li><li><p>这个组件被编译为了 <code>render</code> 函数, <code>render</code> 函数返回了一个 <code>h</code>.</p><ul><li><p><strong>诶, 我要渲染一个组件, 为啥 <code>h</code> 的 <code>type</code> 是 <code>div</code> 而不是配置对象呢?</strong> 一定注意, <code>render</code> 描述的是组件<strong>里面</strong>应该如何渲染, 这里的 <code>h</code> 是说, App 组件里面有一个 <code>div</code>, 如果我们这里写的是 <code>h(demoObj, &#123;&#125;, '111')</code> 这个意思是 App 组件里面有一个 demo 组件, 这个 demo 组件里面啥也没有, 他的 innerText 是 '111'</p></li><li><p><strong>诶, 那我们在哪里定义了 App 的 h 函数呢?</strong> 我们没有用 <code>h</code> 函数定义 App (是利用 createApp 定义的) 至于这俩函数有什么联系后面再说</p></li><li><p><strong>诶, 那难道组件内部只能有一个一级子元素?</strong> 是的, 在 Vue2 中我们就规定 <code>template</code> 下最多只能有一个一级子元素, 在 Vue3 中我们用语法糖解除了这个限制. 你可能会想到对于 App 下的某个组件(如 demo), 我们通过这样的方式让这个组件有多个子元素</p><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript"><span class="token comment">// App.js 的 render</span>
<span class="token function">render</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
    <span class="token keyword">return</span> <span class="token function">h</span><span class="token punctuation">(</span>demoConfig<span class="token punctuation">,</span> <span class="token punctuation">&#123;</span> <span class="token keyword">class</span><span class="token operator">:</span> <span class="token string">'title'</span> <span class="token punctuation">&#125;</span><span class="token punctuation">,</span> <span class="token punctuation">[</span>
        <span class="token function">h</span><span class="token punctuation">(</span><span class="token string">'span'</span><span class="token punctuation">,</span> <span class="token punctuation">&#123;</span><span class="token punctuation">&#125;</span><span class="token punctuation">,</span> <span class="token string">"111"</span><span class="token punctuation">)</span><span class="token punctuation">,</span>
        <span class="token function">h</span><span class="token punctuation">(</span><span class="token string">'span'</span><span class="token punctuation">,</span> <span class="token punctuation">&#123;</span><span class="token punctuation">&#125;</span><span class="token punctuation">,</span> <span class="token string">"222"</span><span class="token punctuation">)</span><span class="token punctuation">,</span>
    <span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>这是错的, 数组将作为插槽传入 demo 组件, 组件的子元素是在组件自己的 <code>render</code> 中定义的.</p><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript">
demoConfig <span class="token operator">=</span> <span class="token punctuation">&#123;</span>
  <span class="token function">render</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>
    <span class="token keyword">return</span> <span class="token function">h</span><span class="token punctuation">(</span><span class="token string">'div'</span><span class="token punctuation">,</span> <span class="token punctuation">&#123;</span><span class="token punctuation">&#125;</span><span class="token punctuation">,</span> <span class="token punctuation">[</span>
        <span class="token function">h</span><span class="token punctuation">(</span><span class="token string">'span'</span><span class="token punctuation">,</span> <span class="token punctuation">&#123;</span><span class="token punctuation">&#125;</span><span class="token punctuation">,</span> <span class="token string">"111"</span><span class="token punctuation">)</span><span class="token punctuation">,</span>
        <span class="token function">h</span><span class="token punctuation">(</span><span class="token string">'span'</span><span class="token punctuation">,</span> <span class="token punctuation">&#123;</span><span class="token punctuation">&#125;</span><span class="token punctuation">,</span> <span class="token string">"222"</span><span class="token punctuation">)</span><span class="token punctuation">,</span>
    <span class="token punctuation">]</span><span class="token punctuation">)</span>
  <span class="token punctuation">&#125;</span>
<span class="token punctuation">&#125;</span>

<span class="token comment">// App.js 的 render</span>
<span class="token function">render</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
    <span class="token keyword">return</span> <span class="token function">h</span><span class="token punctuation">(</span>demoConfig<span class="token punctuation">,</span> <span class="token punctuation">&#123;</span> <span class="token keyword">class</span><span class="token operator">:</span> <span class="token string">'title'</span> <span class="token punctuation">&#125;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>其实我们的疑问就是到底是他妈的谁构造了根组件 <code>App</code> 的 <code>h</code> 函数</p></li></ul></li><li><p>App 是一个组件, 这个组件内部有一个 <code>div</code> 这个 <code>div</code> 又有两个子<code>span</code>, 内容分别是 <code>111</code> 和 <code>222</code></p></li></ul><h3 id="构造主流程">构造主流程</h3><ul><li><p><code>vue-runtime</code> 的主流程</p><pre class="mermaid">  graph TB
根组件配置对象 --createApp--> 一种特殊的vNode --挂载根组件--> 根组件特殊使命结束,成为普通的组件 --渲染--> 进入patch函数 --目标是Element--> Element处理函数 --新Element--> 挂载Element --没有子Element --> 写入innerText
挂载Element --有子Element--> 每个子Element --渲染--> 进入patch函数
Element处理函数 --老Element--> 更新Element
进入patch函数 --目标是组件--> 组件处理函数 --新组件--> 新建组件 --> 应用配置 --> 运行render --> 每个子组件 --渲染--> 进入patch函数
组件处理函数 --老组件--> 更新组件</pre></li><li><p>可以看到 <code>createApp</code> 输入配置对象, <code>h</code> 函数输入 <code>type</code>(可以是string可以是配置对象), <code>props</code>, <code>children</code>. 虽然两者输入不同, 但是他们都返回了 vNode. <code>createApp</code> 的输入可以看作是没有 <code>props</code>, <code>children</code> 的 <code>h</code> 函数的组件输入, 而 <code>createApp</code> 的输出可以看作是具有特殊功能的 <code>h</code> 输出. 实际上 <code>createApp</code> 与 <code>h</code> 在底层都依赖了 <code>createVNode</code> 函数.</p></li><li><p>vue 渲染中对象发生了如下变化:</p><pre class="mermaid">  graph LR
组件/元素配置对象 --> 虚拟节点vNode --> 实例对象 --> DOM</pre><ul><li>组件配置对象包含了 <code>render</code>, <code>setup</code></li><li><code>vNode</code> 在配置对象的基础上加入了部分属性</li><li>实例对象又在 <code>vNode</code> 的基础上加入了属性</li><li>最后挂载为 DOM</li></ul></li></ul><p><code>vue-runtime</code> 对外暴露函数只有 <code>createApp</code> 我们从这个函数入手</p><ul><li><p><code>createApp</code> 创建了 app 组件 <code>vNode</code>, 同时这个的 <code>vNode</code> 还应该有 <code>mount</code> 函数(唯一特殊的地方)</p><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript"><span class="token comment">// @packages/runtime-core/src/createApp.ts</span>
<span class="token keyword">import</span> <span class="token punctuation">&#123;</span> createVNode <span class="token punctuation">&#125;</span> <span class="token keyword">from</span> <span class="token string">'./vnode'</span><span class="token punctuation">;</span>
<span class="token keyword">import</span> <span class="token punctuation">&#123;</span> render <span class="token punctuation">&#125;</span> <span class="token keyword">from</span> <span class="token string">'./render'</span><span class="token punctuation">;</span>

<span class="token keyword">export</span> <span class="token keyword">function</span> <span class="token function">createApp</span><span class="token punctuation">(</span><span class="token parameter">rootComponent</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
  <span class="token keyword">return</span> <span class="token punctuation">&#123;</span>
    <span class="token literal-property property">_component</span><span class="token operator">:</span> rootComponent<span class="token punctuation">,</span>
    <span class="token function">mount</span><span class="token punctuation">(</span><span class="token parameter">container</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
      <span class="token keyword">const</span> vNode <span class="token operator">=</span> <span class="token function">createVNode</span><span class="token punctuation">(</span>rootComponent<span class="token punctuation">)</span><span class="token punctuation">;</span>
      <span class="token function">render</span><span class="token punctuation">(</span>vNode<span class="token punctuation">,</span> document<span class="token punctuation">.</span><span class="token function">querySelector</span><span class="token punctuation">(</span>container<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">&#125;</span><span class="token punctuation">,</span>
  <span class="token punctuation">&#125;</span><span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li><li><p><code>createVnode</code>: 收到配置对象, <code>props</code>, <code>children</code> 将他们作为一个对象存起来(API 与 <code>h</code> 函数一样)</p><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript"><span class="token comment">// @packages/runtime-core/src/vnode.ts</span>
<span class="token keyword">export</span> <span class="token keyword">function</span> <span class="token function">createVNode</span><span class="token punctuation">(</span><span class="token parameter">component<span class="token punctuation">,</span> props <span class="token operator">=</span> <span class="token punctuation">&#123;</span><span class="token punctuation">&#125;</span><span class="token punctuation">,</span> children <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span></span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
  <span class="token keyword">return</span> <span class="token punctuation">&#123;</span>
    <span class="token literal-property property">type</span><span class="token operator">:</span> component<span class="token punctuation">,</span>
    props<span class="token punctuation">,</span>
    children<span class="token punctuation">,</span>
  <span class="token punctuation">&#125;</span><span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li><li><p><code>render</code> 负责渲染 <code>vNode</code>, 但是 <code>render</code> 什么都没做, 只是调用了 <code>patch</code>. 这里多此一举是为了方便之后部署子元素时递归方便</p><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript"><span class="token comment">// @packages/runtime-core/src/render.ts</span>
<span class="token keyword">export</span> <span class="token keyword">function</span> <span class="token function">render</span><span class="token punctuation">(</span><span class="token parameter">vNode<span class="token punctuation">,</span> container</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
  <span class="token function">patch</span><span class="token punctuation">(</span><span class="token keyword">null</span><span class="token punctuation">,</span> vNode<span class="token punctuation">,</span> container<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 第一次创建没有老元素</span>
<span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre></li><li><p><code>patch</code> 函数收入更新前后节点与挂载点(新节点的挂载前节点为 <code>null</code>), 针对不同节点类型调用不同处理函数</p><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript"><span class="token comment">// @packages/runtime-core/src/render.ts</span>
<span class="token keyword">export</span> <span class="token keyword">function</span> <span class="token function">patch</span><span class="token punctuation">(</span><span class="token parameter">vNode1<span class="token punctuation">,</span> vNode2<span class="token punctuation">,</span> container</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
  <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">isObject</span><span class="token punctuation">(</span>vNode2<span class="token punctuation">.</span>type<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token function">processComponent</span><span class="token punctuation">(</span>vNode1<span class="token punctuation">,</span> vNode2<span class="token punctuation">,</span> container<span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token keyword">else</span> <span class="token function">processElement</span><span class="token punctuation">(</span>vNode1<span class="token punctuation">,</span> vNode2<span class="token punctuation">,</span> container<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre></li><li><p><code>processComponent</code> 处理组件</p><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript"><span class="token comment">// @packages/runtime-core/src/render.ts</span>
<span class="token keyword">function</span> <span class="token function">processComponent</span><span class="token punctuation">(</span><span class="token parameter">vNode1<span class="token punctuation">,</span> vNode2<span class="token punctuation">,</span> container</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
  <span class="token keyword">if</span> <span class="token punctuation">(</span>vNode1<span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token function">updateComponent</span><span class="token punctuation">(</span>vNode1<span class="token punctuation">,</span> vNode2<span class="token punctuation">,</span> container<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 老元素就 update</span>
  <span class="token keyword">return</span> <span class="token function">mountComponent</span><span class="token punctuation">(</span>vNode2<span class="token punctuation">,</span> container<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//  新元素就挂载</span>
<span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><code>updateComponent</code> 暂时没有必要实现</p></li><li><p><code>mountComponent</code> 挂载组件. 首先明确组件自己是没有 HTML 标签的, 挂载组件实际上是挂载组件中的子元素. 而组件存在的必要是其导出的 setup 函数中存在子元素需要的变量与函数.</p><p>我们构建组件实例在上面记录组件需要的上下文</p><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript"><span class="token comment">// @packages/runtime-core/src/render.ts</span>
<span class="token keyword">function</span> <span class="token function">mountComponent</span><span class="token punctuation">(</span><span class="token parameter">vNode<span class="token punctuation">,</span> container</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
  <span class="token keyword">const</span> instance <span class="token operator">=</span> <span class="token function">createComponent</span><span class="token punctuation">(</span>vNode<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 创建实例</span>
  <span class="token function">setupComponent</span><span class="token punctuation">(</span>instance<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 配置实例</span>
  <span class="token function">setupRenderEffect</span><span class="token punctuation">(</span>instance<span class="token punctuation">.</span>render<span class="token punctuation">,</span> container<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 部署实例</span>
<span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li><li><p><code>createComponent</code> 用于创建组件实例, 为了方便我们将组件的 type 提到实例上</p><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript"><span class="token comment">// @packages/runtime-core/src/componment.ts</span>
<span class="token keyword">export</span> <span class="token keyword">function</span> <span class="token function">createComponent</span><span class="token punctuation">(</span><span class="token parameter">vNode</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
  <span class="token keyword">return</span> <span class="token punctuation">&#123;</span>
    vNode<span class="token punctuation">,</span>
    <span class="token literal-property property">type</span><span class="token operator">:</span> vNode<span class="token punctuation">.</span>type<span class="token punctuation">,</span> <span class="token comment">// 图方便</span>
    <span class="token literal-property property">render</span><span class="token operator">:</span> <span class="token keyword">null</span><span class="token punctuation">,</span>
  <span class="token punctuation">&#125;</span><span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li><li><p><code>setupComponent</code> 用于创建实例, 配置实例, 包括初始化 props, slots, 处理 setup 导出的变量等. 这里我们先不处理 props, slot, 忽略 setup 导出的变量后的归属问题, 只解决</p><ul><li>如果有 <code>setup</code> 就执行 <code>setup</code>, 如果执行结果是对象就将导出对象绑定到 instance 上, 如果是函数就把他当成 <code>render</code> 函数</li><li>如果没 <code>render</code> 就从 <code>vNode</code> 的 <code>type</code> 上读取 <code>render</code></li></ul><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript"><span class="token comment">// @packages/runtime-core/src/componment.ts</span>
<span class="token keyword">export</span> <span class="token keyword">function</span> <span class="token function">setupComponent</span><span class="token punctuation">(</span><span class="token parameter">instance</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
  <span class="token comment">// initProp</span>
  <span class="token comment">// initSlot</span>
  <span class="token function">setupStatefulComponent</span><span class="token punctuation">(</span>instance<span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token function">finishComponentSetup</span><span class="token punctuation">(</span>instance<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span>

<span class="token comment">// 如果有 setup 就处理 setup 函数运行结果</span>
<span class="token keyword">function</span> <span class="token function">setupStatefulComponent</span><span class="token punctuation">(</span><span class="token parameter">instance</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
  <span class="token keyword">if</span> <span class="token punctuation">(</span>instance<span class="token punctuation">.</span>type<span class="token punctuation">.</span>setup<span class="token punctuation">)</span>
    <span class="token function">handleSetupResult</span><span class="token punctuation">(</span>instance<span class="token punctuation">,</span> instance<span class="token punctuation">.</span>type<span class="token punctuation">.</span><span class="token function">setup</span><span class="token punctuation">.</span><span class="token function">call</span><span class="token punctuation">(</span>instance<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  finishComponentSetup<span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span>

<span class="token comment">// 处理 setup 函数运行结果</span>
<span class="token keyword">function</span> <span class="token function">handleSetupResult</span><span class="token punctuation">(</span><span class="token parameter">instance<span class="token punctuation">,</span> res</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
  <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">isFunction</span><span class="token punctuation">(</span>res<span class="token punctuation">)</span><span class="token punctuation">)</span> instance<span class="token punctuation">.</span>render <span class="token operator">=</span> res<span class="token punctuation">;</span>
  <span class="token keyword">else</span> <span class="token punctuation">&#123;</span>
    instance<span class="token punctuation">.</span>setupResult <span class="token operator">=</span> res<span class="token punctuation">;</span>
  <span class="token punctuation">&#125;</span>
  <span class="token function">finishComponentSetup</span><span class="token punctuation">(</span>instance<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span>

<span class="token comment">// 最后兜底获取 render</span>
<span class="token keyword">function</span> <span class="token function">finishComponentSetup</span><span class="token punctuation">(</span><span class="token parameter">instance</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
  instance<span class="token punctuation">.</span>render <span class="token operator">=</span> instance<span class="token punctuation">.</span>render <span class="token operator">||</span> instance<span class="token punctuation">.</span>type<span class="token punctuation">.</span>render<span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li><li><p>构建 <code>instance</code> 之后需要将中的子元素挂载出去, 递归 <code>patch</code> 即可</p><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript"><span class="token comment">// @packages/runtime-core/src/componment.ts</span>
<span class="token keyword">export</span> <span class="token keyword">function</span> <span class="token function">setupRenderEffect</span><span class="token punctuation">(</span><span class="token parameter">render<span class="token punctuation">,</span> container</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
  <span class="token keyword">const</span> subTree <span class="token operator">=</span> <span class="token function">render</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// render 只能返回 h 函数的结果, 所以一定是一个 vNode, 直接 patch 就行</span>
  <span class="token comment">// !</span>
  <span class="token function">patch</span><span class="token punctuation">(</span><span class="token keyword">null</span><span class="token punctuation">,</span> subTree<span class="token punctuation">,</span> container<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li><li><p>类似的实现 Element 处理功能</p><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript"><span class="token comment">// @packages/runtime-core/src/render.ts</span>
<span class="token keyword">function</span> <span class="token function">processElement</span><span class="token punctuation">(</span><span class="token parameter">vNode1<span class="token punctuation">,</span> vNode2<span class="token punctuation">,</span> container</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
  <span class="token keyword">if</span> <span class="token punctuation">(</span>vNode1<span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token function">updateElement</span><span class="token punctuation">(</span>vNode1<span class="token punctuation">,</span> vNode2<span class="token punctuation">,</span> container<span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token keyword">return</span> <span class="token function">mountElement</span><span class="token punctuation">(</span>vNode2<span class="token punctuation">,</span> container<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre></li><li><p>实现挂载 Element</p><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript"><span class="token comment">// @packages/runtime-core/src/render.ts</span>
<span class="token keyword">function</span> <span class="token function">mountElement</span><span class="token punctuation">(</span><span class="token parameter">vNode<span class="token punctuation">,</span> container</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
  <span class="token keyword">const</span> el <span class="token operator">=</span> document<span class="token punctuation">.</span><span class="token function">createElement</span><span class="token punctuation">(</span>vNode<span class="token punctuation">.</span>type<span class="token punctuation">)</span> <span class="token keyword">as</span> HTMLElement<span class="token punctuation">;</span> <span class="token comment">// 构造 DOM 元素</span>
  <span class="token comment">// 添加属性</span>
  Object<span class="token punctuation">.</span><span class="token function">keys</span><span class="token punctuation">(</span>vNode<span class="token punctuation">.</span>props<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">forEach</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token parameter">k</span><span class="token punctuation">)</span> <span class="token operator">=></span> el<span class="token punctuation">.</span><span class="token function">setAttribute</span><span class="token punctuation">(</span>k<span class="token punctuation">,</span> vNode<span class="token punctuation">.</span>props<span class="token punctuation">[</span>k<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token comment">// 有子元素</span>
  <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">isObject</span><span class="token punctuation">(</span>vNode<span class="token punctuation">.</span>children<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
    vNode<span class="token punctuation">.</span>children<span class="token punctuation">.</span><span class="token function">forEach</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token parameter">d</span><span class="token punctuation">)</span> <span class="token operator">=></span> <span class="token punctuation">&#123;</span>
      <span class="token function">patch</span><span class="token punctuation">(</span><span class="token keyword">null</span><span class="token punctuation">,</span> d<span class="token punctuation">,</span> el<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 递归挂载</span>
    <span class="token punctuation">&#125;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">&#125;</span> <span class="token keyword">else</span> el<span class="token punctuation">.</span>textContent <span class="token operator">=</span> vNode<span class="token punctuation">.</span>children<span class="token punctuation">;</span> <span class="token comment">// 没子元素</span>
  container<span class="token punctuation">.</span><span class="token function">appendChild</span><span class="token punctuation">(</span>el<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li><li><p>最后写下 <code>h</code> 函数</p><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript"><span class="token comment">// @packages/runtime-core/src/h.ts</span>
<span class="token keyword">import</span> <span class="token punctuation">&#123;</span> createVNode <span class="token punctuation">&#125;</span> <span class="token keyword">from</span> <span class="token string">"./vnode"</span><span class="token punctuation">;</span>
<span class="token keyword">export</span> <span class="token keyword">const</span> h <span class="token operator">=</span> createVNode<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre></li></ul><h3 id="实现组件实例-proxy">实现组件实例 <code>Proxy</code></h3><p>我们想要让组件可以引用自己导出的变量</p><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript"><span class="token keyword">export</span> <span class="token keyword">default</span> <span class="token punctuation">&#123;</span>
  <span class="token function">setup</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
    <span class="token keyword">return</span> <span class="token punctuation">&#123;</span>
      <span class="token literal-property property">message</span><span class="token operator">:</span> <span class="token function">ref</span><span class="token punctuation">(</span><span class="token string">'micro-vue'</span><span class="token punctuation">)</span><span class="token punctuation">,</span>
    <span class="token punctuation">&#125;</span><span class="token punctuation">;</span>
  <span class="token punctuation">&#125;</span><span class="token punctuation">,</span>
  <span class="token function">render</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
    <span class="token keyword">return</span> <span class="token function">h</span><span class="token punctuation">(</span><span class="token string">'div'</span><span class="token punctuation">,</span> <span class="token punctuation">&#123;</span> <span class="token keyword">class</span><span class="token operator">:</span> <span class="token string">'title'</span> <span class="token punctuation">&#125;</span><span class="token punctuation">,</span> <span class="token string">'hi '</span> <span class="token operator">+</span> <span class="token keyword">this</span><span class="token punctuation">.</span>message<span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">&#125;</span><span class="token punctuation">,</span>
<span class="token punctuation">&#125;</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>但是因为我们直接调用了 <code>render</code> 函数</p><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript"><span class="token comment">// @packages/runtime-core/src/component.ts</span>
<span class="token keyword">export</span> <span class="token keyword">function</span> <span class="token function">setupRenderEffect</span><span class="token punctuation">(</span><span class="token parameter">render<span class="token punctuation">,</span> container</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
  <span class="token keyword">const</span> subTree <span class="token operator">=</span> <span class="token function">render</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token comment">// ...</span>
<span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>所以 <code>render</code> 的 <code>this</code> 是 <code>global</code>, 我们希望 <code>render</code> 的 <code>this</code> 包括 <code>setup</code> 导出的对象与 Vue 3 文档中的<span class="exturl" data-url="aHR0cHM6Ly9jbi52dWVqcy5vcmcvYXBpL2NvbXBvbmVudC1pbnN0YW5jZS5odG1s">组件实例<i class="fa fa-external-link-alt"></i></span>, 所以我们需要构造一个 Proxy 同时实现访问 setup 结果与组件对象</p><ol type="1"><li>处理 setup 导出</li></ol><p><pre class="line-numbers language-typescript" data-language="typescript"><code class="language-typescript">&#x2F;&#x2F; @packages&#x2F;runtime-core&#x2F;src&#x2F;component.ts
function handleSetupResult(instance, res) &#123;
  &#x2F;&#x2F; ...
  instance.setupResult &#x3D; proxyRefs(res);
  &#x2F;&#x2F; ...
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></p><ol start="2" type="1"><li>在结束组件初始化时构造代理对象, 将代理对象作为一个属性插入实例<pre class="line-numbers language-typescript" data-language="typescript"><code class="language-typescript">&#x2F;&#x2F; @packages&#x2F;runtime-core&#x2F;src&#x2F;component.ts
function finishComponentSetup(instance) &#123;
  &#x2F;&#x2F; 声明代理对象
  instance.proxy &#x3D; new Proxy(&#123; instance &#125;, publicInstanceProxy);
  instance.render &#x3D; instance.render || instance.type.render;
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>将 <code>target</code> 定义为 <code>&#123; instance &#125;</code> 看起来很怪, 为啥不直接用 <code>instance</code> 呢? 因为在 DEV 模式下这个对象内部应该还有很多属性, 只不过我们没有考虑</li><li>定义代理<pre class="line-numbers language-typescript" data-language="typescript"><code class="language-typescript">&#x2F;&#x2F; @packages&#x2F;runtime-core&#x2F;src&#x2F;publicInstanceProxy.ts
const specialInstanceKeyMap &#x3D; &#123;
  $el: (instance) &#x3D;&gt; instance.vNode.el,
&#125;;

export const publicInstanceProxy &#x3D; &#123;
  get(target, key, receiver) &#123;
    &#x2F;&#x2F; 如果 setup 导出的对象上有就返回
    if (Reflect.has(target.instance.setupResult, key))
      return Reflect.get(target.instance.setupResult, key);
    &#x2F;&#x2F; 从组件属性上导出属性
    if (key in specialInstanceKeyMap)
      return specialInstanceKeyMap[key](target.instance);
    return target.instance[key];
  &#125;,
&#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li><li>实现 <code>$el</code></li></ol><p>有很多组件实例, 我们暂时只实现 <code>$el</code>. 挂载点应该是 <code>vNode</code> 的属性, 所以我们将挂载点记录在 <code>vNode</code> 上</p><p><pre class="line-numbers language-typescript" data-language="typescript"><code class="language-typescript">&#x2F;&#x2F; @packages&#x2F;runtime-core&#x2F;src&#x2F;vnode.ts
export function createVNode(component, props &#x3D; &#123;&#125;, children &#x3D; []) &#123;
  return &#123;
    &#x2F;&#x2F; ...
    el: null,
  &#125;;
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><code>el</code> 作为组件实例在组件挂载后在 vNode 上更新即可</p><p><pre class="line-numbers language-typescript" data-language="typescript"><code class="language-typescript">&#x2F;&#x2F; @packages&#x2F;runtime-core&#x2F;src&#x2F;publicInstanceProxy.ts
export function setupRenderEffect(instance, container) &#123;
  &#x2F;&#x2F; ...
  instance.vNode.el &#x3D; container;
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre></p><h3 id="实现-shapeflags">实现 <code>shapeFlags</code></h3><p>可以将组件类型判断抽出为一个变量, 通过位运算判断组件类型. 我们目前需要判断的有:</p><ul><li>是否是 <code>Element</code></li><li>是否是有 <code>setup</code> 的组件(也叫 stateful component)</li><li>子节点是 string 还是数组</li></ul><p>实现</p><ul><li>修改 <code>vNode</code> 定义<pre class="line-numbers language-typescript" data-language="typescript"><code class="language-typescript">export function createVNode(component, props &#x3D; &#123;&#125;, children &#x3D; []) &#123;
  return &#123;
    shapeFlags: getShapeFlags(component, children),
    &#x2F;&#x2F; ...
  &#125;;
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li><li>判断函数<pre class="line-numbers language-typescript" data-language="typescript"><code class="language-typescript">import &#123; isObject &#125; from &#39;..&#x2F;..&#x2F;share&#x2F;index&#39;;

export const enum ShapeFlags &#123;
  ELEMENT &#x3D; 1 &lt;&lt; 0,
  STATEFUL_COMPONENT &#x3D; 1 &lt;&lt; 1,
  TEXT_CHILDREN &#x3D; 1 &lt;&lt; 2,
  ARRAY_CHILDREN &#x3D; 1 &lt;&lt; 3,
&#125;

export function getShapeFlags(type, children) &#123;
  let res &#x3D; 0;
  &#x2F;&#x2F; 注意, 这俩不是互斥的...
  if (!isObject(type)) res |&#x3D; ShapeFlags.ELEMENT;
  else if (type.setup) res |&#x3D; ShapeFlags.STATEFUL_COMPONENT;
  if (isObject(children)) res |&#x3D; ShapeFlags.ARRAY_CHILDREN;
  else res |&#x3D; ShapeFlags.TEXT_CHILDREN;
  return res;
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li><li>同步判断<pre class="line-numbers language-typescript" data-language="typescript"><code class="language-typescript">function setupStatefulComponent(instance) &#123;
  if (instance.vNode.shapeFlags &amp; ShapeFlags.STATEFUL_COMPONENT)
  &#x2F;&#x2F; ...
&#125;

function mountElement(vNode, container) &#123;
  const el &#x3D; document.createElement(vNode.type) as HTMLElement;
  Object.keys(vNode.props).forEach((k) &#x3D;&gt; el.setAttribute(k, vNode.props[k]));
  if (vNode.shapeFlags &amp; ShapeFlags.ARRAY_CHILDREN) &#123;
    &#x2F;&#x2F; ...
  &#125;
  &#x2F;&#x2F; ...
&#125;

export function patch(vNode1, vNode2, container) &#123;
  if (vNode2.shapeFlags &amp; ShapeFlags.ELEMENT)
    processElement(vNode1, vNode2, container);
  &#x2F;&#x2F; ...
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li></ul><h3 id="实现事件注册">实现事件注册</h3><p>我们可以为 Element 传入 attribute, 但是无法传入绑定事件, 例如传入 <code>&#123; onClick: ()=&gt;&#123;&#125; &#125;</code> 在渲染到 DOM 时可以发现渲染结果为</p><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript"><span class="token operator">&lt;</span>div onclick<span class="token operator">=</span><span class="token string">"()=>&#123;&#125;"</span><span class="token operator">></span><span class="token operator">&lt;</span><span class="token operator">/</span>div<span class="token operator">></span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><ul><li><code>onClick</code> 的小驼峰命名没了</li><li>value 应该是一个函数调用, 而这里只写了一个函数, 这样点击时候并不会执行函数只会右查询一下这个函数</li></ul><p>所以我们要手动实现这样的功能: 在挂载 Element 时, 若传入的是事件, 手动绑定这个事件</p><pre class="line-numbers language-typescript" data-language="typescript"><code class="language-typescript">function mountElement(vNode, container) &#123;
  const el &#x3D; document.createElement(vNode.type) as HTMLElement;
  Object.keys(vNode.props).forEach((k) &#x3D;&gt; &#123;
    &#x2F;&#x2F; 通过正则判断是否为事件绑定
    if (&#x2F;^on[A-Z]&#x2F;.test(k))
      el.addEventListener(
        k.replace(&#x2F;^on([A-Z].*)&#x2F;, (_, e) &#x3D;&gt; e[0].toLowerCase() + e.slice(1)),
        vNode.props[k]
      );
    else el.setAttribute(k, vNode.props[k]);
  &#125;);
  &#x2F;&#x2F; ...
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="实现-props">实现 <code>props</code></h3><p><strong>需求:</strong></p><ol type="1"><li>将 props 输入 <code>setup</code>, 使得可以在 <code>setup</code> 中通过 <code>props.属性名</code> 调用, 同时 <code>props</code> 为 shadowReadonly</li><li>在 <code>render</code> 可以通过 <code>this.属性名</code> 调用</li></ol><p><strong>实现:</strong></p><ul><li><p>在 setup 时构造</p><pre class="line-numbers language-typescript" data-language="typescript"><code class="language-typescript">export function setupComponent(instance) &#123;
  &#x2F;&#x2F; ...
  initProps(instance);
  &#x2F;&#x2F; ...
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre></li><li><p>通过第二点我们就知道我们需要将 props 加入 componentPublicProxy</p><pre class="line-numbers language-typescript" data-language="typescript"><code class="language-typescript">export const publicInstanceProxy &#x3D; &#123;
  get(target, key, receiver) &#123;
    &#x2F;&#x2F; ...
    if (key in target.instance.props) return target.instance.props[key];
  	&#x2F;&#x2F; ...
  &#125;,
&#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li><li><p>参考 Vue 的API, 对于第一点需求我们只需要修改 <code>handleSetupResult</code> 的调用, 传入时加入 shadowReadonly</p><pre class="line-numbers language-typescript" data-language="typescript"><code class="language-typescript">handleSetupResult( instance,
      instance.type.setup.call(instance, shadowReadonly(instance.props)&#125;)
);<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>为 setup 传入参数即可</p><pre class="line-numbers language-typescript" data-language="typescript"><code class="language-typescript">setup(props, &#123; emit &#125;) &#123;
    props.foo++; &#x2F;&#x2F; warn: readonly value
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre></li><li><p>我们为啥不把 shadowReadonly 写入 componentPublicProxy 呢? 这样岂不是可以保护 <code>render</code> 中调用不会修改原值? 没有必要, 我们只需要保证浅层 readOnly, 而 render 是直接拿属性名的, 不会修改 props 上的属性定义.</p></li></ul><h3 id="实现-emits">实现 <code>Emits</code></h3><p><strong>需求:</strong></p><p>通过 props 传入一堆 <code>onXxxXxx</code> 函数在 <code>setup</code> 中可以通过 <code>emit(xxxXxx)</code> 调用函数. 其中<code>emit</code> 通过 <code>setup(props, &#123;emit&#125;)</code> 的方式传入.</p><p><strong>注意, 这里就是差一个 <code>on</code></strong>. 你说为啥他妈的你要差个 <code>on</code> 啊, 我写 Vue 的时候也没有差异啊, 这个应该是 vue-loader 为传入的 <code>emit</code> 名加上的 (如: <code>&lt;comp v-on:doSth='xxx'&gt;</code>, 可能会被 vue-loader 转为 <code>&#123; onDoSth: xxx &#125;</code>)</p><p><strong>那么, 难道 <code>props</code> 上的 <code>onDoSth</code> 不会被注册成事件监听吗?</strong> 怎么会, 我们的事件监听是为 Element 绑定的!</p><p><strong>实现:</strong></p><ul><li><p>实现 emit 函数</p><pre class="line-numbers language-typescript" data-language="typescript"><code class="language-typescript">export function emit(instance, event, ...args) &#123;
  let eventName &#x3D; event;
  if (&#x2F;-([a-z])&#x2F;.test(eventName)) &#x2F;&#x2F; 如果是 xxx-xxx 命名法, 将其转换为小驼峰
    eventName &#x3D; eventName.replace(&#x2F;-([a-z])&#x2F;, (_, lc) &#x3D;&gt; lc.toUpperCase());
  if (&#x2F;[a-z].*&#x2F;.test(eventName)) &#x2F;&#x2F; 如果是小驼峰命名法, 将其转换为大驼峰
    eventName &#x3D; eventName[0].toUpperCase() + eventName.slice(1);
  eventName &#x3D; &#39;on&#39; + eventName; &#x2F;&#x2F; 加入 on
  instance.vNode.props[eventName] &amp;&amp; instance.vNode.props[eventName](args);
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li><li><p>将函数加入实例对象 <code>$emit</code></p><pre class="line-numbers language-typescript" data-language="typescript"><code class="language-typescript">const specialInstanceKeyMap &#x3D; &#123;
  $el: (instance) &#x3D;&gt; instance.vNode.el,
  $emit: (instance) &#x3D;&gt; emit.bind(null, instance),
&#125;;

export const publicInstanceProxy &#x3D; &#123;&#x2F;*...*&#x2F;&#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>这里有个比较绕的点, Vue 要求 <code>emit</code> 调用方法为 <code>emit(名字, 函数调用参数)</code>, 我们这边多了一个 <code>instance</code>, 所以我们在定义 <code>$emit</code> 时为函数 bind 第一个参数</p></li><li><p>传入 <code>setup</code> 的调用参数</p><pre class="line-numbers language-typescript" data-language="typescript"><code class="language-typescript">handleSetupResult(
    instance,
    instance.type.setup.call(instance, shadowReadonly(instance.props), &#123;
        emit: instance.proxy.$emit,
    &#125;)
);<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li></ul></div><footer class="post-footer"><p class="post-end-coffee">-------- 本文结束 <i class="fa-solid fa-mug-hot"></i> 感谢阅读 --------</p><div class="popular-posts-header">相关文章</div><ul class="popular-posts"><li class="popular-posts-item"><div class="popular-posts-title"><a href="/article/Vue23基础/" rel="bookmark">Vue2/3入门笔记</a></div></li><li class="popular-posts-item"><div class="popular-posts-title"><a href="/article/Ajax与Axios的使用与关键源码笔记/" rel="bookmark">Ajax与Axios的使用与关键源码笔记</a></div></li><li class="popular-posts-item"><div class="popular-posts-title"><a href="/article/2022寒假字节跳动前端训练营笔记/" rel="bookmark">2022寒假字节跳动前端训练营笔记</a></div></li><li class="popular-posts-item"><div class="popular-posts-title"><a href="/article/BootStrap笔记/" rel="bookmark">BootStrap 笔记</a></div></li><li class="popular-posts-item"><div class="popular-posts-title"><a href="/article/Html5的音视频标签与新增冷门标签/" rel="bookmark">Html5的音视频标签与新增冷门标签</a></div></li></ul><script>let post_body = document.querySelector('.post-body');
  let theme_switch = document.getElementById('theme_switch');
  const theme = {};
  Object.defineProperty(theme, 'value', {
    set(v){
      post_body.setAttribute('theme', v);
      localStorage.setItem('md_theme', v);
      theme_switch.value = v;
    }
  })
  theme.value = localStorage.getItem('md_theme') || 'sneh';
  theme_switch.addEventListener('change',e=>theme.value = e.target.value)
  document.getElementById('theme_switch_wapper').classList.remove('hidden');</script><div class="reward-container"><div></div><button>赞赏</button><div class="post-reward"><div><img src="/images/wechatpay.png" alt="Liu Kairui 微信"> <span>微信</span></div><div><img src="/images/alipay.png" alt="Liu Kairui 支付宝"> <span>支付宝</span></div></div></div><div class="post-copyright"><ul><li class="post-copyright-author"><strong>本文作者： </strong>Liu Kairui</li><li class="post-copyright-link"><strong>本文链接：</strong> <a href="https://blog.liukairui.me/article/%E7%90%86%E8%A7%A3Vue/" title="理解Vue">https://blog.liukairui.me/article/理解Vue/</a></li><li class="post-copyright-license"><strong>版权声明： </strong>本博客所有文章除特别声明外，均采用 <span class="exturl" data-url="aHR0cHM6Ly9jcmVhdGl2ZWNvbW1vbnMub3JnL2xpY2Vuc2VzL2J5LW5jLXNhLzQuMC9kZWVkLnpo"><i class="fab fa-fw fa-creative-commons"></i>BY-NC-SA</span> 许可协议。转载请注明出处！</li></ul></div><div class="post-tags"><a href="/tags/%E5%89%8D%E7%AB%AF/" rel="tag"><i class="fa fa-tag"></i> 前端</a> <a href="/tags/%E7%AC%94%E8%AE%B0/" rel="tag"><i class="fa fa-tag"></i> 笔记</a> <a href="/tags/%E5%89%8D%E7%AB%AF%E6%A1%86%E6%9E%B6/" rel="tag"><i class="fa fa-tag"></i> 前端框架</a> <a href="/tags/Vue/" rel="tag"><i class="fa fa-tag"></i> Vue</a></div><div class="post-nav"><div class="post-nav-item"><a href="/article/%E4%BD%A0%E4%B8%8D%E7%9F%A5%E9%81%93%E7%9A%84JavaScript%E5%AD%A6%E4%B9%A0/" rel="prev" title="《你不知道的JavaScript》学习"><i class="fa fa-chevron-left"></i> 《你不知道的JavaScript》学习</a></div><div class="post-nav-item"></div></div></footer></article></div><div class="comments" id="valine-comments"></div></div></main><footer class="footer"><div class="footer-inner"><div class="copyright">&copy; 2019 – <span itemprop="copyrightYear">2022</span> <span class="with-love"><i class="fa fa-heart"></i> </span><span class="author" itemprop="copyrightHolder">Liu Kairui</span></div><div class="wordcount"><span class="post-meta-item"><span class="post-meta-item-icon"><i class="fa fa-chart-line"></i> </span><span>总字数：</span> <span title="总字数">1.4m</span></span></div><div class="busuanzi-count"><span class="post-meta-item" id="busuanzi_container_site_uv"><span class="post-meta-item-icon"><i class="fa fa-user"></i> </span><span class="site-uv" title="总访客量"><span id="busuanzi_value_site_uv"></span> </span></span><span class="post-meta-item" id="busuanzi_container_site_pv"><span class="post-meta-item-icon"><i class="fa fa-eye"></i> </span><span class="site-pv" title="总访问量"><span id="busuanzi_value_site_pv"></span></span></span></div><div class="powered-by">由 <span class="exturl" data-url="aHR0cHM6Ly9oZXhvLmlv">Hexo</span> & <span class="exturl" data-url="aHR0cHM6Ly90aGVtZS1uZXh0LmpzLm9yZy9taXN0Lw==">NexT.Mist</span> 强力驱动</div><div class="addthis_inline_share_toolbox"><script src="//s7.addthis.com/js/300/addthis_widget.js#pubid=ra-630c5bd30a606ba8" async></script></div><div id="time_and_count"></div><script src="https://cdn.jsdelivr.net/npm/moment@2.22.2/moment.min.js"></script><script src="https://cdn.jsdelivr.net/npm/moment-precise-range-plugin@1.3.0/moment-precise-range.min.js"></script><script>function timer() {
    var ages = moment.preciseDiff(moment(),moment(20201101,"YYYYMMDD"));
    ages = ages.replace(/years?/, "年");
    ages = ages.replace(/months?/, "月");
    ages = ages.replace(/days?/, "天");
    ages = ages.replace(/hours?/, "小时");
    ages = ages.replace(/minutes?/, "分");
    ages = ages.replace(/seconds?/, "秒");
    ages = ages.replace(/\d+/g, '<span class="daysCnt" style="color: #1890ff">$&</span>');
    div.innerHTML = `小站已悄悄运行了 ${ages}`;
    div.className="workDays";
  }
  let div = document.createElement("div");
  let time_and_count = document.getElementById("time_and_count");
  time_and_count.appendChild(div);
  timer();
  setInterval("timer()",1000)</script><script>let footer = document.querySelector('.footer-inner')

let wordCount = document.querySelector('.wordcount')
wordCount.innerHTML = wordCount.innerText.replace('：',': ').replace('m','M')
if(wordCount){
  time_and_count.appendChild(wordCount);
}

let busaunzi = document.querySelector('.busuanzi-count')
if(busaunzi){
  footer.appendChild(busaunzi);
}

let powerby = document.querySelector('.powered-by')
if(powerby){
  footer.appendChild(powerby);
}</script></div></footer><script src="https://cdnjs.cloudflare.com/ajax/libs/animejs/3.2.1/anime.min.js" integrity="sha256-XL2inqUJaslATFnHdJOi9GfQ60on8Wx1C2H8DYiN1xY=" crossorigin="anonymous"></script><script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.6.1/jquery.min.js" integrity="sha256-o88AwQnZB+VDvE9tvIXrMQaPlFFSUTR+nldQm1LuPXQ=" crossorigin="anonymous"></script><script src="https://cdnjs.cloudflare.com/ajax/libs/fancybox/3.5.7/jquery.fancybox.min.js" integrity="sha256-yt2kYMy0w8AbtF89WXb2P1rfjcP/HTHLT7097U8Y5b8=" crossorigin="anonymous"></script><script src="https://cdnjs.cloudflare.com/ajax/libs/pangu/4.0.7/pangu.min.js" integrity="sha256-j+yj56cdEY2CwkVtGyz18fNybFGpMGJ8JxG3GSyO2+I=" crossorigin="anonymous"></script><script src="/js/comments.js"></script><script src="/js/utils.js"></script><script src="/js/motion.js"></script><script src="/js/schemes/muse.js"></script><script src="/js/next-boot.js"></script><script src="https://cdnjs.cloudflare.com/ajax/libs/algoliasearch/4.14.2/algoliasearch-lite.umd.js" integrity="sha256-dImjLPUsG/6p3+i7gVKBiDM8EemJAhQ0VvkRK2pVsQY=" crossorigin="anonymous"></script><script src="https://cdnjs.cloudflare.com/ajax/libs/instantsearch.js/4.45.0/instantsearch.production.min.js" integrity="sha256-356MuKn0s/KnBeNjzWGP1048qENU5M4IiAWc7q9GErU=" crossorigin="anonymous"></script><script src="/js/third-party/search/algolia-search.js"></script><script class="next-config" data-name="pdf" type="application/json">{"object_url":{"url":"https://cdnjs.cloudflare.com/ajax/libs/pdfobject/2.2.8/pdfobject.min.js","integrity":"sha256-tu9j5pBilBQrWSDePOOajCUdz6hWsid/lBNzK4KgEPM="},"url":"/lib/pdf/web/viewer"}</script><script src="/js/third-party/tags/pdf.js"></script><script class="next-config" data-name="mermaid" type="application/json">{"enable":true,"theme":"forest","js":{"url":"https://cdnjs.cloudflare.com/ajax/libs/mermaid/9.1.6/mermaid.min.js","integrity":"sha256-ZfzwelSToHk5YAcr9wbXAmWgyn9Jyq08fSLrLhZE89w="}}</script><script src="/js/third-party/tags/mermaid.js"></script><script src="/js/third-party/fancybox.js"></script><script src="/js/third-party/pace.js"></script><script async src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><script class="next-config" data-name="leancloud_visitors" type="application/json">{"enable":true,"app_id":"ABKlVtS4cyaWYEwunPyK3sXt-9Nh9j0Va","app_key":"xxGXdTTEGEVifs2TLB35844I","server_url":"https://abklvts4.lc-cn-e1-shared.com","security":false}</script><script src="/js/third-party/statistics/lean-analytics.js"></script><script class="next-config" data-name="enableMath" type="application/json">true</script><script class="next-config" data-name="mathjax" type="application/json">{"enable":true,"tags":"none","js":{"url":"https://cdnjs.cloudflare.com/ajax/libs/mathjax/3.2.2/es5/tex-mml-chtml.js","integrity":"sha256-MASABpB4tYktI2Oitl4t+78w/lyA+D7b/s9GEP0JOGI="}}</script><script src="/js/third-party/math/mathjax.js"></script><script src="https://cdnjs.cloudflare.com/ajax/libs/quicklink/2.3.0/quicklink.umd.js" integrity="sha256-yvJQOINiH9fWemHn0vCA5lsHWJaHs6/ZmO+1Ft04SvM=" crossorigin="anonymous"></script><script class="next-config" data-name="quicklink" type="application/json">{"enable":true,"home":false,"archive":false,"delay":true,"timeout":3000,"priority":true,"url":"https://blog.liukairui.me/article/%E7%90%86%E8%A7%A3Vue/"}</script><script src="/js/third-party/quicklink.js"></script><script src="https://unpkg.com/darkmode-js@1.5.7/lib/darkmode-js.min.js"></script><script>var options = {
  bottom: '71px',
  right: 'unset',
  left: '30px',
  time: '0s',
  mixColor: 'transparent',
  backgroundColor: 'transparent',
  buttonColorDark: '#222',
  buttonColorLight: '#222',
  saveInCookies: true,
  label: '',
  autoMatchOsTheme: true
}
const darkmode = new Darkmode(options);
window.darkmode = darkmode;
darkmode.showWidget();</script><script>NexT.utils.loadComments('#valine-comments', () => {
  NexT.utils.getScript('https://cdn.jsdelivr.net/npm/valine@1.4.14/dist/Valine.min.js', () => {
    new Valine(Object.assign({"enable":true,"appId":"ABKlVtS4cyaWYEwunPyK3sXt-9Nh9j0Va","appKey":"xxGXdTTEGEVifs2TLB35844I","serverURLs":"https://abklvts4.lc-cn-e1-shared.com","placeholder":"请开始你的表演","avatar":"identicon","meta":["nick","mail","link"],"pageSize":10,"lang":"zh-CN","visitor":false,"comment_count":true,"recordIP":true,"enableQQ":true,"requiredFields":[]}, {
      el: '#valine-comments',
      path: "/article/%E7%90%86%E8%A7%A3Vue/",
      serverURLs: "https://abklvts4.lc-cn-e1-shared.com"
    }));
  }, window.Valine);
});</script><script src="/live2dw/lib/L2Dwidget.min.js?094cbace49a39548bed64abff5988b05"></script><script>L2Dwidget.init({pluginRootPath:"live2dw/",pluginJsPath:"lib/",pluginModelPath:"assets/",tagMode:!1,log:!1,model:{jsonPath:"/live2dw/assets/hijiki.model.json"},display:{position:"right",width:150,height:300},mobile:{show:!1},react:{opacity:.7}})</script></body></html>